#+TITLE: Daniel Newman's Emacs configuration
#+OPTIONS: toc:4 h:4
* Configuration
** About this file
<<babel-init>>

I've decided to try my hand at using a literate format for my emacs config
with inspiration from [[https://github.com/sachac/.emacs.d][Sacha Chua]] and [[http://eschulte.github.io/emacs24-starter-kit/][eschulte]]
** Personal Information

#+begin_src emacs-lisp
(setq user-full-name "Daniel Newman"
      user-mail-address "dnewman@danlovesprogramming.com")
#+end_src

** Emacs initialization
*** Add package sources

#+begin_src emacs-lisp
    (unless (assoc-default "melpa" package-archives)
      (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
      (package-refresh-contents))
#+end_src


Use =M-x package-refresh-contents= to reload the list of packages
after adding these for the first time.

*** Add my elisp directory and other files

Sometimes I load files outside the package system. As long as they're
in a directory in my =load-path=, Emacs can find them.

#+begin_src emacs-lisp
(add-to-list 'load-path "~/elisp")
(add-to-list 'load-path "~/elisp/artbollocks-mode")
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
(use-package auto-compile
  :ensure t
  :init (auto-compile-on-load-mode))
#+end_src

*** Load Secrets

It's best to keep sensitive information in a separate file so you can publish your config but save private information.

#+begin_src emacs-lisp
(load "~/.emacs.secrets" t)
#+end_src

** General configuration
*** Startup
Don't show the startup screen
#+begin_src emacs-lisp 
(setq inhibit-startup-message t)
#+end_src
[2015-02-21 Sat 21:15]
*** Backups

By default, Emacs saves backup files in the current directory, but I like to save everything in one single directory

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

Save all the things

#+begin_src emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+end_src

*** History

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
	regexp-search-ring))
#+end_src

*** Windows configuration

When you're starting out, tooltips, menus, and the tool bar can be very helpful. [[http://sachachua.com/blog/2014/03/emacs-basics-using-mouse/][(Emacs Basics: Using the Mouse]]). Eventually, you may want to reclaim that extra little bit of screenspace. The following code turns those things off when using a graphical Emacs.

#+begin_src emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode 1)
  (scroll-bar-mode -1))
#+end_src

*** Winner mode - undo and redo window configuration

=winner-mode= lets you use =C-c <left>= and =C-c <right>= to switch between window configurations. This is handy when something has popped up a buffer that you want to look at briefly before returning to whatever you were working on. When you're done, press =C-c <left>=.

#+begin_src emacs-lisp
  (use-package winner
    :ensure winner
    :init (winner-mode 1))
#+end_src
*** Sentences end with a single space

In my world, sentences end with a single space. This makes
sentence navigation commands work for me.

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

*** Helm - interactive completion

Helm makes it easy to complete various things. I find it to be easier
to configure than ido in order to get completion in as many places as
possible, although I prefer ido's way of switching buffers.

#+begin_src emacs-lisp
    (use-package helm
      :ensure helm
      :diminish helm-mode
      :init
      (progn 
        (require 'helm-config) 
        (setq helm-candidate-number-limit 100)
        ;; From https://gist.github.com/antifuchs/9238468
        (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
              helm-input-idle-delay 0.01  ; this actually updates things
                                            ; reeeelatively quickly.
              helm-quick-update t
              helm-M-x-requires-pattern nil
              helm-ff-skip-boring-files t)
        (helm-mode))
      :config
      (progn
        ;; I don't like the way switch-to-buffer uses history, since
        ;; that confuses me when it comes to buffers I've already
        ;; killed. Let's use ido instead.
        (add-to-list 'helm-completing-read-handlers-alist 
                     '(switch-to-buffer . ido))
        (add-to-list 'helm-completing-read-handlers-alist 
                     '(rename-file . ido))
        (add-to-list 'helm-completing-read-handlers-alist 
                     '(dired-rename-file . ido))
        ;; Unicode
        (add-to-list 'helm-completing-read-handlers-alist 
                     '(insert-char . ido)))
      :bind (("C-c h" . helm-mini) 
             ("C-h a" . helm-apropos)
             ("M-y" . helm-show-kill-ring)
             ("M-x" . helm-M-x)
             ("C-x c o" . helm-occur)
             ("C-x c s" . helm-swoop)
             ("C-x c b" . sacha/helm-do-grep-book-notes)
             ("C-x c SPC" . helm-all-mark-rings)))
    (ido-mode -1) ;; Turn off ido mode in case I enabled it accidentally
#+end_src

Great for describing bindings. I'll replace the binding for =where-is= too.

#+begin_src emacs-lisp
(require-package 'helm-descbinds)
(use-package helm-descbinds
  :bind (("C-h b" . helm-descbinds)
         ("C-h w" . helm-descbinds)))
#+end_src

helm-grep? Bit slow and hard to read, though.
#+begin_src emacs-lisp
(defvar sacha/book-notes-directory "~/Dropbox/books")
(defun sacha/helm-do-grep-book-notes ()
  "Search my book notes."
  (interactive)
  (helm-do-grep-1 (list sacha/book-notes-directory)))
#+end_src
*** Mode line format

Display a more compact mode line

#+begin_src emacs-lisp
(use-package smart-mode-line
  :init
  (progn
  (setq-default
   mode-line-format 
   '("%e"
     mode-line-front-space
     mode-line-mule-info
     mode-line-client
     mode-line-modified
     mode-line-remote
     mode-line-frame-identification
     mode-line-buffer-identification
     "   "
     mode-line-position
     (vc-mode vc-mode)
     "  "
     mode-line-modes
     mode-line-misc-info
     mode-line-end-spaces))))
#+end_src

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)   
#+end_src


*** Minibuffer editing - more space!

    Sometimes you want to be able to do fancy things with the text
    that you're entering into the minibuffer. Sometimes you just want
    to be able to read it, especially when it comes to lots of text.
    This binds =C-M-e= in a minibuffer) so that you can edit the
    contents of the minibuffer before submitting it.

#+begin_src emacs-lisp
  (use-package miniedit
    :ensure miniedit
    :commands minibuffer-edit
    :init (miniedit-install))
#+end_src

*** Set up a light-on-dark color scheme

I like light on dark because I find it to be more restful. The
color-theme in ELPA was a little odd, though, so we define some advice to make
it work. Some things still aren't quite right.

#+begin_src emacs-lisp
  (defadvice color-theme-alist (around dnewman activate)
    (if (ad-get-arg 0)
        ad-do-it
      nil))
  (use-package color-theme :ensure t)
  (use-package color-theme-solarized :ensure t)
  (defun sacha/setup-color-theme ()
    (interactive)
    (color-theme-solarized-dark)
    (set-face-foreground 'secondary-selection "darkblue")
    (set-face-background 'secondary-selection "lightblue")
    (set-face-background 'font-lock-doc-face "black")
    (set-face-foreground 'font-lock-doc-face "wheat")
    (set-face-background 'font-lock-string-face "black"))
 
  (use-package color-theme
    :init
    (when window-system
      (sacha/setup-color-theme)))
#+end_src

I sometimes need to switch to a lighter background for screenshots.
For that, I use =color-theme-vim=.

Some more tweaks to solarized:
#+begin_src emacs-lisp
(when window-system
  (custom-set-faces
   '(erc-input-face ((t (:foreground "antique white"))))
   '(helm-selection ((t (:background "ForestGreen" :foreground "black"))))
   '(outline-1 ((t (:inherit font-lock-function-name-face :foreground "cornflower blue"))))))

#+end_src

*** Undo tree mode - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo. 
# 
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure undo-tree
    :diminish undo-tree-mode
    :init
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))
#+end_src

*** Help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+begin_src emacs-lisp
(use-package guide-key
  :diminish guide-key-mode
  :init
  (progn
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)))  ; Enable guide-key-mode
#+end_src


*** UTF-8

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src
*** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el

#+begin_src emacs-lisp
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
      (if mark-active (list (region-beginning) (region-end))
        (list (line-beginning-position)
          (line-beginning-position 2)))))
#+end_src

*** Server
Start a emacs server so new instances aren't created when opening new files
#+begin_src emacs-lisp
(server-start)

#+end_src
[2015-02-11 Wed 22:07]
** Navigation
*** Pop to mark

Handy way of getting back to previous places.

#+begin_src emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+end_src
*** Text size

#+begin_src emacs-lisp
(bind-key "C-+" 'text-scale-increase)
(bind-key "C--" 'text-scale-decrease)
#+end_src

*** Helm-swoop - quickly finding lines

This promises to be a fast way to find things. Let's bind it to =Ctrl-Shift-S= to see if I can get used to that...

#+begin_src emacs-lisp
  (use-package helm-swoop
   :bind
   (("C-S-s" . helm-swoop)
    ("M-i" . helm-swoop)
    ("M-s s" . helm-swoop)
    ("M-s M-s" . helm-swoop)
    ("M-I" . helm-swoop-back-to-last-point)
    ("C-c M-i" . helm-multi-swoop)
    ("C-x M-i" . helm-multi-swoop-all)
    )
   :config
   (progn
     (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
     (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
  )
#+end_src

*** Windmove - switching between windows

Windmove lets you move between windows with something more natural than cycling through =C-x o= (=other-window=).
Windmove doesn't behave well with Org, so we need to use different keybindings.

#+begin_src emacs-lisp
  (use-package windmove
    :bind
    (("<f2> <right>" . windmove-right)
     ("<f2> <left>" . windmove-left)
     ("<f2> <up>" . windmove-up)
     ("<f2> <down>" . windmove-down)
     ))
#+end_src
*** Make window splitting more useful

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury
#+begin_src emacs-lisp
(defun sacha/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (unless prefix
    (switch-to-next-buffer)))
(defun sacha/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (unless prefix (switch-to-next-buffer)))
(bind-key "C-x 2" 'sacha/vsplit-last-buffer)
(bind-key "C-x 3" 'sacha/hsplit-last-buffer)

#+end_src
*** Searching based on the current word

This lets me search up and down. I don't use this often, though.

#+begin_src emacs-lisp
  (defun sacha/search-word-backward ()
    "Find the previous occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-backward "w_")
      (goto-char
       (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
  
  (defun sacha/search-word-forward ()
    "Find the next occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-forward "w_")
      (goto-char
       (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
  (defadvice search-for-keyword (around sacha activate)
    "Match in a case-insensitive way."
    (let ((case-fold-search t))
      ad-do-it))
  (global-set-key '[M-up] 'sacha/search-word-backward)
  (global-set-key '[M-down] 'sacha/search-word-forward)
#+end_src

*** Frequently-accessed files
Registers allow you to jump to a file or other location quickly. To
jump to a register, use =C-x r j= followed by the letter of the
register. Using registers for all these file shortcuts is probably a bit of a waste since I can easily define my own keymap, but since I rarely go beyond register A anyway...

#+begin_src emacs-lisp :results silent
  (mapcar
   (lambda (r)
     (set-register (car r) (cons 'file (cdr r))))
   '((?i . "~/.emacs.d/dnewman.org")
     (?o . "~/.emacs.d/org-mode.org")
     (?t . "~/personal/org/todo.org")))
#+end_src

*** Key chords 
I'm on a Dvorak keyboard, so these might not work for you.
Experimenting with this. =key-chord= lets you define keyboard
shortcuts that use ordinary keys.

Some code from http://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/
#+begin_src emacs-lisp
    (defun sacha/key-chord-define (keymap keys command)
      "Define in KEYMAP, a key-chord of two keys in KEYS starting a COMMAND.
    \nKEYS can be a string or a vector of two elements. Currently only elements
    that corresponds to ascii codes in the range 32 to 126 can be used.
    \nCOMMAND can be an interactive function, a string, or nil.
    If COMMAND is nil, the key-chord is removed.

    MODIFICATION: Do not define the transposed key chord.
    "
      (if (/= 2 (length keys))
          (error "Key-chord keys must have two elements"))
      ;; Exotic chars in a string are >255 but define-key wants 128..255 for those
      (let ((key1 (logand 255 (aref keys 0)))
            (key2 (logand 255 (aref keys 1))))
        (define-key keymap (vector 'key-chord key1 key2) command)))
    (fset 'key-chord-define 'sacha/key-chord-define)

    (defun sacha/switch-to-previous-buffer ()
      "Switch to previously open buffer.
    Repeated invocations toggle between the two most recently open buffers."
      (interactive)
      (switch-to-buffer (other-buffer (current-buffer) 1)))

    (defvar sacha/key-chord-command-map (make-sparse-keymap))
    (bind-key "h" 'emms-pause sacha/key-chord-command-map)
    (bind-key "u" 'emms-pause sacha/key-chord-command-map)
    (bind-key "t" 'emms-seek-backward sacha/key-chord-command-map)
    (bind-key "s" 'emms-seek-to sacha/key-chord-command-map)
    (bind-key "f" 'windmove-right sacha/key-chord-command-map)
    (bind-key "b" 'windmove-left sacha/key-chord-command-map)
    (bind-key "n" 'windmove-down sacha/key-chord-command-map)
    (bind-key "p" 'windmove-up sacha/key-chord-command-map)
#+end_src

I'm trying to get the hang of windmove.
#+begin_src emacs-lisp
  (defvar sacha/windmove-map (make-sparse-keymap))
  (bind-key "h" 'windmove-left sacha/windmove-map)
  (bind-key "t" 'windmove-up sacha/windmove-map)
  (bind-key "n" 'windmove-down sacha/windmove-map)
  (bind-key "s" 'windmove-right sacha/windmove-map)
  (bind-key "<left>" 'windmove-left sacha/windmove-map)
  (bind-key "<up>" 'windmove-up sacha/windmove-map)
  (bind-key "<down>" 'windmove-down sacha/windmove-map)
  (bind-key "<right>" 'windmove-right sacha/windmove-map)
#+end_src

Now let's set up the actual keychords.

#+begin_src emacs-lisp
    (use-package key-chord
      :init
      (progn 
        (fset 'key-chord-define 'sacha/key-chord-define)
        (setq key-chord-one-key-delay 0.16)
        (key-chord-mode 1)
        ;; k can be bound too
        (key-chord-define-global "uu"     'undo)
        (key-chord-define-global "jj"     'ace-jump-word-mode)
        (key-chord-define-global "yy"     sacha/windmove-map)
        ;; y is now free
        (key-chord-define-global "jj"     'ace-jump-word-mode)
        (key-chord-define-global "jw"     'ace-window)
        (key-chord-define-global "jl"     'ace-jump-line-mode)
        ;(key-chord-define-global "jz"     'ace-jump-zap-up-to-char)
        ;(key-chord-define-global "jZ"     'ace-jump-zap-to-char)
        (key-chord-define-global "FF"     'find-file)
        (key-chord-define-global "hh"     sacha/key-chord-command-map)
        (key-chord-define-global "hc"     'emms-seek-forward)
        (key-chord-define-global "xx"     'er/expand-region)
        (key-chord-define-global "  "     'sacha/insert-space-or-expand)
        (key-chord-define-global "JJ"     'sacha/switch-to-previous-buffer)))
#+end_src

*** Smartscan

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el

#+begin_src emacs-lisp
(use-package smartscan
  :init (global-smartscan-mode t))
#+end_src

*** Dired

From http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/

#+begin_src emacs-lisp
(require 'find-dired)
(setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
#+end_src

Borrowed from http://whattheemacsd.com/setup-dired.el-02.html

Allows recursive deletes

#+begin_src emacs-lisp
(setq dired-recursive-deletes 'top)

(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (dired-next-line 4))

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (dired-next-line -1))

(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map
              (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)
            (define-key dired-mode-map
              (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
            ))

#+end_src

*** Move to beginning of line
Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+begin_src emacs-lisp
(defun sacha/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'sacha/smarter-move-beginning-of-line)
#+end_src
*** Recent files

#+begin_src emacs-lisp
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode)
#+end_src
*** Copy filename to clipboard

http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/
https://github.com/bbatsov/prelude

#+begin_src emacs-lisp
(defun prelude-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src
*** Narrowing
From http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
#+begin_src emacs-lisp

(use-package recursive-narrow
  :config
  (add-hook 'recursive-narrow-dwim-functions)
  :bind
  (("C-x n w" . recursive-widen)
   ("C-x n n" . recursive-narrow-or-widen-dwim)))
#+end_src
** Gnus
https://henrikpingel.wordpress.com/2014/07/30/how-to-use-isync-and-the-dovecot-mail-server-to-read-your-gmail-in-emacs-efficiently/
from Henrik Pingel setup of gmail and gnus using isync and dovecot which partial follows Sacha Chua http://sachachua.com/blog/2008/05/geek-how-to-use-offlineimap-and-the-dovecot-mail-server-to-read-your-gmail-in-emacs-efficiently/

#+begin_src emacs-lisp
(setq gnus-select-method
'(nnimap "Mail"
(nnimap-address "localhost")
(nnimap-stream network)
(nnimap-authenticator login)
(nnir-search-engine imap)))
(setq user-mail-address "dwnewman78@gmail.com")
(setq gnus-ignored-from-addresses "dwnewman78@gmail.com")

; set gmail smtp
(setq message-send-mail-function 'smtpmail-send-it
smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
smtpmail-auth-credentials '(("smtp.gmail.com" 587 "dwnewman78@gmail.com" nil))
smtpmail-default-smtp-server "smtp.gmail.com"
smtpmail-smtp-server "smtp.gmail.com"
smtpmail-smtp-service 587)
;      smtpmail-local-domain “yourcompany.com”)
#+end_src
** Reading

https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el
From Xah Lee:

#+begin_src emacs-lisp
(defun xah-toggle-margin-right()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novels or documentation."
  (interactive)
  (if (eq (cdr (windows-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+end_src
** Writing
*** Avoiding weasel words
#+begin_src emacs-lisp
  (use-package artbollocks-mode
    :init
    (progn
      (setq artbollocks-weasel-words-regex
            (concat "\\b" (regexp-opt
	                   '("one of the"
			     "should"
			     "just"
			     "sort of"
			     "a lot"
			     "probably"
			     "maybe"
			     "perhaps"
			     "I think"
			     "really"
			     "pretty"
			     "nice"
			     "action"
			     "utilize"
			     "leverage") t) "\\b"))
       ;; Don't show the art critic words, or at least until I firgure
       ;; out my own jargon
       (setq artbollocks-jargon nil)))
#+end_src

*** Unfill paragraph

I unfill paragraphs a lot because Wordpress likes adding extra =<br>= tags if I don't. (I should probably just tweak my Wordpress installation.)

#+begin_src emacs-lisp
  (defun sacha/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list t)))
    (let ((fill-column (point-max)))
      (fill-paragraph nil region)))
(bind-key "M-Q" 'sacha/unfill-paragraph)
#+end_src

I never actually justify text, so I might as well change the way
=fill-paragraph= works. With the code below, =M-q= will fill the
paragraph normally, and =C-u M-q= will unfill it.

#+begin_src emacs-lisp
  (defun sacha/fill-or-unfill-paragraph (&optional unfill region)
    "Fill paragraph (or REGION).
  With the prefix argument UNFILL, unfill it instead."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list (if current-prefix-arg 'unfill) t)))
    (let ((fill-column (if unfill (point-max) fill-column)))
      (fill-paragraph nil region)))
(bind-key "M-q" 'sacha/fill-or-unfill-paragraph)
#+end_src

Also, =visual-line-mode= is so much better than =auto-fill-mode=. It doesn't actually break the text into multiple lines - it only looks that way.

#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+end_src
*** Unicode

#+begin_src emacs-lisp
(defmacro sacha/insert-unicode (unicode-name)
  `(lambda () (interactive)
     (insert-char (cdr (assoc-string ,unicode-name (ucs-names))))))
(bind-key "C-x 8 s" (sacha/insert-unicode "ZERO WIDTH SPACE"))
(bind-key "C-x 8 S" (sacha/insert-unicode "SNOWMAN"))
#+end_src
*** Clean up spaces

#+begin_src emacs-lisp
  (bind-key "M-SPC" 'cycle-spacing)
#+end_src
*** Expand

#+begin_src emacs-lisp
(bind-key "M-/" 'hippie-expand)
#+end_src
** Org
   I've tried to wrap my head around how Sacha Chua has her org mode setup, but I think I've gotten too use to the way Bernt Hansen has setup. I have used his method for several years and I guess it's just hard coded in my muscle memory.  Nevertheless, I have the config saved in an external file org-mode.org
** Coding
*** Web development
#+begin_src emacs-lisp
  ;; from FAQ at http://web-mode.org/ for smartparens
  (defun sacha/web-mode-hook ()
    (setq web-mode-enable-auto-pairing nil))

  (defun sacha/sp-web-mode-is-code-context (id action context)
    (when (and (eq action 'insert)
               (not (or (get-text-property (point) 'part-side)
                        (get-text-property (point) 'block-side))))
      t))

  (use-package web-mode
    :ensure web-mode
    :init (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    :config
    (progn
      (setq web-mode-enable-current-element-highlight t)
      (setq web-mode-ac-sources-alist
            '(("css" . (ac-source-css-property))
              ("html" . (ac-source-words-in-buffer ac-source-abbrev)))
            )))
#+end_src
*** Tab width of 2 is compact and readable
#+begin_src emacs-lisp
    (setq-default tab-width 2)
#+end_src
*** New lines are always indented

I almost always want to go to the right indentation on the next line.
#+begin_src emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

*** Adapt to being on Windows

I'm on Windows, so I use Cygwin to add Unix-y tools to make my life easier. 
These config snippets seem to help too.
#+begin_src emacs-lisp
  (when (eq system-type 'windows-nt)
	  (setenv "CYGWIN" "nodosfilewarning")
    (setq shell-file-name "C:/emacs/libexec/emacs/24.4/i686-pc-mingw32/cmdproxy.exe")
    (add-hook 'comint-output-filter-functions 'shell-strip-ctrl-m nil t)
    (add-hook 'comint-output-filter-functions 'comint-watch-for-password-prompt nil t))
#+end_src

*** Expand region

This is something I have to get the hang of too. It gradually expands the selection. Handy for Emacs Lisp.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure expand-region
    :bind ("C-=" . er/expand-region))
#+end_src
*** Emacs Lisp
**** Edebug

Did you know edebug has a trace function? I didn't. Thanks, agumonkey!

#+begin_src emacs-lisp
(setq edebug-trace t)
#+end_src

While edebugging, use T to view a trace buffer (=*edebug-trace*=).
Emacs will quickly execute the rest of your code, printing out the
arguments and return values for each expression it evaluates.

**** Eldoc
Eldoc provides minibuffer hints when working with Emacs Lisp.
#+begin_src emacs-lisp
(use-package "eldoc"
  :diminish eldoc-mode
  :commands turn-on-eldoc-mode
  :init
  (progn
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
#+end_src
**** Refactoring  :drill:
     SCHEDULED: <2013-03-03 Sun>
     :PROPERTIES:
     :ID:       99ac7ddb-08ef-46c4-8fa8-8a45164f9ef4
     :DRILL_LAST_INTERVAL: 3.86
     :DRILL_REPEATS_SINCE_FAIL: 2
     :DRILL_TOTAL_REPEATS: 2
     :DRILL_FAILURE_COUNT: 1
     :DRILL_AVERAGE_QUALITY: 2.5
     :DRILL_EASE: 2.36
     :DRILL_LAST_QUALITY: 3
     :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
     :END:

More things that I need to get used to...

#+begin_src emacs-lisp
;; C-c C-v l : elint current buffer in clean environment.
;; C-c C-v L : elint current buffer by multiple emacs binaries.
;;             See `erefactor-lint-emacsen'
;; C-c C-v r : Rename symbol in current buffer.
;;             Resolve `let' binding as long as i can.
;; C-c C-v R : Rename symbol in requiring modules and current buffer.
;; C-c C-v h : Highlight current symbol in this buffer
;;             and suppress `erefacthr-highlight-mode'.
;; C-c C-v d : Dehighlight all by above command.
;; C-c C-v c : Switch prefix bunch of symbols.
;;             ex: '(hoge-var hoge-func) -> '(foo-var foo-func)
;; C-c C-v ? : Display flymake elint warnings/errors

  (use-package erefactor
    :ensure erefactor
    :config
    (define-key emacs-lisp-mode-map "\C-c\C-v" erefactor-map))
#+end_src
**** Jumping to code

#+begin_src emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
(bind-key "C-c f" 'find-function)
#+end_src
**** Sorting

#+begin_src emacs-lisp
  (defun sacha/sort-sexps-in-region (beg end)
    "Can be handy for sorting out duplicates.
Sorts the sexps from BEG to END. Leaves the point at where it
couldn't figure things out (ex: syntax errors)."
    (interactive "r")
    (let ((input (buffer-substring beg end))
          list last-point form result)
      (save-restriction
        (save-excursion
          (narrow-to-region beg end)
          (goto-char (point-min))
          (setq last-point (point-min))
          (setq form t)
          (while (and form (not (eobp)))
            (setq form (ignore-errors (read (current-buffer))))
            (when form
              (add-to-list
               'list
               (cons
                (prin1-to-string form)
                (buffer-substring last-point (point))))
              (setq last-point (point))))
          (setq list (sort list (lambda (a b) (string< (car a) (car b)))))
          (delete-region (point-min) (point))
          (insert (mapconcat 'cdr list "\n"))))))
#+end_src

*** Snippets
    #+begin_src emacs-lisp
      (use-package yasnippet
        :ensure t
        :diminish yas-minor-mode
        :commands yas-global-mode
        :init
        (progn
          (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
          (setq yas-key-syntaxes '("w_" "w_." "^ "))
          (setq yas-snippet-dirs "~/elisp/yasnippet-snippets")
          (setq yas-expand-only-for-last-commands '(self-insert-command))
          (yas-global-mode 1))
        :config
        (bind-key "\t" 'hippie-expand yas-minor-mode-map)
        (add-to-list 'yas-prompt-functions 'shk-yas/helm-prompt))
      ;;        (global-set-key (kbd "C-c y") (lambda () (interactive)
      ;;                                         (yas/load-directory "~/elisp/snippets")))
#+end_src

From http://emacswiki.org/emacs/Yasnippet
#+begin_src emacs-lisp
  (defun shk-yas/helm-prompt (prompt choices &optional display-fn)
    "Use helm to select a snippet. Put this into `yas/prompt-functions.'"
    (interactive)
    (setq display-fn (or display-fn 'identity))
    (if (require 'helm-config)
        (let (tmpsource cands result rmap)
          (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
          (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
          (setq tmpsource
                (list
                 (cons 'name prompt)
                 (cons 'candidates cands)
                 '(action . (("Expand" . (lambda (selection) selection))))
                 ))
          (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
          (if (null result)
              (signal 'quit "user quit!")
            (cdr (assoc result rmap))))
      nil))
#+end_src

From https://github.com/pcmantz/elisp/blob/master/my-bindings.el
#+begin_src emacs-lisp
  (setq default-cursor-color "gray")
  (setq yasnippet-can-fire-cursor-color "purple")

  ;; It will test whether it can expand, if yes, cursor color -> green.
  (defun yasnippet-can-fire-p (&optional field)
    (interactive)
    (setq yas--condition-cache-timestamp (current-time))
    (let (templates-and-pos)
      (unless (and yas-expand-only-for-last-commands
                   (not (member last-command yas-expand-only-for-last-commands)))
        (setq templates-and-pos (if field
                                    (save-restriction
                                      (narrow-to-region (yas--field-start field)
                                                        (yas--field-end field))
                                      (yas--templates-for-key-at-point))
                                  (yas--templates-for-key-at-point))))
      (and templates-and-pos (first templates-and-pos))))

  (defun sacha/change-cursor-color-when-can-expand (&optional field)
    (interactive)
    (set-cursor-color (if (sacha/can-expand)
                          yasnippet-can-fire-cursor-color
                        default-cursor-color)))

  (defun sacha/can-expand ()
    "Return true if right after an expandable thing."
    (or (abbrev--before-point) (yasnippet-can-fire-p)))

                                          ; As pointed out by Dmitri, this will make sure it will update color when needed.
  (add-hook 'post-command-hook 'sacha/change-cursor-color-when-can-expand)

  (defun sacha/insert-space-or-expand ()
    "For binding to the SPC SPC keychord."
    (interactive)
    (condition-case nil (or (sacha/hippie-expand-maybe nil) (insert "  "))))
#+end_src

This requires me to modify the behaviour of hippie-expand so that it doesn't ding so much.
#+begin_src emacs-lisp
  (defun sacha/hippie-expand-maybe (arg)
    "Try to expand text before point, using multiple methods.
  The expansion functions in `hippie-expand-try-functions-list' are
  tried in order, until a possible expansion is found.  Repeated
  application of `hippie-expand' inserts successively possible
  expansions.
  With a positive numeric argument, jumps directly to the ARG next
  function in this list.  With a negative argument or just \\[universal-argument],
  undoes the expansion."
    (interactive "P")
    (if (or (not arg)
            (and (integerp arg) (> arg 0)))
        (let ((first (or (= he-num -1)
                         (not (equal this-command last-command)))))
          (if first
              (progn
                (setq he-num -1)
                (setq he-tried-table nil)))
          (if arg
              (if (not first) (he-reset-string))
            (setq arg 0))
          (let ((i (max (+ he-num arg) 0)))
            (while (not (or (>= i (length hippie-expand-try-functions-list))
                            (apply (nth i hippie-expand-try-functions-list)
                                   (list (= he-num i)))))
              (setq i (1+ i)))
            (setq he-num i))
          (if (>= he-num (length hippie-expand-try-functions-list))
              (progn (setq he-num -1) nil)
            (if (and hippie-expand-verbose
                     (not (window-minibuffer-p)))
                (message "Using %s"
                         (nth he-num hippie-expand-try-functions-list)))))
      (if (and (>= he-num 0)
               (eq (marker-buffer he-string-beg) (current-buffer)))
          (progn
            (setq he-num -1)
            (he-reset-string)
            (if (and hippie-expand-verbose
                     (not (window-minibuffer-p)))
                (message "Undoing expansions"))))))

#+end_src

yas/expand
yas-expand
    
because
because
Because


*** Show column number

I sometimes need to know where I am in a line.
    #+begin_src emacs-lisp
(column-number-mode 1)
#+end_src

*** Don't show whitespace in diff, but show context
    #+begin_src emacs-lisp
(setq vc-diff-switches '("-b" "-B" "-u"))
(setq vc-git-diff-switches nil)
#+end_src

*** Javascript

This makes script blocks easier to copy:

#+begin_src emacs-lisp
(defvar sacha/javascript-test-regexp (concat (regexp-quote "/** Testing **/") "\\(.*\n\\)*")
	"Regular expression matching testing-related code to remove.
See `sacha/copy-javascript-region-or-buffer'.")

(defun sacha/copy-javascript-region-or-buffer (beg end)
	"Copy the active region or the buffer, wrapping it in script tags.
Add a comment with the current filename and skip test-related
code. See `sacha/javascript-test-regexp' to change the way
test-related code is detected."
	(interactive "r")
	(unless (region-active-p)
		(setq beg (point-min) end (point-max)))
	(kill-new
	 (concat
		"<script type=\"text/javascript\">\n"
		(if (buffer-file-name) (concat "// " (file-name-nondirectory (buffer-file-name)) "\n") "")
		(replace-regexp-in-string
		 sacha/javascript-test-regexp
		 ""
		 (buffer-substring (point-min) (point-max))
		 nil)
		"\n</script>")))
#+end_src

And the rest of the js2 config:

#+begin_src emacs-lisp
      (use-package js2-mode
        :ensure t
        :commands js2-mode
        :init
        (progn
          (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
          (setq-default js2-basic-offset 2))
        :config
        (progn 
          (bind-key "C-x C-e" 'js-send-last-sexp js2-mode-map)
          (bind-key "C-M-x" 'js-send-last-sexp-and-go js2-mode-map)
          (bind-key "C-c b" 'js-send-buffer js2-mode-map)
          (bind-key "C-c C-b" 'js-send-buffer-and-go js2-mode-map)
          (bind-key "C-c w" 'sacha/copy-javascript-region-or-buffer js2-mode-map)
          (bind-key "C-c l" 'js-load-file-and-go js2-mode-map)))
#+end_src

**** Tern - for Javascript

#+begin_src emacs-lisp
(use-package tern
  :init
  (progn
  (add-hook 'js2-mode-hook 'tern-mode)))

#+end_src
*** C Programming
Reset silly gnu indention and start a new line when typing delimiters
#+begin_src emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
''(add-hook 'c-mode-common-hook '(lambda () (c-toggle-auto-state 1)))
(remove-hook 'c-mode-common-hook 'visual-line-mode)
(add-to-list 'c-mode-common-hook (lambda () (setq truncate-lines -1)))
(add-to-list 'c-mode-common-hook (lambda () (setq compile-command "build.bat")))
#+end_src

Refactoring C code:
#+begin_src emacs-lisp
(defun my-move-function-up ()
  "Move current function up."
  (interactive)
  (save-excursion
    (c-mark-function)
    (let ((fun-beg (point))
          (fun-end (mark)))
      (transpose-regions (progn
                           (c-beginning-of-defun 1)
                           (point))
                         (progn
                           (c-end-of-defun 1)
                           (point))
                         fun-beg fun-end))))

(defun my-move-function-down ()
  "Move current function down."
  (interactive)
  (save-excursion
    (c-mark-function)
    (let ((fun-beg (point))
          (fun-end (mark)))
      (transpose-regions fun-beg fun-end
                         (progn
                           (c-beginning-of-defun -1)
                           (point))
                         (progn
                           (c-end-of-defun 1)
                           (point))))))
(defun mark-c-scope-beg ()
  "Marks the c-scope (region between {}) enclosing the point. 
   Naive, as will be confused by { } within strings"
  (let 
	  ((scope-depth 1))
	(while (not (= scope-depth 0))
	  (search-backward-regexp "}\\|{")
	  (if (string= (char-to-string (char-before)) "}")
		  (setq scope-depth (1+ scope-depth))
			(setq scope-depth (1- scope-depth)))))
  (point))

(defun mark-c-scope-end ()
  "Marks the c-scope (region between {}) enclosing the point. 
   Naive, as will be confused by { } within strings"
  (let 
	  ((scope-depth 1))
	(while (not (= scope-depth 0))
	  (search-forward-regexp "}\\|{")
	  (if (string= (char-to-string (char-before)) "}")
		  (setq scope-depth (1- scope-depth))
			(setq scope-depth (1_ scope-depth)))))
  (point))

(defun kill-c-scope ()
  (interactive)
  (let
	  ((inital-point (point)))
	(save-excursion 
	  (let
		((beg (mark-c-scope-beg)))
		(goto-char inital-point)
		(let ((end (mark-c-scope-end))))))))


#+end_src
*** Magit - nice git interface
		:PROPERTIES:
		:ID:       o2b:9a42a292-7b75-4c7f-8da2-7a0d8c22d0c6
		:POST_DATE: [2014-10-31 Fri 23:26]
		:POSTID:   27579
		:BLOG:     sacha
		:END:

<<magit>>

Thanks to sheijk for hints on tweaking magit to limit it to the current directory!

#+begin_src emacs-lisp
    (defun sacha/magit-commit-all ()
      "Publish the current file and commit all the current changes."
      (interactive)
      (magit-status default-directory)
      (magit-stage-all)
      (call-interactively 'magit-log-edit))

    (use-package magit
      :ensure magit
      :config
      (progn
        (when (equal system-type 'windows-nt)
          (setq magit-git-executable "c:/program files (x86)/git/bin/git.exe"))
        (setq magit-diff-options '("-b")) ; ignore whitespace
        (defvar sacha/magit-limit-to-directory nil "Limit magit status to a specific directory.")
        (defun sacha/magit-status-in-directory (directory)
          "Displays magit status limited to DIRECTORY.
  Uses the current `default-directory', or prompts for a directory
  if called with a prefix argument. Sets `sacha/magit-limit-to-directory'
  so that it's still active even after you stage a change. Very experimental."
          (interactive (list (expand-file-name
                              (if current-prefix-arg
                                  (read-directory-name "Directory: ")
                                default-directory))))
          (setq sacha/magit-limit-to-directory directory)
          (magit-status directory))

        (defadvice magit-insert-untracked-files (around sacha activate)
          (if sacha/magit-limit-to-directory
              (magit-with-section (section untracked 'untracked "Untracked files:" t)
                (let ((files (cl-mapcan
                              (lambda (f)
                                (when (eq (aref f 0) ??) (list f)))
                              (magit-git-lines
                               "status" "--porcelain" "--" sacha/magit-limit-to-directory))))
                  (if (not files)
                      (setq section nil)
                    (dolist (file files)
                      (setq file (magit-decode-git-path (substring file 3)))
                      (magit-with-section (section file file)
                        (insert "\t" file "\n")))
                    (insert "\n"))))
            ad-do-it))

        (defadvice magit-insert-unstaged-changes (around sacha activate)
          (if sacha/magit-limit-to-directory
              (let ((magit-current-diff-range (cons 'index 'working))
                    (magit-diff-options (copy-sequence magit-diff-options)))
                (magit-git-insert-section (unstaged "Unstaged changes:")
                    #'magit-wash-raw-diffs
                  "diff-files"
                  "--" sacha/magit-limit-to-directory
                  ))
            ad-do-it))

        (defadvice magit-insert-staged-changes (around sacha activate)
          "Limit to `sacha/magit-limit-to-directory' if specified."
          (if sacha/magit-limit-to-directory
              (let ((no-commit (not (magit-git-success "log" "-1" "HEAD"))))
                (when (or no-commit (magit-anything-staged-p))
                  (let ((magit-current-diff-range (cons "HEAD" 'index))
                        (base (if no-commit
                                  (magit-git-string "mktree")
                                "HEAD"))
                        (magit-diff-options (append '("--cached") magit-diff-options)))
                    (magit-git-insert-section (staged "Staged changes:")
                        (apply-partially #'magit-wash-raw-diffs t)
                      "diff-index" "--cached" base "--" sacha/magit-limit-to-directory))))
            ad-do-it)))
      :bind (("C-x v d" . magit-status)
             ("C-x v C-d" . sacha/magit-status-in-directory)
             ("C-x v p" . magit-push) 
             ("C-x v c" . sacha/magit-commit-all)))
#+end_src

The proper way to implement this is probably to patch or override the
definition of magit-git-insert-section so that it takes a list of
options to add at the end of the command, but that can wait for another time (or braver souls). 

**** TODO Make this better by adding a post command options variable
*** Tag files

    I don't often use a TAGS file, but when I do, I don't want to have
    to set my tags file per project. I search for it in the directory
    tree instead.
    
    #+begin_src emacs-lisp
      (defun sacha/recursive-find-file (file &optional directory)
        "Find the first FILE in DIRECTORY or its parents."
        (setq directory (or directory (file-name-directory (buffer-file-name)) (pwd)))
        (if (file-exists-p (expand-file-name file directory))
            (expand-file-name file directory)
          (unless (string= directory "/")
            (sacha/recursive-find-file file (expand-file-name ".." directory)))))
      
      (defun sacha/find-tags ()
        "Set the TAGS file."
        (set (make-variable-buffer-local 'tags-table-list) nil)
        (set (make-variable-buffer-local 'tags-file-name) 
             (sacha/recursive-find-file "TAGS")))
      
      (eval-after-load 'drupal-mode
        '(progn
           (add-hook 'drupal-mode-hook 'sacha/find-tags)))
      #+end_src
*** Projects

#+begin_src emacs-lisp
(use-package projectile
  :ensure projectile
  :diminish projectile-mode
  :init 
  (progn
    (setq projectile-keymap-prefix (kbd "C-c p")) 
    (setq projectile-completion-system 'default)
    (setq projectile-enable-caching t)
    (projectile-global-mode)))
(use-package helm-projectile
   :ensure helm-projectile)
#+end_src
*** Exploring MELPA recipes

#+begin_src emacs-lisp

#+end_src

*** Ruby

		#+begin_src emacs-lisp
(use-package rinari :ensure rinari)
(use-package bundler :ensure bundler)
    (use-package robe
      :ensure robe
      :init
		  (progn (add-hook 'ruby-mode-hook 'robe-mode)
             (add-hook 'robe-mode-hook 'ac-robe-setup)
             (add-hook 'ruby-mode-hook 'auto-complete-mode)))
		#+end_src

#+begin_src emacs-lisp
(defun sacha/rspec-verify-single ()
  "Runs the specified example at the point of the current buffer."
  (interactive)
  (rspec-run-single-file
   (concat 
     (rspec-spec-file-for (buffer-file-name))
     ":" 
     (save-restriction
               (widen)
               (number-to-string (line-number-at-pos))))
   (rspec-core-options)))

(use-package rspec-mode
  :ensure rspec-mode
  :config
  (progn 
    (setq rspec-command-options "--fail-fast --format documentation")
    (bind-key "C-c , ," 'rspec-rerun rspec-mode-map)
    (fset 'rspec-verify-single 'sacha/rspec-verify-single)))
  
#+end_src

SASS

#+begin_src emacs-lisp
(add-hook 'sass-mode-hook
          (lambda () (setq indent-tabs-mode nil)))
(setq-default indent-tabs-mode nil)
#+end_src
*** Skewer

This lets you send HTML, CSS, and Javascript fragments to Google
Chrome. You may need to start Chrome with =chrome
--allow-running-insecure-content=, if you're using the user script
with HTTPS sites.

#+begin_src emacs-lisp
(use-package skewer-mode
  :ensure skewer-mode
  :config (skewer-setup))
#+end_src

*** Autocomplete

#+begin_src emacs-lisp
(use-package company
  :ensure company
  :config
  (add-hook 'prog-mode-hook 'company-mode))
#+end_src

** Ledger (personal finance): Make it easier to review my credit card transactions

#+begin_src emacs-lisp
(defun sacha/ledger-go-to-beginning-of-entry ()
  "Move to the beginning of the current entry."
  (while (and (not (bobp))
              (eq (ledger-context-line-type (ledger-context-at-point))
                  'acct-transaction))
    (forward-line -1)))

(defun sacha/ledger-entry-date ()
  "Returns the date of the entry containing point or nil."
  (save-excursion
    (sacha/ledger-go-to-beginning-of-entry)
    (let ((context-info (ledger-context-other-line 0)))
      (when (eq (ledger-context-line-type context-info) 'entry)
        (goto-char (line-beginning-position))
        (if (looking-at "\\([-0-9\\./]+\\)")
            (match-string-no-properties 1))))))

(defun sacha/ledger-guess-mbna ()
  "Adds a sub-account for the dates for my credit card transactions."
  (interactive)
  (save-excursion
    (sacha/ledger-go-to-beginning-of-entry)
    (forward-line 1)
    (let ((amount 0) (date (sacha/ledger-entry-date)) month)
      (if (string-match "[0-9]+[-\\.]\\([0-9]+\\)[-\\.]\\([0-9]+\\)" date)
          (setq month (string-to-number (match-string 1 date))))
      ;; Is this a payment or a charge?
      (save-excursion
        (while (and (eq (ledger-context-line-type (ledger-context-at-point))
                        'acct-transaction)
                    (not (eobp)))
          (let ((context (ledger-context-at-point)))
            (if (ledger-context-field-value context 'amount)
                (if (string-match "MBNA" (ledger-context-field-value context 'account))
                    (setq amount (string-to-number (ledger-context-field-value context 'amount)))
                  (setq amount (- (string-to-number (ledger-context-field-value context 'amount)))))))
          (forward-line 1)))
      (save-excursion
        (while (and (eq (ledger-context-line-type (ledger-context-at-point))
                        'acct-transaction)
                    (not (eobp)))
          (let ((context (ledger-context-at-point)))
            (if (string-match "MBNA" (ledger-context-field-value context 'account))
                (if (re-search-forward "\\(MBNA\\)[ \t]*[-$\.0-9]*[ \t]*$" (line-end-position) t)
                    (replace-match
                     (concat "MBNA:"
                             (elt
                              '("January" "February" "March" "April" "May" "June" "July" "August" "September" "October" "November" "December")
                              (% (+ (if (> amount 0) 10 11) month) 12)))
                             t t nil 1))))
          (forward-line 1))))))
#+end_src

** Internet Relay Chat

   IRC is a great way to hang out with other Emacs geeks.
   #+begin_src emacs-lisp
     (use-package erc
       :ensure erc
       :config
       (setq erc-autojoin-channels-alist '(("freenode.net"
					    "#org-mode"
					    "#hacklabto"
					    "#emacs"))
	     erc-server "irc.freenode.net"
	     erc-nick "floatingman"))
   #+end_src

** Self-tracking, statistics, and other data transformations

*** Compare times and effort estimates
<<compare-time>>

This is for comparing times in column view and in tables.

#+begin_src emacs-lisp
  (defun sacha/compare-times (clocked estimated)
    (if (and (> (length clocked) 0) estimated)
        (format "%.2f"
              (/ (* 1.0 (org-hh:mm-string-to-minutes clocked))
                 (org-hh:mm-string-to-minutes estimated)))
      ""))
#+end_src

Use with =#+COLUMNS: %40ITEM %17Effort(Estimated){:} %CLOCKSUM=, =#+BEGIN: columnview :hlines 1= ... =#+END:=, and

#+begin_src org
,#+TBLFM: $4='(sacha/compare-times $3 $2)
#+end_src

*** R

#+begin_src emacs-lisp
  (use-package ess-site
    :ensure ess
    :commands R)
#+end_src

*** Workrave
    #+begin_src emacs-lisp
    (defvar sacha/workrave-file (expand-file-name ".\\Workrave\\historystats" (getenv "AppData")))

(defun sacha/workrave-transform-statistics (&optional file)
  (interactive (list sacha/workrave-file))
  (with-current-buffer (find-file-noselect file)
  ;; D day month-1 year hour min day month-1 year hour min
    (let ((result "Date\tStart\tEnd\tClicks\tKeystrokes\n"))
      (goto-char (point-min))
      (while (re-search-forward "^D \\(.*\\)" nil t)
	(let ((dates (split-string (match-string 1))))
	  (if (re-search-forward "^m \\(.*\\)" nil t)
	      (let ((info (split-string (match-string 1))))
		(setq result
		      (concat result
			      (format "%d-%d-%s\t%s:%02d\t%s:%02d\t%s\t%s\n"
				      (+ 1900 (string-to-number (elt dates 2))) ; year
				      (1+ (string-to-number (elt dates 1))) ; month
				      (elt dates 0) ; day
				      (elt dates 3) ; start hour
				      (string-to-number (elt dates 4)) ; start min
				      (elt dates 8) ; end hour
				      (string-to-number (elt dates 9)) ; end min
				      (elt info 5) ; clicks
				      (elt info 6) ; keystrokes
				      )))))))
      (if (interactive-p)
	  (kill-new result)
	result))))
    #+end_src
*** Blog
#+begin_src emacs-lisp
  (defun sacha/strip-blog-share ()
    (interactive)
    (let (base)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward 
                "<div class=\"sharedaddy sd-sharing-enabled\">.*?<div class=\"sharing-clear\"></div></div></div></div>" nil t)
          (replace-match "")))))
#+end_src
*** Artrage

#+begin_src emacs-lisp
          (defun sacha/artrage-export-png (directory &optional prefix)
            "Change an Artrage script file (arscript) to export images to DIRECTORY. 
      If PREFIX is specified, use that instead of image-."
            (interactive "MPath: ")
            (unless (file-directory-p directory)
              (make-directory directory t))
            (while (re-search-forward "[0-9\\.]+s" nil t)
              (replace-match "0.000s"))
            (goto-char (point-min))
            (while (search-forward "<StrokeEvent>" nil t)
              (replace-match (concat 
                              "EvType: Command    CommandID: ExportLayer    Idx: -1    Channels: NO    Path: \""
                              directory
                              "/" (or prefix "image-")
                              ".png\"
  <StrokeEvent>") t t)))
    
#+end_src
** Workarounds
*** color-theme sometimes comes across lists. Odd!

#+begin_src emacs-lisp
  (defadvice face-attribute (around sacha activate)
    (if (symbolp (ad-get-arg 0))
        ad-do-it))
#+end_src

*** ido-sort-mtime stopped working when I upgraded to Windows 8

#+begin_src emacs-lisp
  (defadvice ido-sort-mtime (around sacha activate)
    (setq ido-temp-list
          (sort ido-temp-list 
                (lambda (a b)
                  (let ((ta (or (nth 5 (file-attributes (concat ido-current-directory a))) '(0 0)))
                        (tb (or (nth 5 (file-attributes (concat ido-current-directory b))) '(0 0))))
                    (if (= (nth 0 ta) (nth 0 tb))
                        (> (nth 1 ta) (nth 1 tb))
                      (> (nth 0 ta) (nth 0 tb)))))))
    (setq ad-return-value
          (ido-to-end  ;; move . files to end (again)
           (delq nil (mapcar
                      (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                      ido-temp-list)))))
  
#+end_src
*** Cygwin mogrify doesn't work for me, but ImageMagick does

#+begin_src emacs-lisp
;(setq eimp-mogrify-program "c:/Program Files/ImageMagick-6.8.3-Q16/mogrify.exe")
#+end_src

** Advanced stuff / things I tend to forget about
*** Editing multiple things
**** Multiple cursors mode					      :drill:
     SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       o2b:61b0ffae-669b-4360-98fd-a6f0ea6f018e
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 2
    :DRILL_FAILURE_COUNT: 1
    :DRILL_AVERAGE_QUALITY: 2.5
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

I often define keyboard macros to process multiple lines in a region.
Maybe =multiple-cursors= will be an even better way. Looks promising!
[[http://emacsrocks.com/e13.html][See Emacs Rocks episode 13 (multiple-cursors) for a great demo]].

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure multiple-cursors
    :bind 
     (("C-c m a" . mc/mark-all-like-this)
      ("C-c m m" . mc/mark-all-like-this-dwim)
      ("C-c m l" . mc/edit-lines)
      ("C-c m n" . mc/mark-next-like-this)
      ("C-c m p" . mc/mark-previous-like-this)
      ("C-c m s" . mc/mark-sgml-tag-pair)
      ("C-c m d" . mc/mark-all-like-this-in-defun)))
  (use-package phi-search
    :ensure phi-search)
  (use-package phi-search-mc
    :ensure phi-search-mc
    :config
    (phi-search-mc/setup-keys))
  (use-package mc-extras
    :ensure mc-extras
    :config
      (define-key mc/keymap (kbd "C-. =") 'mc/compare-chars))
#+end_src

Thanks to [[http://irreal.org/blog/?p=1733][Irreal]] and [[http://planet.emacsen.org/][Planet Emacsen]] for the link!

*** Edit list   :drill:
    SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       e9147cb0-bad0-421c-9396-4f9045d6ebbb
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 3
    :DRILL_FAILURE_COUNT: 2
    :DRILL_AVERAGE_QUALITY: 2.333
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

M-x edit-list makes it easier to edit an Emacs Lisp list.

#+begin_src emacs-lisp
(use-package edit-list
  :ensure edit-list
  :commands edit-list)
#+end_src

*** Ace Jump mode  :drill:
    :PROPERTIES:
    :ID:       56f173e7-d2a2-4589-84d7-c6b435c8a5f8
    :DRILL_LAST_INTERVAL: 0.0
    :DRILL_REPEATS_SINCE_FAIL: 1
    :DRILL_TOTAL_REPEATS: 3
    :DRILL_FAILURE_COUNT: 2
    :DRILL_AVERAGE_QUALITY: 1.667
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 0
    :DRILL_LAST_REVIEWED: [2013-03-13 Wed 09:50]
    :END:

Quickly jump to a position in the current view.

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :ensure ace-jump-mode)
  ;; I use the jj key-chord for this; see the definitions for key-chord
#+end_src

Ace Window looks useful too.

#+begin_src emacs-lisp
(use-package ace-window
  :ensure ace-window
  :config (setq aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s))
  :bind ("C-x o" . ace-window))
#+end_src

And ace-isearch...

#+begin_src emacs-lisp
(use-package ace-isearch
  :ensure ace-isearch
  :init (global-ace-isearch-mode 0))
#+end_src

And ace-jump-zap...

#+begin_src emacs-lisp
(use-package ace-jump-zap
  :ensure ace-jump-zap
  :bind
  (("M-z" . ace-jump-zap-up-to-char-dwim)
   ("C-M-z" . ace-jump-zap-to-char-dwim)))
#+end_src

*** Network: TRAMP and editing files over SSH
Emacs lets you edit files on remote servers, which is pretty darn
cool. On Windows, these things help a little.

#+begin_src emacs-lisp
(setq tramp-default-method "plink")
(setq tramp-auto-save-directory "c:\\tmp")
#+end_src

** Other nifty Emacs things I want to learn
*** Smartparens mode						      :drill:

#+begin_src emacs-lisp
  (use-package smartparens
    :ensure smartparens
    :diminish smartparens
    :config
    (progn
      (require 'smartparens-config)
      (add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
      (add-hook 'emacs-lisp-mode-hook 'show-smartparens-mode)
      (smartparens-global-mode t)
  ;;;;;;;;;;;;;;;;;;;;;;;;
      ;; keybinding management

      (define-key sp-keymap (kbd "C-c s r n") 'sp-narrow-to-sexp)
      (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
      (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)
      (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
      (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
      (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
      (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

      (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
      (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
      (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
      (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

      (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
      (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

      (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
      (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

      (define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
      (define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

      (define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
      (define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
      (define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
      (define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

      (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
      (define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
      (define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
      (define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

      (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
      (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
      (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)

      (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
      (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)

      (define-key sp-keymap (kbd "C-c s t") 'sp-prefix-tag-object)
      (define-key sp-keymap (kbd "C-c s p") 'sp-prefix-pair-object)
      (define-key sp-keymap (kbd "C-c s c") 'sp-convolute-sexp)
      (define-key sp-keymap (kbd "C-c s a") 'sp-absorb-sexp)
      (define-key sp-keymap (kbd "C-c s e") 'sp-emit-sexp)
      (define-key sp-keymap (kbd "C-c s p") 'sp-add-to-previous-sexp)
      (define-key sp-keymap (kbd "C-c s n") 'sp-add-to-next-sexp)
      (define-key sp-keymap (kbd "C-c s j") 'sp-join-sexp)
      (define-key sp-keymap (kbd "C-c s s") 'sp-split-sexp)

  ;;;;;;;;;;;;;;;;;;
      ;; pair management

      (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
      (sp-local-pair 'web-mode "<" nil :when '(sacha/sp-web-mode-is-code-context))

  ;;; markdown-mode
      (sp-with-modes '(markdown-mode gfm-mode rst-mode)
        (sp-local-pair "*" "*" :bind "C-*")
        (sp-local-tag "2" "**" "**")
        (sp-local-tag "s" "```scheme" "```")
        (sp-local-tag "<"  "<_>" "</_>" :transform 'sp-match-sgml-tags))

  ;;; tex-mode latex-mode
      (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
        (sp-local-tag "i" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;<" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;>"))

  ;;; html-mode
      (sp-with-modes '(html-mode sgml-mode web-mode)
        (sp-local-pair "<" ">"))

  ;;; lisp modes
      (sp-with-modes sp--lisp-modes
        (sp-local-pair "(" nil :bind "C-("))))
#+end_src
** Web browsing

	 Minor tweak for Firefox on Windows. Otherwise I get "Searching for
	 program" "permission denied" "firefox".
	 
	 #+begin_src emacs-lisp
	 (setq browse-url-firefox-program
         "C:/Program Files (x86)/Mozilla Firefox/firefox.exe")
	 #+end_src
** Transcript editing

#+begin_src emacs-lisp
  (use-package emms
    :ensure emms
    :config
    (progn
      (require 'emms-player-simple)
      (require 'emms-source-file)
      (require 'emms-source-playlist)
      (require 'emms-player-mplayer)
      (setq emms-player-list '(emms-player-mplayer))
      )
    :bind
    (("C-c e SPC" . emms-pause)
     ("C-c e e" . emms-pause)
     ("C-c e +" . emms-seek-forward)
     ("C-c e -" . emms-seek-backward)
     ("C-c e s" . emms-seek)
     ("C-c e [" . sacha/emms-player-mplayer-slow-down)
     ("C-c e ]" . sacha/emms-player-mplayer-speed-up)))

  (bind-key "C-c t s"  'sacha/split-sentence-and-capitalize org-mode-map)
  (bind-key "C-c t -"  'sacha/split-sentence-delete-word-and-capitalize org-mode-map)
  (bind-key "C-c t d"  'sacha/delete-word-and-capitalize org-mode-map)

  (defun sacha/split-sentence-and-capitalize ()
    (interactive)
    (delete-char 1)
    (insert ".")
    (capitalize-word 1))
  (defun sacha/split-sentence-delete-word-and-capitalize ()
    (interactive)
    (delete-char 1)
    (insert ".")
    (kill-word 1)
    (capitalize-word 1))
  (defun sacha/delete-word-and-capitalize ()
    (interactive)
    (skip-syntax-backward "w")
    (kill-word 1)
    (capitalize-word 1))

  (defun sacha/emms-player-mplayer-set-speed (speed)
    "Depends on mplayer's -slave mode"
    (interactive "MSpeed: ")
    (process-send-string emms-player-simple-process-name 
       (format "speed_set %s\n" speed)))

  (defvar sacha/emms-player-mplayer-speed-increment 0.1)

  (defun sacha/emms-player-mplayer-speed-up ()
    "Depends on mplayer's -slave mode"
    (interactive)
    (process-send-string emms-player-simple-process-name 
       (format "speed_incr %f\n" sacha/emms-player-mplayer-speed-increment)))
  (defun sacha/emms-player-mplayer-slow-down ()
    "Depends on mplayer's -slave mode"
    (interactive)
    (process-send-string emms-player-simple-process-name 
       (format "speed_incr %f\n" (- 0 sacha/emms-player-mplayer-speed-increment))))


#+end_src

** Other cool configs you may want to check out
 <<links>>

 - [[http://doc.norang.ca/org-mode.html][Bernt Hansen]]: Lots of Org-related config. I picked up the graph-drawing stuff from this.
 - [[http://bzg.fr/emacs.html][Bastien Guerry]]: Org, Gnus, ERC - Explained in this [[http://sachachua.com/blog/2013/05/emacs-chat-bastien-guerry/][Emacs Chat (~1h)]]
 - [[https://github.com/iani/emacs-prelude][Iannis Zannos]]: Explained in this [[https://www.youtube.com/watch?v=0F8aCbC9z3A][Emacs Chat (~1h)]]
 - [[https://github.com/magnars/.emacs.d][Magnar Sveen]]: http://whattheemacsd.com/ has some explanations. [[http://sachachua.com/blog/2013/11/emacs-chat-magnar-sveen-emacs-rocks/][Emacs Chat (~1h)]]
 - [[https://github.com/jwiegley/dot-emacs][John Wiegley]]: Also see his [[http://www.youtube.com/watch?v=RvPFZL6NJNQ][Emacs Lisp Development talk]] (sorry, sucky video) and [[http://www.youtube.com/watch?v=ytNsHmRLZGM][Emacs Chat video]]

** Inactive/infrequent things
*** Beeminder
 <<beeminder>>

 https://github.com/sachac/beeminder.el

 This bit of code lets me track sent messages in Gnus:

 #+begin_src emacs-lisp :eval no :tangle no
 (defun sacha/beeminder-track-message ()
	 (save-excursion
		 (goto-char (point-min))
		 (when (re-search-forward "Newsgroups: .*emacs")
			 (goto-char (point-min))
			 (when (re-search-forward "Subject: \\(.*\\)" nil t)
				 (beeminder-add-data "orgml" "1" (match-string 1))))))
 #+end_src

 And this loads the beeminder code:

 #+BEGIN_SRC emacs-lisp :eval no :tangle no
(require-package 'beeminder)
 (use-package beeminder
   :config (add-hook 'message-send-news-hook 'sacha/beeminder-track-message))
 #+END_SRC

*** Rainbow delimiters

 #+begin_src emacs-lisp  :eval no :tangle no
(require-package 'rainbow-delimiters) 
(use-package rainbow-delimiters
   :init (global-rainbow-delimiters-mode))
 #+end_src

*** Drupal

 #+begin_src emacs-lisp :eval no :tangle no
   (define-derived-mode drupal-mode php-mode "Drupal"
     "Major mode for Drupal source code.
   \\{drupal-mode-map}"
     (setq case-fold-search t) 
     (setq indent-tabs-mode nil)
     (setq c-basic-offset 2)
     (setq indent-tabs-mode nil)
     (setq tab-width 2)
     (setq fill-column 78)
     (c-set-offset 'arglist-cont 0)
     (c-set-offset 'arglist-intro '+)
     (c-set-offset 'case-label 2)
     (c-set-offset 'arglist-close 0)
     (setq yas/buffer-local-condition 
     '(cond
			((looking-at "\\w") nil)
			((and
				(not (bobp))
				(or (equal "font-lock-comment-face"
                   (get-char-property (1- (point)) 'face))
						(equal "font-lock-string-face"
                   (get-char-property (1- (point)) 'face))))
       '(require-snippet-condition . force-in-comment))
			(t t))))
   (define-key drupal-mode-map (kbd "TAB") 'indent-according-to-mode)
   (add-hook 'drupal-mode-hook (lambda () (flymake-mode 1)))
   (add-hook 'drupal-mode-hook (lambda () (yas/minor-mode 1)))
   (add-to-list 'auto-mode-alist '("\\.\\(php\\|test\\|module\\|inc\\|install\\|engine\\|profile\\|.theme\\)$" . drupal-mode))
   (add-to-list 'auto-mode-alist '("\\.tpl.php$" . html-helper-mode))
   (define-key drupal-mode-map '[M-S-up] 'flymake-goto-prev-error)
   (define-key drupal-mode-map '[M-S-down] 'flymake-goto-next-error)
   (define-key drupal-mode-map (kbd "C-c C-c") 'comment-dwim)
  
   (defun sacha/drupal-module-name ()
     "Return the Drupal module name for .module and .install files."    (file-name-sans-extension (file-name-nondirectory
																(buffer-file-name))))
   (add-to-list 'hs-special-modes-alist '(drupal-mode "{" "}" "/[*/]" nil hs-c-like-adjust-block-beginning))
  
 #+end_src


*** Autoconnect to IRC so that I don't forget

 #+begin_src emacs-lisp  :eval no :tangle no
 (erc :server "irc.freenode.net" :port 6667 :nick "sachac")
 #+end_src
   
*** Animation for Emacs chats

 #+begin_src emacs-lisp
 (defun sacha/animate-emacs-chat ()
   (interactive)
   (text-scale-set 6)
   (erase-buffer)
   (sit-for 3)
   (let ((list '("Emacs Chat: Sacha Chua"
                 "interviewed by Bastien Guerry"
                 ""
                 "July 24, 2013"
                 "sachachua.com/emacs-chat"))
         (approx-width 41)
         (approx-height 16)
         row)
     (setq row (/ (- approx-height (length list)) 2))
     (mapcar
			(lambda (x)
				(animate-string x
												row
												(/ (- approx-width (length x)) 2))
				(setq row (1+ row)))
			list)))
 #+end_src
*** Old Flickr/Evernote export

 #+begin_src emacs-lisp :eval no :tangle no
				;; I don't use these as much now that I have the functions above.
				(defun sacha/evernote-extract-links (filename)
					"Extract note names and URLs from an ENEX file."
					(interactive)
         
					(goto-char (point-min))
					(let (list)
						(while (re-search-forward "<title>\\(.+?\\)</title>\\(.*?\n\\)*?.*?href=\"\\(.*?\\)\"" nil t)
							(setq list (cons (cons (match-string-no-properties 1) (match-string-no-properties 3)) list)))
						(delete-region (point-min) (point-max))
						(insert (mapconcat (lambda (x) (concat "- [[" (cdr x) "][" (car x) "]]")) list "\n"))))      
       
				
 #+end_src
*** Enable minibuffer completion
 [2013-03-31] Superseded by ido-hacks?

 It can be difficult to remember the full names of Emacs commands, so I
 use =icomplete-mode= for minibuffer completion. This also makes it
 easier to discover commands.

 #+begin_src emacs-lisp :eval no :tangle no
 (icomplete-mode 1)
 #+end_src

*** Because I'm trying to use helm instead of ido...

**** Ido-mode: Much better navigationy things
 [2013-03-31]: Let's try using Helm instead.

 Ido-mode is awesome. Let's make it awesomer. I usually want to go to
 recently-opened files first.

 #+begin_src emacs-lisp :eval no :tangle no
 (use-package ido
   :init
   (progn
   (ido-mode 1)
   (setq ido-default-buffer-method 'selected-window)
   (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
   (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
   (defun ido-sort-mtime ()
     (setq ido-temp-list
           (sort ido-temp-list 
                 (lambda (a b)
                   (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                         (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                     (if (= (nth 0 ta) (nth 0 tb))
                         (> (nth 1 ta) (nth 1 tb))
                       (> (nth 0 ta) (nth 0 tb)))))))
     (ido-to-end  ;; move . files to end (again)
			(delq nil (mapcar
                 (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                 ido-temp-list))))))
 #+end_src

**** Finding files

     I don't want to think about directory structures, I just want to
     open files. 

     #+begin_src emacs-lisp  :eval no :tangle no
       (require 'filecache)
       (require 'ido)
       (defun file-cache-ido-find-file (file)
         "Using ido, interactively open file from file cache'.
       First select a file, matched using ido-switch-buffer against the contents
       in `file-cache-alist'. If the file exist in more than one
       directory, select directory. Lastly the file is opened."
         (interactive (list (file-cache-ido-read "File: "
                                                 (mapcar
																									(lambda (x)
																										(car x))
																									file-cache-alist))))
         (let* ((record (assoc file file-cache-alist)))
           (find-file
						(expand-file-name
             file
             (if (= (length record) 2)
                 (car (cdr record))
               (file-cache-ido-read
								(format "Find %s in dir: " file) (cdr record)))))))
      
       (defun file-cache-ido-read (prompt choices)
         (let ((ido-make-buffer-list-hook
								(lambda ()
									(setq ido-temp-list choices))))
           (ido-read-buffer prompt)))
       (add-to-list 'file-cache-filter-regexps "docs/html")
       (add-to-list 'file-cache-filter-regexps "\\.svn-base$")
       (add-to-list 'file-cache-filter-regexps "\\.dump$")
     #+end_src     

     To use this code, I add something like
    
     #+begin_src emacs-lisp :tangle no :eval no
       (sacha/file-cache-setup-tree "sacha/proj1" "C-c d"
																		'("/dir1"
																			"/dir2"))
     #+end_src
     to my config. Then =C-c d= (or whatever keyboard shortcut I use)
     searches for files within the specified directories.
    
*** Keywiz - keyboard quizzes
 #+begin_src emacs-lisp :eval no :tangle no
   (use-package keywiz)
   (defun sacha/load-keybindings ()
     "Since we don't want to have to pass through a keywiz game each time..."
     (setq keywiz-cached-commands nil)
     (do-all-symbols (sym)
       (when (and (commandp sym)
									(not (memq sym '(self-insert-command
                                   digit-argument undefined))))
         (let ((keys (apply 'nconc (mapcar
																		(lambda (key)
																			(when (keywiz-key-press-event-p key)
																				(list key)))
																		(where-is-internal sym)))))
           ;;  Politically incorrect, but clearer version of the above:
           ;;    (let ((keys (delete-if-not 'keywiz-key-press-event-p
           ;;                               (where-is-internal sym))))
           (and keys
								(push (list sym keys) keywiz-cached-commands))))))
   (sacha/load-keybindings)
   ;; Might be good to use this in org-agenda...
   (defun sacha/random-keybinding ()
     "Describe a random keybinding."
     (let* ((command (keywiz-random keywiz-cached-commands))
						(doc (and command (documentation (car command)))))
       (if command
           (concat (symbol-name (car command)) " "
                   "(" (mapconcat 'key-description (cadr command) ", ") ")"
                   (if doc
                       (concat ": " (substring doc 0 (string-match "\n" doc)))
                     ""))
         "")))
 #+end_src
** Games
*** Typing of Emacs
#+begin_src emacs-lisp :eval no :tangle no
(require-package 'typing)
(use-package typing
         :init
         (autoload 'typing-of-emacs "typing" nil t)
         :config
         (progn
           (setq toe-starting-length 6)
           (setq toe-starting-time-per-word 2)
           (setq toe-max-length 20)))
 #+end_src
*** 2048 in Emacs, and colours too																		:emacs:
		:PROPERTIES:
		:ID:       o2b:e2b41b2d-463c-4469-91b8-63eb97a13b9d
		:POST_DATE: [2014-04-16 Wed 23:23]
		:POSTID:   27182
		:BLOG:     sacha
		:END:

 While browsing through =M-x list-packages=, I noticed that there was a
 new MELPA package that implemented the 2048 game in Emacs. I wrote the
 following code to colorize it. Haven't tested the higher numbers yet,
 but they're easy enough to tweak if the colours disagree with your
 theme. =)

 #+begin_src emacs-lisp
   (defface 2048-face-2    '((t . (:background "khaki" :foreground "black"))) "Face for the tile 2" :group '2048-faces)
   (defface 2048-face-4    '((t . (:background "burlywood" :foreground "black"))) "Face for the tile 4" :group '2048-faces)
   (defface 2048-face-8    '((t . (:background "orange3" :foreground "black"))) "Face for the tile 8" :group '2048-faces)
   (defface 2048-face-16   '((t . (:background "orange" :foreground "black"))) "Face for the tile 16" :group '2048-faces)
   (defface 2048-face-32   '((t . (:background "orange red" :foreground "black"))) "Face for the tile 32" :group '2048-faces)
   (defface 2048-face-64   '((t . (:background "firebrick" :foreground "white"))) "Face for the tile 64" :group '2048-faces)
   (defface 2048-face-128  '((t . (:background "dark red" :foreground "white"))) "Face for the tile 128" :group '2048-faces)
   (defface 2048-face-256  '((t . (:background "dark magenta" :foreground "white"))) "Face for the tile 256" :group '2048-faces)
   (defface 2048-face-512  '((t . (:background "magenta" :foreground "black"))) "Face for the tile 512" :group '2048-faces)
   (defface 2048-face-1024 '((t . (:background "gold" :foreground "black"))) "Face for the tile 1024" :group '2048-faces)
   (defface 2048-face-2048 '((t . (:background "yellow" :foreground "black"))) "Face for the tile 2048" :group '2048-faces)


     (defun sacha/2048-set-font-size ()
       (text-scale-set 5)
       (goto-char (point-min)))

     (use-package 2048-game
       :config
       (progn
				(add-hook '2048-mode-hook 'sacha/2048-set-font-size)))
 #+end_src

** Path

 #+begin_src emacs-lisp
 (setenv "PATH" (concat "\"c:/program files/postgresql/9.3/bin;\"" (getenv "PATH")))
 #+end_src

 
