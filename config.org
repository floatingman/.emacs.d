#+TITLE: Daniel Newman's Literate Emacs Configuration
#+AUTHOR: Daniel Newman
#+EMAIL: dwnewman78@gmail.com
#+SETUPFILE: ~/.emacs.d/setupfiles/emacs.setup
#+STARTUP: overview

* The Beginning
:PROPERTIES:
:CUSTOM_ID: init
:END:
I've seen some cool Emacs configs written out using [[http://orgmode.org/worg/org-contrib/babel/][Org-mode Babel]] to
enclose code within paragraphs of text. I think this will be a cool
way to organize my config and also provide some context around why I
did things the way I did

I am going to attempt to arrange my code in modules and provide a
makefile to make installing convenient

** Check for minimum emacs version
Don't let old fools use this
#+BEGIN_SRC emacs-lisp :tangle yes
;; turn on emacs debugging to diagnose errors
;;(setq debug-on-error t)

(let ((minver "24.5"))
  (when (version< emacs-version minver)
    (error "Your Emacs is too old -- this config requires v%s or higher" minver)))
(when (version< emacs-version "25.1")
  (message "Your Emacs is old, and some functionality in this config will be disabled. Please upgrade if possible."))
#+END_SRC
** Benchmarking
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sanityinc/time-subtract-millis (b a)
  (* 1000.0 (float-time (time-subtract b a))))


(defvar sanityinc/require-times nil
  "A list of (FEATURE LOAD-START-TIME LOAD-DURATION).
LOAD-DURATION is the time taken in milliseconds to load FEATURE.")

(defun sanityinc/require-times-wrapper (orig feature &rest args)
  "Note in `sanityinc/require-times' the time taken to require each feature."
  (let* ((already-loaded (memq feature features))
         (require-start-time (and (not already-loaded) (current-time))))
    (prog1
        (apply orig feature args)
      (when (and (not already-loaded) (memq feature features))
        (let ((time (sanityinc/time-subtract-millis (current-time) require-start-time)))
          (add-to-list 'sanityinc/require-times
                       (list feature require-start-time time)
                       t))))))

(advice-add 'require :around 'sanityinc/require-times-wrapper)

(define-derived-mode sanityinc/require-times-mode tabulated-list-mode "Require-Times"
  "Show times taken to `require' packages."
  (setq tabulated-list-format
        [("Start time (ms)" 20 sanityinc/require-times-sort-by-start-time-pred)
         ("Feature" 30 t)
         ("Time (ms)" 12 sanityinc/require-times-sort-by-load-time-pred)])
  (setq tabulated-list-sort-key (cons "Start time (ms)" nil))
  ;; (setq tabulated-list-padding 2)
  (setq tabulated-list-entries #'sanityinc/require-times-tabulated-list-entries)
  (tabulated-list-init-header)
  (when (fboundp 'tablist-minor-mode)
    (tablist-minor-mode)))

(defun sanityinc/require-times-sort-by-start-time-pred (entry1 entry2)
  (< (string-to-number (elt (nth 1 entry1) 0))
     (string-to-number (elt (nth 1 entry2) 0))))

(defun sanityinc/require-times-sort-by-load-time-pred (entry1 entry2)
  (> (string-to-number (elt (nth 1 entry1) 2))
     (string-to-number (elt (nth 1 entry2) 2))))

(defun sanityinc/require-times-tabulated-list-entries ()
  (cl-loop for (feature start-time millis) in sanityinc/require-times
           with order = 0
           do (incf order)
           collect (list order
                         (vector
                          (format "%.3f" (sanityinc/time-subtract-millis start-time before-init-time))
                          (symbol-name feature)
                          (format "%.3f" millis)))))

(defun sanityinc/require-times ()
  "Show a tabular view of how long various libraries took to load."
  (interactive)
  (with-current-buffer (get-buffer-create "*Require Times*")
    (sanityinc/require-times-mode)
    (tabulated-list-revert)
    (display-buffer (current-buffer))))



(defun sanityinc/show-init-time ()
  (message "init completed in %.2fms"
           (sanityinc/time-subtract-millis after-init-time before-init-time)))

(add-hook 'after-init-hook 'sanityinc/show-init-time)

#+END_SRC
** Setup some variables for use in other config files
#+BEGIN_SRC emacs-lisp :tangle yes
(defconst *is-a-mac* (eq system-type 'darwin))
(defconst *is-linux* (eq system-type 'gnu/linux))
(defconst *is-gui* (not (eq window-system nil)))
#+END_SRC
** Adjust garbage collection
#+BEGIN_SRC emacs-lisp :tangle yes
;;----------------------------------------------------------------------------
;; Adjust garbage collection thresholds during startup, and thereafter
;;----------------------------------------------------------------------------
(let ((normal-gc-cons-threshold (* 20 1024 1024))
      (init-gc-cons-threshold (* 128 1024 1024)))
  (setq gc-cons-threshold init-gc-cons-threshold)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold normal-gc-cons-threshold))))
#+END_SRC
** Load custom file
#+BEGIN_SRC emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC
** Utils
#+BEGIN_SRC emacs-lisp :tangle yes
(define-obsolete-function-alias 'after-load 'with-eval-after-load "")

;;----------------------------------------------------------------------------
;; Handier way to add modes to auto-mode-alist
;;----------------------------------------------------------------------------
(defun add-auto-mode (mode &rest patterns)
  "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
  (dolist (pattern patterns)
    (add-to-list 'auto-mode-alist (cons pattern mode))))

;; Like diminish, but for major modes
(defun sanityinc/set-major-mode-name (name)
  "Override the major mode NAME in this buffer."
  (setq-local mode-name name))

(defun sanityinc/major-mode-lighter (mode name)
  (add-hook (derived-mode-hook-name mode)
            (apply-partially 'sanityinc/set-major-mode-name name)))

;;----------------------------------------------------------------------------
;; String utilities missing from core emacs
;;----------------------------------------------------------------------------
(defun sanityinc/string-all-matches (regex str &optional group)
  "Find all matches for `REGEX' within `STR', returning the full match string or group `GROUP'."
  (let ((result nil)
        (pos 0)
        (group (or group 0)))
    (while (string-match regex str pos)
      (push (match-string group str) result)
      (setq pos (match-end group)))
    result))


;;----------------------------------------------------------------------------
;; Delete the current file
;;----------------------------------------------------------------------------
(defun delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))


;;----------------------------------------------------------------------------
;; Rename the current file
;;----------------------------------------------------------------------------
(defun rename-this-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (progn
      (when (file-exists-p filename)
        (rename-file filename new-name 1))
      (set-visited-file-name new-name)
      (rename-buffer new-name))))

;;----------------------------------------------------------------------------
;; Browse current HTML file
;;----------------------------------------------------------------------------
(defun browse-current-file ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))
#+END_SRC
** Load site-lisp
#+BEGIN_SRC emacs-lisp :tangle yes
(eval-when-compile (require 'cl))
(defun sanityinc/add-subdirs-to-load-path (parent-dir)
  "Adds every non-hidden subdir of PARENT-DIR to `load-path'."
  (let* ((default-directory parent-dir))
    (progn
      (setq load-path
            (append
             (remove-if-not
              (lambda (dir) (file-directory-p dir))
              (directory-files (expand-file-name parent-dir) t "^[^\\.]"))
             load-path)))))

(sanityinc/add-subdirs-to-load-path
 (expand-file-name "site-lisp/" user-emacs-directory))

;;; Utilities for grabbing upstream libs

(defun site-lisp-dir-for (name)
  (expand-file-name (format "site-lisp/%s" name) user-emacs-directory))

(defun site-lisp-library-el-path (name)
  (expand-file-name (format "%s.el" name) (site-lisp-dir-for name)))

(defun download-site-lisp-module (name url)
  (let ((dir (site-lisp-dir-for name)))
    (message "Downloading %s from %s" name url)
    (unless (file-directory-p dir)
      (make-directory dir t))
    (add-to-list 'load-path dir)
    (let ((el-file (site-lisp-library-el-path name)))
      (url-copy-file url el-file t nil)
      el-file)))

(defun ensure-lib-from-url (name url)
  (unless (site-lisp-library-loadable-p name)
    (byte-compile-file (download-site-lisp-module name url))))

(defun site-lisp-library-loadable-p (name)
  "Return whether or not the library `name' can be loaded from a
source file under ~/.emacs.d/site-lisp/name/"
  (let ((f (locate-library (symbol-name name))))
    (and f (string-prefix-p (file-name-as-directory (site-lisp-dir-for name)) f))))
#+END_SRC

** Setup package manager
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)
  ;;; Install into separate package dirs for each Emacs version, to prevent bytecode incompatibility
  (let ((versioned-package-dir
         (expand-file-name (format "elpa-%s.%s" emacs-major-version emacs-minor-version)
                           user-emacs-directory)))
    (setq package-user-dir versioned-package-dir))


  (add-to-list 'package-archives '( "melpa" . "https://melpa.org/packages/") t)
  ;; Official MELPA Mirror, in case necessary.
  ;;(add-to-list 'package-archives (cons "melpa-mirror" (concat proto "://www.mirrorservice.org/sites/melpa.org/packages/")) t)

  ;; Work-around for https://debbugs.gnu.org/cgi/bugreport.cgi?bug=34341
  (when (and (version< emacs-version "26.3") (boundp 'libgnutls-version) (>= libgnutls-version 30604))
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))

  (require 'cl-lib)

  (defun require-package (package &optional min-version no-refresh)
    "Install given PACKAGE, optionally requiring MIN-VERSION.
  If NO-REFRESH is non-nil, the available package lists will not be
  re-downloaded in order to locate PACKAGE."
    (or (package-installed-p package min-version)
        (let* ((known (cdr (assoc package package-archive-contents)))
               (versions (mapcar #'package-desc-version known)))
          (if (cl-find-if (lambda (v) (version-list-<= min-version v)) versions)
              (package-install package)
            (if no-refresh
                (error "No version of %s >= %S is available" package min-version)
              (package-refresh-contents)
              (require-package package min-version t))))))

  (defun maybe-require-package (package &optional min-version no-refresh)
    "Try to install PACKAGE, and return non-nil if successful.
  In the event of failure, return nil and print a warning message.
  Optionally require MIN-VERSION.  If NO-REFRESH is non-nil, the
  available package lists will not be re-downloaded in order to
  locate PACKAGE."
    (condition-case err
        (require-package package min-version no-refresh)
      (error
       (message "Couldn't install optional package `%s': %S" package err)
       nil)))

  
  ;;; Fire up package.el

  (setq package-enable-at-startup nil)
  (package-initialize)

  (defvar deos/did-refresh-packages nil
    "Flag for whether packages have been refreshed yet")

  (defun install-pkgs (list)
    (dolist (pkg list)
      (progn
        (if (not (package-installed-p pkg))
            (progn
              (if (not deos/did-refresh-packages)
                  (progn (package-refresh-contents)
                         (setq deos/did-refresh-packages t)))
              (package-install pkg))))))

  (install-pkgs '(use-package))
  ;; Load use-package, used for loading packages everywhere else
  (require 'use-package nil t)
  ;; Set to t to debug package loading or nil to disable
  (setq use-package-verbose nil)

  ;; package.el updates the saved version of package-selected-packages correctly only
  ;; after custom-file has been loaded, which is a bug. We work around this by adding
  ;; the required packages to package-selected-packages after startup is complete.

  (defvar sanityinc/required-packages nil)

  (defun sanityinc/note-selected-package (oldfun package &rest args)
    "If OLDFUN reports PACKAGE was successfully installed, note it in `sanityinc/required-packages'."
    (let ((available (apply oldfun package args)))
      (prog1 available
        (when (and available (boundp 'package-selected-packages))
          (add-to-list 'sanityinc/required-packages package)))))

  (advice-add 'require-package :around 'sanityinc/note-selected-package)

  (when (fboundp 'package--save-selected-packages)
    (require-package 'seq)
    (add-hook 'after-init-hook
              (lambda () (package--save-selected-packages
                     (seq-uniq (append sanityinc/required-packages package-selected-packages))))))

  
  (require-package 'fullframe)
  (fullframe list-packages quit-window)

  
  (let ((package-check-signature nil))
    (require-package 'gnu-elpa-keyring-update))

  
  (defun sanityinc/set-tabulated-list-column-width (col-name width)
    "Set any column with name COL-NAME to the given WIDTH."
    (when (> width (length col-name))
      (cl-loop for column across tabulated-list-format
               when (string= col-name (car column))
               do (setf (elt column 1) width))))

  (defun sanityinc/maybe-widen-package-menu-columns ()
    "Widen some columns of the package menu table to avoid truncation."
    (when (boundp 'tabulated-list-format)
      (sanityinc/set-tabulated-list-column-width "Version" 13)
      (let ((longest-archive-name (apply 'max (mapcar 'length (mapcar 'car package-archives)))))
        (sanityinc/set-tabulated-list-column-width "Archive" longest-archive-name))))

  (add-hook 'package-menu-mode-hook 'sanityinc/maybe-widen-package-menu-columns)
#+END_SRC

** Setup environment variables from shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :defer t
    :init
    (with-eval-after-load 'exec-path-from-shell
      (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "NIX_SSL_CERT_FILE" "NIX_PATH"))
        (add-to-list 'exec-path-from-shell-variables var)))


    (when (or (memq window-system '(mac ns x))
              (unless (memq system-type '(ms-dos windows-nt))
                (daemonp)))
      (exec-path-from-shell-initialize)))
#+END_SRC

* The Core
:PROPERTIES:
:CUSTOM_ID: core-config
:END:
This is the place where a lot of default config is set. Most variables
and functions should be in this file
** Load some packages
#+BEGIN_SRC emacs-lisp :tangle yes
  (require-package 'diminish)
  (maybe-require-package 'scratch)
  (require-package 'command-log-mode)
#+END_SRC
** It's about to get personal
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Newman"
      user-mail-address "dwnewman78@gmail.com")
#+END_SRC
** Some defaults
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :ensure t
  :init (diminish 'auto-fill-function ""))

(setq-default
 blink-cursor-interval 0.4
 bookmark-default-file (expand-file-name ".bookmarks.el" user-emacs-directory)
 buffers-menu-max-size 30
 case-fold-search t
 ediff-split-window-function 'split-window-horizontally
 ediff-window-setup-function 'ediff-setup-windows-plain
 indent-tabs-mode nil
 create-lockfiles nil
 auto-save-default nil
 make-backup-files nil
 mouse-yank-at-point t
 scroll-preserve-screen-position 'always
 set-mark-command-repeat-pop t
 tooltip-delay 1.5
 truncate-lines nil
 truncate-partial-width-windows nil)

(add-hook 'after-init-hook 'global-auto-revert-mode)
(setq global-auto-revert-non-file-buffers t
      auto-revert-verbose nil)
(with-eval-after-load 'autorevert
  (diminish 'auto-revert-mode))
#+END_SRC
** UTF-8 all the way!
#+begin_src emacs-lisp
(use-package list-unicode-display
  :ensure t)
(defun sanityinc/locale-var-encoding (v)
  "Return the encoding portion of the locale string V, or nil if missing."
  (when v
    (save-match-data
      (let ((case-fold-search t))
        (when (string-match "\\.\\([^.]*\\)\\'" v)
          (intern (downcase (match-string 1 v))))))))

(dolist (varname '("LC_ALL" "LANG" "LC_CTYPE"))
  (let ((encoding (sanityinc/locale-var-encoding (getenv varname))))
    (unless (memq encoding '(nil utf8 utf-8))
      (message "Warning: non-UTF8 encoding in environment variable %s may cause interop problems with this Emacs configuration." varname))))

(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
(unless (eq system-type 'windows-nt)
  (set-selection-coding-system 'utf-8))
#+end_src

** When I select a region and start typing, just delete the region automatically. This ends up working great with =expand-region=

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

** Don't warn me about large files unless they're at least 25mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 25 1024 1024))
#+END_SRC

** If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC

** Don't indicate empty lines or the end of a buffer with visual marks (the lines are cleaned up automatically anyway)

#+BEGIN_SRC emacs-lisp
(setq-default indicate-empty-lines nil)
(setq-default indicate-buffer-boundaries nil)
#+END_SRC

** Turn off all kinds of modes, I don't need the menu bar, or the tool bar:
#+BEGIN_SRC emacs-lisp
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))

(menu-bar-mode -1)
#+END_SRC

** No borders
#+BEGIN_SRC emacs-lisp :tangle yes
(let ((no-border '(internal-border-width . 0)))
  (add-to-list 'default-frame-alist no-border)
  (add-to-list 'initial-frame-alist no-border))
#+END_SRC

** Display line numbers
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp 'display-line-numbers-mode)
  (setq-default display-line-numbers-width 3)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode))
#+END_SRC

** Preview goto
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package goto-line-preview
  :ensure t
  :config
  (global-set-key [remap goto-line] 'goto-line-preview))
(when (fboundp 'display-line-numbers-mode)
  (defun sanityinc/with-display-line-numbers (f &rest args)
    (let ((display-line-numbers t))
      (apply f args)))
  (advice-add 'goto-line-preview :around #'sanityinc/with-display-line-numbers))
#+END_SRC
** Why would you not want to know lines/columns in your mode-line?

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** Page breaks
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t
  :diminish t
  :hook (after-init . global-page-break-lines-mode))
#+END_SRC

** Ignore case when using completion for file names:

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

** Nobody likes to have to type "yes" to questions, so change it to just hitting the =y= key to confirm:

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Confirm before killing emacs, but only on graphical sessions

#+BEGIN_SRC emacs-lisp
(when (window-system)
  (setq confirm-kill-emacs 'yes-or-no-p))
#+END_SRC

** It's much easier to move around lines based on how they are displayed, rather than the actual line. This helps a ton with long log file lines that may be wrapped:

#+BEGIN_SRC emacs-lisp
(setq line-move-visual t)
#+END_SRC

** Hide the mouse while typing:

#+BEGIN_SRC emacs-lisp
(setq make-pointer-invisible t)
#+END_SRC

** Set up the fill-column to 80 characters and set tab width to 2

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default default-tab-width 2)
#+END_SRC

** Fix some weird color escape sequences

#+BEGIN_SRC emacs-lisp
(setq system-uses-terminfo nil)
#+END_SRC

** Resolve symlinks:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename t)
#+END_SRC

** Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

** Uniquify buffers, using angle brackets, so you get =foo= and =foo<2>=:

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

** Search (and search/replace) using regex by default, since that's usually what I want to do:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "M-%") 'query-replace-regexp)
;; This is usually bound to `C-M-l', but that locks the screen on linux, so bind
;; it to something I can use
(global-set-key (kbd "M-L") 'reposition-window)
#+END_SRC

** Just kill this buffer, don't prompt me. I'll use helm if I want to kill a different buffer

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") #'kill-this-buffer)
#+END_SRC

** Single space still ends a sentence:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

** Split windows a bit better (don't split horizontally, I have a widescreen :P)

#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 180)
#+END_SRC

** Make sure auto automatically rescan for imenu changes:

#+BEGIN_SRC emacs-lisp
(set-default 'imenu-auto-rescan t)
#+END_SRC

** Seed the random number generator:

#+BEGIN_SRC emacs-lisp
(random t)
#+END_SRC

** Switch to unified diffs by default:

#+BEGIN_SRC emacs-lisp
(setq diff-switches "-u")
#+END_SRC

** Turn on auto-fill mode in text buffers:

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)

#+END_SRC

** Some local minor modes clash with CUA rectangle selection
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar-local sanityinc/suspended-modes-during-cua-rect nil
  "Modes that should be re-activated when cua-rect selection is done.")

(eval-after-load 'cua-rect
  (advice-add 'cua--deactivate-rectangle :after
              (lambda (&rest _)
                (dolist (m sanityinc/suspended-modes-during-cua-rect)
                  (funcall m 1)
                  (setq sanityinc/suspended-modes-during-cua-rect nil)))))

(defun sanityinc/suspend-mode-during-cua-rect-selection (mode-name)
  "Add an advice to suspend `MODE-NAME' while selecting a CUA rectangle."
  (eval-after-load 'cua-rect
    (advice-add 'cua--activate-rectangle :after
                (lambda (&rest _)
                  (when (bound-and-true-p mode-name)
                    (add-to-list 'sanityinc/suspended-modes-during-cua-rect mode-name)
                    (funcall mode-name 0))))))

(sanityinc/suspend-mode-during-cua-rect-selection 'whole-line-or-region-local-mode)
#+END_SRC
** Set the internal calculator not to go to scientific form quite so quickly:

#+BEGIN_SRC emacs-lisp
(setq calc-display-sci-low -5)
#+END_SRC
** Never kill the scratch
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package immortal-scratch
  :ensure t
  :hook (after-init . immortal-scratch-mode))
#+END_SRC
** Start a server if not running, but a only for gui-only:

#+BEGIN_SRC emacs-lisp :tangle no
(set-default 'server-socket-dir "~/.emacs.d/server")
(if (functionp 'window-system)
    (when (and (window-system)
           (>= emacs-major-version 24))
(server-start)))

#+END_SRC

** Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp
(when (boundp 'global-prettify-symbols-mode)
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("lambda" . ?λ) prettify-symbols-alist)))
  (add-hook 'clojure-mode-hook
            (lambda ()
              (push '("fn" . ?ƒ) prettify-symbols-alist)))
  (global-prettify-symbols-mode +1))
#+END_SRC

** Emacs (foolishly) defaults to adding the =--insecure= flag.
It also supports the (incredibly broken) SSL version 3. What are you thinking Emacs!?!

Here I set it back to a *sane* value:

#+BEGIN_SRC emacs-lisp
(setq tls-program
      ;; Defaults:
      ;; '("gnutls-cli --insecure -p %p %h"
      ;;   "gnutls-cli --insecure -p %p %h --protocols ssl3"
      ;;   "openssl s_client -connect %h:%p -no_ssl2 -ign_eof")
      '(;;"gnutls-cli -p %p %h"
        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof"))
#+END_SRC

** Toggle line wrapping with =C-x C-l=

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-l") #'toggle-truncate-lines)
#+end_src

** All restoring window placement with Emacs' built-in =winner-mode=
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'winner-mode)
#+END_SRC
** Save whatever's in the current (system) clipboard before replacing it with the Emacs' text.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
** Clean up whitespace

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :ensure t
  :diminish ws-butler-mode
  :init
  (add-hook 'prog-mode-hook #'ws-butler-mode)
  (add-hook 'org-mode-hook #'ws-butler-mode)
  (add-hook 'text-mode-hook #'ws-butler-mode))
#+END_SRC

** On the other hand, auto-indenting can be really handy.

#+BEGIN_SRC emacs-lisp
(use-package auto-indent-mode
  :ensure t)
#+END_SRC

** Usually =M-SPC= is bound to ~just-one-space~, but [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]] is actually a better alternative because it can shrink space between lines.

Thanks to
http://pragmaticemacs.com/emacs/delete-blank-lines-and-shrink-whitespace/ for
the link to this package.

#+BEGIN_SRC emacs-lisp
(use-package shrink-whitespace
  :ensure t
  :bind ("M-SPC" . shrink-whitespace))
#+END_SRC

** Extended bookmarks, which I've started used for dired buffers and so on.
I always have a bookmark for my Downloads folder as well as some TRAMP bookmarks
for my webserver, in case I want to manually copy things around.

#+BEGIN_SRC emacs-lisp
  (use-package bookmark+
    :disabled f
    :ensure t
    :defer 10
    :init (setq bmkp-replace-EWW-keys-flag t)
    :config
    (setq bookmark-version-control t
          ;; auto-save bookmarks
          bookmark-save-flag 1))
#+END_SRC

** Anzu shows the number of search hits in the modeline, which is handy.

It can also be used for a "refactor-like" thing similar to query-replace.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :defer t
  :bind ("M-%" . anzu-query-replace-regexp)
  :config
  (progn
    (use-package thingatpt)
    (setq anzu-mode-lighter ""
          ;; spaceline already takes care of this
          anzu-cons-mode-line-p nil)
    (set-face-attribute 'anzu-mode-line nil :foreground "yellow")))

(add-hook 'prog-mode-hook #'anzu-mode)
(add-hook 'org-mode-hook #'anzu-mode)
#+END_SRC

** Also, add a thing for yanking the entire symbol into the query while searching:

#+BEGIN_SRC emacs-lisp
(defun isearch-yank-symbol ()
  (interactive)
  (isearch-yank-internal (lambda () (forward-symbol 1) (point))))

(define-key isearch-mode-map (kbd "C-M-w") #'isearch-yank-symbol)
#+END_SRC

** Desktops and sessions
#+BEGIN_SRC emacs-lisp :tangle yes
;; save a list of open files in ~/.emacs.d/.emacs.desktop
(setq desktop-path (list user-emacs-directory)
      desktop-auto-save-timeout 600)
(desktop-save-mode 1)

(defun sanityinc/desktop-time-restore (orig &rest args)
  (let ((start-time (current-time)))
    (prog1
        (apply orig args)
      (message "Desktop restored in %.2fms"
               (sanityinc/time-subtract-millis (current-time)
                                               start-time)))))
(advice-add 'desktop-read :around 'sanityinc/desktop-time-restore)

(defun sanityinc/desktop-time-buffer-create (orig ver filename &rest args)
  (let ((start-time (current-time)))
    (prog1
        (apply orig ver filename args)
      (message "Desktop: %.2fms to restore %s"
               (sanityinc/time-subtract-millis (current-time)
                                               start-time)
               (when filename
                 (abbreviate-file-name filename))))))
(advice-add 'desktop-create-buffer :around 'sanityinc/desktop-time-buffer-create)
#+END_SRC

** Histories
Restore histories and registers after saving
#+BEGIN_SRC emacs-lisp :tangle yes

(setq-default history-length 1000)
(add-hook 'after-init-hook 'savehist-mode)

(use-package session
  :ensure t)

(setq session-save-file (expand-file-name ".session" user-emacs-directory))
(setq session-name-disable-regexp "\\(?:\\`'/tmp\\|\\.git/[A-Z_]+\\'\\)")
(setq session-save-file-coding-system 'utf-8)

(add-hook 'after-init-hook 'session-initialize)

;; save a bunch of variables to the desktop file
;; for lists specify the len of the maximal saved data also
(setq desktop-globals-to-save
      '((comint-input-ring        . 50)
        (compile-history          . 30)
        desktop-missing-file-warning
        (dired-regexp-history     . 20)
        (extended-command-history . 30)
        (face-name-history        . 20)
        (file-name-history        . 100)
        (grep-find-history        . 30)
        (grep-history             . 30)
        (ivy-history              . 100)
        (magit-revision-history   . 50)
        (minibuffer-history       . 50)
        (org-clock-history        . 50)
        (org-refile-history       . 50)
        (org-tags-history         . 50)
        (query-replace-history    . 60)
        (read-expression-history  . 60)
        (regexp-history           . 60)
        (regexp-search-ring       . 20)
        register-alist
        (search-ring              . 20)
        (shell-command-history    . 50)
        tags-file-name
        tags-table-list))
#+END_SRC

** Avy mode
#+BEGIN_SRC emacs-lisp
(use-package avy
  :init
  (progn (bind-key "M-s M-s" 'avy-isearch isearch-mode-map))
  :config
  (progn
    (use-package dash)

    (defun avy-isearch ()
      "Override to allow avy-background to work as configured."
      (interactive)
      (avy-with avy-isearch
                (avy--process
                 (avy--regex-candidates isearch-string)
                 (avy--style-fn avy-style))
                (isearch-done)))

    (setq avy-background t)
    (setq avy-all-windows 'all-frames)
    (setq avy-style 'de-bruijn)
    (setq avy-keys (-concat (number-sequence ?a ?z) (number-sequence ?A ?Z))))

  :bind (("M-s M-s w" . avy-goto-word-0)
         ("M-s s w"   . avy-goto-word-or-subword-1)
         ("M-s s l"   . avy-goto-line)
         ("M-s s i"   . avy-goto-char-in-line)
         ("M-s s c"   . avy-goto-char)
         ("M-s z t"   . avy-zap-to-char)
         ("M-s z u"   . avy-zap-up-to-char)
         ("M-s c c"   . avy-copy-line)
         ("M-s c m"   . avy-move-line)
         ("M-s c r"   . avy-copy-region)))
#+END_SRC

Automagically resizes the windows to be the golden ratio (1.618), nice when
using a big font size and I need more eshell space

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :defer t
  :init
  (add-hook 'ediff-before-setup-windows-hook (lambda () (golden-ratio-mode -1)))
  (add-hook 'ediff-quit-hook (lambda () (golden-ratio-mode 1)))
  :config
  ;; Default is 1.0, but I find this adjust just slightly less, which is nice
  (setq golden-ratio-adjust-factor .9)

  (defun deos/helm-alive-p ()
    (if (boundp 'helm-alive-p)
        (symbol-value 'helm-alive-p)))
  (defun deos/ispell-running-p ()
    (and (boundp 'ispell-choices-buffer)
         (get-buffer ispell-choices-buffer)))

  ;; Inhibit helm and ispell buffers
  (setq golden-ratio-inhibit-functions '(deos/helm-alive-p deos/ispell-running-p))

  (setq golden-ratio-exclude-buffer-regexp '("\\`\\*[Hh]elm.*\\*\\'")
        golden-ratio-exclude-buffer-names '("*Org Select*")
        golden-ratio-exclude-modes '(messages-buffer-mode
                                     fundamental-mode
                                     ediff-mode
                                     calendar-mode
                                     wget-mode
                                     calc-mode
                                     calc-trail-mode
                                     mu4e-view-mode
                                     mu4e-headers-mode)
        golden-ratio-recenter t))
#+END_SRC

Add a generic cleanup method that can be called everywhere, bound to =C-c n=:

#+BEGIN_SRC emacs-lisp
(defun untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max)))

(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))

(defvar bad-cleanup-modes '(python-mode yaml-mode)
  "List of modes where `cleanup-buffer' should not be used")

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a
buffer. If the buffer is one of the `bad-cleanup-modes' then no
re-indenting and un-tabification is done."
  (interactive)
  (unless (member major-mode bad-cleanup-modes)
    (progn
      (indent-buffer)
      (untabify-buffer)))
  (delete-trailing-whitespace))

;; Perform general cleanup.
(global-set-key (kbd "C-c n") #'cleanup-buffer)
#+END_SRC

Read-only viewing of files is quite useful. Keybindings for paging through stuff
in a less/vim manner.

Make sure you install =mupdf= for the best quality PDFs on Linux and OSX. (=brew
install mupdf= on osx)

#+BEGIN_SRC emacs-lisp
(use-package view
  :defer 15
  :config
  (progn
    (defun View-goto-line-last (&optional line)
      "goto last line"
      (interactive "P")
      (goto-line (line-number-at-pos (point-max))))

    (define-key view-mode-map (kbd "e") 'View-scroll-half-page-forward)
    (define-key view-mode-map (kbd "u") 'View-scroll-half-page-backward)

    ;; less like
    (define-key view-mode-map (kbd "N") 'View-search-last-regexp-backward)
    (define-key view-mode-map (kbd "?") 'View-search-regexp-backward?)
    (define-key view-mode-map (kbd "g") 'View-goto-line)
    (define-key view-mode-map (kbd "G") 'View-goto-line-last)
    ;; vi/w3m like
    (define-key view-mode-map (kbd "h") 'backward-char)
    (define-key view-mode-map (kbd "j") 'next-line)
    (define-key view-mode-map (kbd "k") 'previous-line)
    (define-key view-mode-map (kbd "l") 'forward-char)))

(use-package doc-view
  :config
  (define-key doc-view-mode-map (kbd "j")
    #'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k")
    #'doc-view-previous-line-or-previous-page)
  ;; use 'q' to kill the buffer, not just hide it
  (define-key doc-view-mode-map (kbd "q")
    #'kill-this-buffer))

(defun deos/turn-on-viewing-mode ()
  "Turn on the viewing mode, to make looking through logs easier"
  (interactive)
  (view-mode 1))
#+END_SRC

I also use the 'pdf-tools' package, which is *really* nice for viewing PDF
files. The only real caveat for it is that it requires you to do the =M-x
pdf-tools-install= every time the package is updated, to actually *build* the
tool that it uses.

#+BEGIN_SRC emacs-lisp :tangle no

(use-package pdf-tools
  :ensure t
  :when window-system
  :init (pdf-tools-install))
#+END_SRC

Expand region is useful it's insane.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :defer t
  :bind (("C-c e" . er/expand-region)
         ("C-M-@" . er/contract-region)))
#+END_SRC

Mulitple cursors is like rectangular selection/insertion but on steroids

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+END_SRC

VLF lets me handle things like 2gb files gracefully, which is good, because
sometimes I need to look at someone's 5gb log file.

#+BEGIN_SRC emacs-lisp
(use-package vlf-setup
  :ensure vlf)
#+END_SRC

I use M-x =proced= a lot to get a top-like (or htop-like) display of processes,
kill them and all that, when I do, I want it to auto-update

#+BEGIN_SRC emacs-lisp
(setq-default proced-auto-update-flag t)
(setq-default proced-auto-update-interval 5)
#+END_SRC

I don't really need bi-directional display, so let's speed up long lines

#+BEGIN_SRC emacs-lisp
(setq-default bidi-display-reordering nil)
#+END_SRC

Don't bother saving things to the kill-ring twice, remove duplicates

#+BEGIN_SRC emacs-lisp
(setq kill-do-not-save-duplicates t)
#+END_SRC

Preserve the window location when opening things

#+BEGIN_SRC emacs-lisp
(setq switch-to-buffer-preserve-window-point t)
#+END_SRC

Use a sane re-builder syntax so I don't have to have crazy escapes, see:
https://masteringemacs.org/article/re-builder-interactive-regexp-builder

#+BEGIN_SRC emacs-lisp
(setq reb-re-syntax 'string)
#+END_SRC

Ignore case when performing completion

#+BEGIN_SRC emacs-lisp
(setq completion-ignore-case t
      read-file-name-completion-ignore-case t)
#+END_SRC

I occasionally use =rgrep= to search through code, and it can be pretty handy to
be able to refactor the name of a method or something by making the ~*grep*~
buffer writable, that's what wgrep does.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :init (require 'wgrep))
#+END_SRC

Increase the auto-revert timer from its default of 5 seconds to a more
reasonable value

#+BEGIN_SRC emacs-lisp
(setq auto-revert-interval 10)
#+END_SRC
** Binding the EOS mega-map with Hydra
:PROPERTIES:
:CUSTOM_ID: eos-hydra-map
:END:

I'm used to not be a fan of hydra, mostly because I don't need popups for every
little thing under the sun. However, I lately decided I wanted a unified
interface to the parts of EOS.

#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)

(defhydra deos/hydra-toggle-map nil
  "
^Toggle^
^^^^^^^^----------------------
_d_: debug-on-error             _+_: monitor jack in
_D_: debug-on-quit              _-_: monitor jack out
_f_: fixed/variable width mode  _0_: monitor reset
_F_: auto-fill-mode             _R_: code reading mode
_l_: toggle-truncate-lines
_r_: read-only-mode
_v_: viewing-mode
_n_: narrow-or-widen-dwim
_g_: golden-ratio-mode
_q_: quit
"
  ("d" toggle-debug-on-error :exit t)
  ("D" toggle-debug-on-quit :exit t)
  ("g" golden-ratio-mode :exit t)
  ("f" variable-pitch-mode :exit t)
  ("F" auto-fill-mode :exit t)
  ("l" toggle-truncate-lines :exit t)
  ("r" read-only-mode :exit t)
  ("v" deos/turn-on-viewing-mode :exit t)
  ("n" deos/narrow-or-widen-dwim :exit t)
  ("+" deos/monitor-jack-in :exit t)
  ("-" deos/monitor-jack-out :exit t)
  ("0" deos/monitor-reset :exit t)
  ("R" deos/code-reading-mode :exit t)
  ("q" nil :exit t))

(defhydra deos/hydra-next-error nil
  "Error Selection"
  ("`" next-error "next")
  ("j" next-error "next" :bind nil)

  ("n" next-error "next" :bind nil)
  ("k" previous-error "previous" :bind nil)
  ("p" previous-error "previous" :bind nil)
  ("l" flycheck-list-errors "list-errors" :exit t)
  ("q" nil "quit" :color red))

(defhydra deos/hydra-macro
  (:pre
   (when defining-kbd-macro
     (kmacro-end-macro 1)))
  "
  ^Create-Cycle^   ^Basic^           ^Insert^        ^Save^         ^Edit^
╭─────────────────────────────────────────────────────────────────────────╯
     ^_k_^           [_e_] execute    [_n_] insert    [_b_] name      [_'_] previous
     ^^↑^^           [_d_] delete     [_t_] set       [_K_] key       [_,_] last
 ( ←   → )       [_o_] edit       [_a_] add       [_x_] register
     ^^↓^^           [_r_] region     [_f_] format    [_B_] defun
     ^_j_^           [_m_] step
    ^^   ^^          [_s_] swap
"
  ("(" kmacro-start-macro :color blue)
  (")" kmacro-end-or-call-macro-repeat)
  ("k" kmacro-cycle-ring-previous)
  ("j" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("e" kmacro-end-or-call-macro-repeat)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("n" kmacro-insert-counter)
  ("t" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" kmacro-edit-macro)
  ("," edit-kbd-macro)
  ("q" nil :color blue))
#+END_SRC

Here's a Hydra for information about the system (and emacs) that I stole from a
different user:

#+BEGIN_SRC emacs-lisp
(defhydra deos/hydra-about-emacs ()
  "
    About Emacs                                                        [_q_] quit
    ^^--------------------------------------------------------------------------
    PID:             %s(emacs-pid)
    Uptime:          %s(emacs-uptime)
    Init time:       %s(emacs-init-time)
    Directory:       %s(identity user-emacs-directory)
    Invoked from:    %s(concat invocation-directory invocation-name)
    Version:         %s(identity emacs-version)

    User Info
    ^^--------------------------------------------------------------------------
    User name:       %s(user-full-name)
    Login (real):    %s(user-login-name) (%s(user-real-login-name))
      UID (real):    %s(user-uid) (%s(user-real-uid))
      GID (real):    %s(group-gid) (%s(group-real-gid))
    Mail address:    %s(identity user-mail-address)

    System Info
    ^^--------------------------------------------------------------------------
    System name:     %s(system-name)
    System type:     %s(identity system-type)
    System config:   %s(identity system-configuration)
    "
  ("q" nil nil))
#+END_SRC

And finally, the main EOS Hydra for entry:

#+BEGIN_SRC emacs-lisp
(defhydra deos/hydra nil
  "
╭────────────────────────────────────────────────────────╯
  [_a_] Org Agenda       [_E_] ERC       [_m_] Mail
  [_t_] Toggle map       [_T_] Twitter   [_M_] Music
  [_s_] Skeletons                        [_g_] Gnus
  [_p_] Proced           [_W_] Weather   [(] Macros
  [_c_] Multi-compile    [_R_] RSS       [`] Errors
  [_d_] Downloads        [_D_] Debbugs   [_C_] ES-CC
                                         [_B_] Bookmarks
  [_q_] quit
"
  ("`" deos/hydra-next-error/body :exit t)
  ("(" deos/hydra-macro/body :exit t)
  ("a" (org-agenda nil " ") :exit t)
  ("A" deos/hydra-about-emacs/body :exit t)
  ("t" deos/hydra-toggle-map/body :exit t)
  ("T" deos/start-or-jump-to-twitter :exit t)
  ("g" gnus :exit t)
  ("d" deos/popup-downloads :exit t)
  ("D" debbugs-gnu :exit t)
  ("B" helm-bookmarks :exit t)
  ("C" es-command-center :exit t)
  ("m" deos/switch-to-mail :exit t)
  ("M" deos/hydra-mpd/body :exit t)
  ("c" multi-compile-run :exit t)
  ("E" (when (y-or-n-p "Really start ERC?") (start-erc)) :exit t)
  ("R" elfeed :exit t)
  ("s" deos/hydra-skeleton/body :exit t)
  ("p" proced :exit t)
  ("W" wttrin :exit t)
  ("q" nil :exit t))

;; Bind the main EOS hydra to M-t
(global-set-key (kbd "M-t") 'deos/hydra/body)
#+END_SRC

Undo-tree allows me to have sane undo defaults, as well as being able to
visualize it in ascii art if needed.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init (global-undo-tree-mode t)
  :defer t
  :diminish ""
  :config
  (progn
    (define-key undo-tree-map (kbd "C-x u") 'undo-tree-visualize)
    (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)))
(defhydra hydra-undo-tree (:color yello :hint nil)
  "
  _p_: undo _n_: redo _s_: save _l_: load  "
  ("p"   undo-tree-undo)
  ("n"   undo-tree-redo)
  ("s"   undo-tree-save-history)
  ("l"   undo-tree-load-history)
  ("u"   undo-tree-visualize "visualize" :color blue)
  ("q"   nil "quit" :color blue))

(global-set-key (kbd "M-,") 'hydra-undo-tree/undo-tree-undo)
#+END_SRC

** GPG and gpg-agent (as well as SSH agent)
:PROPERTIES:
:CUSTOM_ID: gpg-agent
:END:

I use =gpg-agent= [fn:30:
https://www.debian-administration.org/article/452/Using_gnupg-agent_to_securely_retain_keys]
as an ssh agent.

#+begin_src emacs-lisp
(defun tsp/gpg-version ()
  "Return the version of gpg as a string"
  (save-window-excursion
    (with-temp-buffer
      (shell-command (concat epg-gpg-program " --version") (current-buffer))
      (goto-char (point-min))
      (string-match "gpg (GnuPG) \\(.*\\)" (buffer-string))
      (tsp/str-chomp
       (match-string 1)))))
#+end_src

Before we start, let's install a nice little tool for setting up ssh-agent and
gpg-agent, =keychain=

I use =gpg2= everywhere, including in Emacs.

#+BEGIN_SRC emacs-lisp
(setq epg-gpg-program "gpg2")
#+END_SRC

** Spell check and flyspell settings
:PROPERTIES:
:CUSTOM_ID: spellcheck
:END:
I use Hunspell and Aspell checking spelling, ignoring words under 3 characters
and running very quickly. My personal word dictionary is at =~/.flydict=.

While I used to use Hunspell, I've gone back to aspell because it's a bit easier
to get up and running with.

#+BEGIN_SRC emacs-lisp :tangle true
  ;; Standard location of personal dictionary
  (setq ispell-personal-dictionary "~/.flydict")
  (require 'ispell)
  (when (executable-find ispell-program-name)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (with-eval-after-load 'flyspell
      (define-key flyspell-mode-map (kbd "C-;") nil)
      (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)))
#+END_SRC
** Which Key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC
** Key-chords
#+BEGIN_SRC emacs-lisp
  (use-package use-package-chords
    :ensure t
    :config
    (key-chord-mode 1))
#+END_SRC
** Open the config file
#+BEGIN_SRC emacs-lisp
(defun find-config ()
  "Edit config.org"
  (interactive)
  (find-file "~/.emacs.d/config.org"))
(global-set-key (kbd "C-c I") 'find-config)
#+END_SRC
** Stop C-z from minimizing windows under OSX
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sanityinc/maybe-suspend-frame ()
  (interactive)
  (unless (and *is-a-mac* window-system)
    (suspend-frame)))

(global-set-key (kbd "C-z") 'sanityinc/maybe-suspend-frame)
#+END_SRC
** Suppress GUI features
#+BEGIN_SRC emacs-lisp :tangle yes
(setq use-file-dialog nil)
(setq use-dialog-box nil)
(setq inhibit-startup-screen t)
#+END_SRC
** Basic gui functions
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sanityinc/adjust-opacity (frame incr)
  "Adjust the background opacity of FRAME by increment INCR."
  (unless (display-graphic-p frame)
    (error "Cannot adjust opacity of this frame"))
  (let* ((oldalpha (or (frame-parameter frame 'alpha) 100))
         ;; The 'alpha frame param became a pair at some point in
         ;; emacs 24.x, e.g. (100 100)
         (oldalpha (if (listp oldalpha) (car oldalpha) oldalpha))
         (newalpha (+ incr oldalpha)))
    (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
      (modify-frame-parameters frame (list (cons 'alpha newalpha))))))

(when (and *is-a-mac* (fboundp 'toggle-frame-fullscreen))
  ;; Command-Option-f to toggle fullscreen mode
  ;; Hint: Customize `ns-use-native-fullscreen'
  (global-set-key (kbd "M-ƒ") 'toggle-frame-fullscreen))

;; TODO: use seethru package instead?
(global-set-key (kbd "M-C-8") (lambda () (interactive) (sanityinc/adjust-opacity nil -2)))
(global-set-key (kbd "M-C-9") (lambda () (interactive) (sanityinc/adjust-opacity nil 2)))
(global-set-key (kbd "M-C-7") (lambda () (interactive) (modify-frame-parameters nil `((alpha . 100)))))


(when *is-a-mac*
  (when (maybe-require-package 'ns-auto-titlebar)
    (ns-auto-titlebar-mode)))


(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))

;; Non-zero values for `line-spacing' can mess up ansi-term and co,
;; so we zero it explicitly in those cases.
(add-hook 'term-mode-hook
          (lambda ()
            (setq line-spacing 0)))


;; Change global font size easily

(require-package 'default-text-scale)
(add-hook 'after-init-hook 'default-text-scale-mode)



(require-package 'disable-mouse)
#+END_SRC
** Recentf
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'after-init-hook 'recentf-mode)
(setq-default
 recentf-max-saved-items 1000
 recentf-exclude `("/tmp/" "/ssh:" ,(concat package-user-dir "/.*-autoloads\\.el\\'")))
#+END_SRC
* Appearance
** Theme
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package color-theme-sanityinc-solarized
  :ensure t)
(use-package color-theme-sanityinc-tomorrow
  :ensure t)

;; Don't prompt to confirm theme safety. This avoids problems with
;; first-time startup on Emacs > 26.3.
(setq custom-safe-themes t)

;; If you don't customize it, this is the theme you get.
(setq-default custom-enabled-themes '(sanityinc-tomorrow-bright))

;; Ensure that themes will be applied even if they have not been customized
(defun reapply-themes ()
  "Forcibly load the themes listed in `custom-enabled-themes'."
  (dolist (theme custom-enabled-themes)
    (unless (custom-theme-p theme)
      (load-theme theme)))
  (custom-set-variables `(custom-enabled-themes (quote ,custom-enabled-themes))))

(add-hook 'after-init-hook 'reapply-themes)


;;------------------------------------------------------------------------------
;; Toggle between light and dark
;;------------------------------------------------------------------------------
(defun light ()
  "Activate a light color theme."
  (interactive)
  (setq custom-enabled-themes '(sanityinc-tomorrow-day))
  (reapply-themes))

(defun dark ()
  "Activate a dark color theme."
  (interactive)
  (setq custom-enabled-themes '(sanityinc-tomorrow-bright))
  (reapply-themes))


(use-package dimmer
  :ensure t
  :init
  (setq-default dimmer-fraction 0.15)
  :hook (after-init . dimmer-mode)
  :config
  (with-eval-after-load 'dimmer
    ;; TODO: file upstream as a PR
    (advice-add 'frame-set-background-mode :after (lambda (&rest args) (dimmer-process-all))))
  (with-eval-after-load 'dimmer
    ;; Don't dim in terminal windows. Even with 256 colours it can
    ;; lead to poor contrast.  Better would be to vary dimmer-fraction
    ;; according to frame type.
    (defun sanityinc/display-non-graphic-p ()
      (not (display-graphic-p)))
    (add-to-list 'dimmer-exclusion-predicates 'sanityinc/display-non-graphic-p)))
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
;; The original font height (so it can be restored too at a later time)
(setq deos/original-height 180)

(defun deos/setup-fonts ()
(when *is-gui*
;; default font and variable-pitch fonts
(set-face-attribute 'default nil
                    :family "Iosevka"
                    :height deos/original-height)
    (dolist (face '(mode-line mode-line-inactive minibuffer-prompt))
      (set-face-attribute face nil :family "Iosevka"
                          :height deos/original-height))
    (set-face-attribute 'variable-pitch nil
                        :family "DejaVu Sans" :height deos/original-height)
    ;; font for all unicode characters
    ;;(set-fontset-font t 'unicode "DejaVu Sans Mono" nil 'prepend)
    ))

(when *is-gui*
  (add-hook 'after-init-hook #'deos/setup-fonts))
#+END_SRC
** Monitor Switching
Sometimes I want to plug my laptop into a larger monitor, or give presentations,
so I'd like to have a single function I can call to adjust any sizes that are
necessary.

The =deos/height-modifier= can be added or subtracted to the size of the font for
Emacs. I usually bind this in the Hydra toggle map.

#+BEGIN_SRC emacs-lisp
(defvar deos/height-modifier 15
  "Default value to increment the size by when jacking into a monitor.")

(defun deos/monitor-jack-in ()
  "Increase the font size by `deos/height-modifier' amount, for
when you jack into an external monitor."
  (interactive)
  (dolist (face '(default
                   mode-line
                   mode-line-inactive
                   minibuffer-prompt
                   variable-pitch))
    (set-face-attribute face nil :height (+ (face-attribute face :height)
                                            deos/height-modifier))))

(defun deos/monitor-jack-out ()
  "Decreas the font size by `deos/height-modifier' amount, for
when you jack out of an external monitor."
  (interactive)
  (dolist (face '(default
                   mode-line
                   mode-line-inactive
                   minibuffer-prompt
                   variable-pitch))
    (set-face-attribute face nil :height (- (face-attribute face :height)
                                            deos/height-modifier))))

(defun deos/monitor-reset ()
  "Go back to the default font size and `line-spacing'"
  (interactive)
  (dolist (face '(default
                   mode-line
                   mode-line-inactive
                   minibuffer-prompt
                   variable-pitch))
    (set-face-attribute face nil :height deos/original-height))
  (text-scale-adjust 0)
  (when (fboundp 'minimap-mode)
    (condition-case err
        (minimap-mode 0)
      ('error 0)))
  (setq line-spacing 0))

(defun deos/code-reading-mode ()
  "Do a bunch of fancy stuff to make reading/browsing code
easier. When you're done, `deos/monitor-jack-out' is a great way
to go back to a normal setup."
  (interactive)
  (delete-other-windows)
  (text-scale-increase 1)
  (setq line-spacing 5)
  (use-package minimap :ensure t)
  (when (not minimap-mode)
    (minimap-mode 1)))
#+END_SRC
** Mode line
*** Powerline mode
#+BEGIN_SRC emacs-lisp
(use-package powerline
  :ensure t
  :config
  (setq powerline-default-separator 'utf-8))
#+END_SRC
*** Feebleline mode
Minimalist mode line
#+BEGIN_SRC emacs-lisp
(use-package feebleline
  :ensure t)
#+END_SRC
*** Nyan Cat
Just for fun
#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :ensure t)
#+END_SRC
** Codenotes
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\<\\(NOTE\\|FIXME\\|TODO\\|BUG\\|HACK\\|REFACTOR\\|THE HORROR\\)" 1 font-lock-warning-face t)))))
#+END_SRC
* Navigation
Here are some navigation tricks that I've acquired over the years
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x +") 'balance-windows-area)

(global-set-key (kbd "C-c y") #'bury-buffer)
(global-set-key (kbd "C-c C-y") #'bury-buffer)
(global-set-key (kbd "C-c r") #'revert-buffer)

;; ==== Window switching ====
(defun deos/other-window-backwards ()
  (interactive)
  (other-window -1))

(global-set-key (kbd "M-'") #'other-window)
(global-set-key (kbd "M-\"") #'deos/other-window-backwards)
(global-set-key (kbd "H-'") #'other-window)
(global-set-key (kbd "H-\"") #'deos/other-window-backwards)
(global-set-key (kbd "<C-tab>") #'other-window)
(global-set-key (kbd "C-x C-o") #'other-window)
#+END_SRC
Transpose the buffers
#+BEGIN_SRC emacs-lisp :tangle yes
(defun transpose-buffers (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

(global-set-key (kbd "C-x 4 t") 'transpose-buffers)
#+END_SRC

Some random navigation keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x C-l") 'toggle-truncate-lines)

;; join line to next line
(global-set-key (kbd "M-j")
                (lambda ()
                  (interactive)
                  (join-line -1)))

;; Completion that uses many different methods to find options.
(global-set-key (kbd "M-/") 'hippie-expand)
(setq hippie-expand-try-functions-list
      '(try-complete-file-name-partially
        try-complete-file-name
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill))

;; Font size
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)

;; Start or switch to eshell
(global-set-key (kbd "C-x C-m") 'eshell)

;; If you want to be able to M-x without meta (phones, etc)
(global-set-key (kbd "C-c C-x") 'execute-extended-command)
#+END_SRC

Highlight helpers
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hl-anything
  :ensure t
  :diminish hl-highlight-mode
  :commands hl-highlight-mode
  :init
  (global-set-key (kbd "<f7> <f7>") 'hl-highlight-thingatpt-local)
  (global-set-key (kbd "<f7> u") 'hl-unhighlight-all-local)
  (global-set-key (kbd "<f7> U") 'hl-unhighlight-all-global)
  (global-set-key (kbd "<f7> n") 'hl-find-next-thing)
  (global-set-key (kbd "<f7> p") 'hl-find-prev-thing))
#+END_SRC

** Isearch
#+BEGIN_SRC emacs-lisp :tangle yes
; Use regex searches by default.
;;(global-set-key (kbd "C-s") 'isearch-forward-regexp)
;;(global-set-key (kbd "C-r") 'isearch-backward-regexp)
;; Case-fold regex by default
(setq search-default-mode 'character-fold-to-regexp)
;; Non regex search gets the meta also
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)

;; Activate occur easily inside isearch
(define-key isearch-mode-map (kbd "C-o")
  (lambda () (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))

(defun deos/add-watchword (string)
  "Highlight whatever `string' is in the current buffer
permanently."
  (font-lock-add-keywords
   nil `((,(if isearch-regexp isearch-string (regexp-quote isearch-string))
          1 '((:background "yellow") (:weight bold)) t))))

(define-key isearch-mode-map (kbd "M-h")
  (lambda () (interactive)
    (deos/add-watchword
     (if isearch-regexp isearch-string (regexp-quote isearch-string)))))
#+END_SRC

** Mices
#+BEGIN_SRC emacs-lisp :tangle yes
;; mouse integration
(require 'mouse)
(xterm-mouse-mode t)
(global-set-key [mouse-4] '(lambda ()
                           (interactive)
                           (scroll-down 1)))
(global-set-key [mouse-5] '(lambda ()
                           (interactive)
                           (scroll-up 1)))
(setq mouse-sel-mode t)
(defun track-mouse (e))
#+END_SRC

** Move text
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package move-text
  :ensure t
  :init (move-text-default-bindings))
#+END_SRC

** Navigating without control
For those who are a little less evil
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra :ensure t)
(require 'view)

(defhydra deos/nav-mode (:foreign-keys run)
  "[NAV-MODE] q or i to exit"
  ("t" toggle-truncate-lines)
  ("a" beginning-of-line)
  ("l" forward-char)
  ("<right>" forward-char)
  ("h" backward-char)
  ("<left>" backward-char)
  ("n" next-line)
  ("j" next-line)
  ("<down>" next-line)
  ("p" previous-line)
  ("k" previous-line)
  ("<up>" previous-line)
  ("e" View-scroll-half-page-forward)
  ("u" View-scroll-half-page-backward)
  ("SPC" scroll-up-command)
  ("S-SPC" scroll-down-command)
  ("<" beginning-of-buffer)
  (">" end-of-buffer)
  ("." end-of-buffer)
  ("C-'" nil)
  ("d" (when (y-or-n-p "Kill buffer?")
         (kill-this-buffer))
   :exit t)
  ("/" isearch-forward-regexp :exit t)
  ("?" isearch-backward-regexp :exit t)
  ("i" nil :exit t)
  ("q" nil :exit t))

(global-set-key (kbd "M-V") 'deos/nav-mode/body)
#+END_SRC
** Folding
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package origami
  :ensure t
  :bind (:map origami-mode-map
              ("C-c f" . origami-recursively-toggle-node)
              ("C-c F" . origami-toggle-all-nodes)))
#+END_SRC
* Org-mode
 Among settings for many aspects of `org-mode', this code includes
 an opinionated setup for the Getting Things Done (GTD) system based
 around the Org Agenda.  I have an "inbox.org" file with a header
 including

     #+CATEGORY: Inbox
     #+FILETAGS: INBOX

 and then set this file as `org-default-notes-file'.  Captured org
 items will then go into this file with the file-level tag, and can
 be refiled to other locations as necessary.

 Those other locations are generally other org files, which should
 be added to `org-agenda-files-list' (along with "inbox.org" org).
 With that done, there's then an agenda view, accessible via the
 `org-agenda' command, which gives a convenient overview.
 `org-todo-keywords' is customised here to provide corresponding
 TODO states, which should make sense to GTD adherents.
** Org-mode configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (when *is-a-mac*
    (use-package grab-mac-link
      :ensure t))

  (use-package org-cliplink
    :ensure t)

  (define-key global-map (kbd "C-c l") 'org-store-link)
  (define-key global-map (kbd "C-c a") 'org-agenda)

  (defvar sanityinc/org-global-prefix-map (make-sparse-keymap)
    "A keymap for handy global access to org helpers, particularly clocking.")

  (define-key sanityinc/org-global-prefix-map (kbd "j") 'org-clock-jump-to-current-clock)
  (define-key sanityinc/org-global-prefix-map (kbd "l") 'org-clock-in-last)
  (define-key sanityinc/org-global-prefix-map (kbd "i") 'org-clock-in)
  (define-key sanityinc/org-global-prefix-map (kbd "o") 'org-clock-out)
  (define-key global-map (kbd "C-c o") sanityinc/org-global-prefix-map)


  ;; Various preferences
  (setq org-log-done t
        org-edit-timestamp-down-means-later t
        org-hide-emphasis-markers t
        org-catch-invisible-edits 'show
        org-export-coding-system 'utf-8
        org-fast-tag-selection-single-key 'expert
        org-html-validation-link nil
        org-export-kill-product-buffer-when-displayed t
        org-tags-column 80)


  ;; Lots of stuff from http://doc.norang.ca/org-mode.html

  ;; Re-align tags when window shape changes
  (with-eval-after-load 'org-agenda
    (add-hook 'org-agenda-mode-hook
              (lambda () (add-hook 'window-configuration-change-hook 'org-agenda-align-tags nil t))))


  

  (use-package writeroom-mode
    :ensure t)

  (define-minor-mode prose-mode
    "Set up a buffer for prose editing.
  This enables or modifies a number of settings so that the
  experience of editing prose is a little more like that of a
  typical word processor."
    nil " Prose" nil
    (if prose-mode
        (progn
          (when (fboundp 'writeroom-mode)
            (writeroom-mode 1))
          (setq truncate-lines nil)
          (setq word-wrap t)
          (setq cursor-type 'bar)
          (when (eq major-mode 'org)
            (kill-local-variable 'buffer-face-mode-face))
          (buffer-face-mode 1)
          ;;(delete-selection-mode 1)
          (setq-local blink-cursor-interval 0.6)
          (setq-local show-trailing-whitespace nil)
          (setq-local line-spacing 0.2)
          (setq-local electric-pair-mode nil)
          (ignore-errors (flyspell-mode 1))
          (visual-line-mode 1))
      (kill-local-variable 'truncate-lines)
      (kill-local-variable 'word-wrap)
      (kill-local-variable 'cursor-type)
      (kill-local-variable 'blink-cursor-interval)
      (kill-local-variable 'show-trailing-whitespace)
      (kill-local-variable 'line-spacing)
      (kill-local-variable 'electric-pair-mode)
      (buffer-face-mode -1)
      ;; (delete-selection-mode -1)
      (flyspell-mode -1)
      (visual-line-mode -1)
      (when (fboundp 'writeroom-mode)
        (writeroom-mode 0))))

  ;;(add-hook 'org-mode-hook 'buffer-face-mode)


  (setq org-support-shift-select t)
  
  ;;; Capturing

  (global-set-key (kbd "C-c c") 'org-capture)

  (setq org-capture-templates
        `(("t" "todo" entry (file "")  ; "" => `org-default-notes-file'
           "* NEXT %?\n%U\n" :clock-resume t)
          ("n" "note" entry (file "")
           "* %? :NOTE:\n%U\n%a\n" :clock-resume t)
          ))


  
  ;;; Refiling

  (setq org-refile-use-cache nil)

  ;; Targets include this file and any file contributing to the agenda - up to 5 levels deep
  (setq org-refile-targets '((nil :maxlevel . 5) (org-agenda-files :maxlevel . 5)))

  (with-eval-after-load 'org-agenda
    (add-to-list 'org-agenda-after-show-hook 'org-show-entry))

  (advice-add 'org-refile :after (lambda (&rest _) (org-save-all-org-buffers)))

  ;; Exclude DONE state tasks from refile targets
  (defun sanityinc/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets."
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))
  (setq org-refile-target-verify-function 'sanityinc/verify-refile-target)

  (defun sanityinc/org-refile-anywhere (&optional goto default-buffer rfloc msg)
    "A version of `org-refile' which allows refiling to any subtree."
    (interactive "P")
    (let ((org-refile-target-verify-function))
      (org-refile goto default-buffer rfloc msg)))

  (defun sanityinc/org-agenda-refile-anywhere (&optional goto rfloc no-update)
    "A version of `org-agenda-refile' which allows refiling to any subtree."
    (interactive "P")
    (let ((org-refile-target-verify-function))
      (org-agenda-refile goto rfloc no-update)))

  ;; Targets start with the file name - allows creating level 1 tasks
  ;;(setq org-refile-use-outline-path (quote file))
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)

  ;; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes 'confirm)

  
  ;;; To-do settings

  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
                (sequence "PROJECT(p)" "|" "DONE(d!/!)" "CANCELLED(c@/!)")
                (sequence "WAITING(w@/!)" "DELEGATED(e!)" "HOLD(h)" "|" "CANCELLED(c@/!)")))
        org-todo-repeat-to-state "NEXT")

  (setq org-todo-keyword-faces
        (quote (("NEXT" :inherit warning)
                ("PROJECT" :inherit font-lock-string-face))))


  
  ;;; Agenda views

  (setq-default org-agenda-clockreport-parameter-plist '(:link t :maxlevel 3))


  (let ((active-project-match "-INBOX/PROJECT"))

    (setq org-stuck-projects
          `(,active-project-match ("NEXT")))

    (setq org-agenda-compact-blocks t
          org-agenda-sticky t
          org-agenda-start-on-weekday nil
          org-agenda-span 'day
          org-agenda-include-diary nil
          org-agenda-sorting-strategy
          '((agenda habit-down time-up user-defined-up effort-up category-keep)
            (todo category-up effort-up)
            (tags category-up effort-up)
            (search category-up))
          org-agenda-window-setup 'current-window
          org-agenda-custom-commands
          `(("N" "Notes" tags "NOTE"
             ((org-agenda-overriding-header "Notes")
              (org-tags-match-list-sublevels t)))
            ("g" "GTD"
             ((agenda "" nil)
              (tags "INBOX"
                    ((org-agenda-overriding-header "Inbox")
                     (org-tags-match-list-sublevels nil)))
              (stuck ""
                     ((org-agenda-overriding-header "Stuck Projects")
                      (org-agenda-tags-todo-honor-ignore-options t)
                      (org-tags-match-list-sublevels t)
                      (org-agenda-todo-ignore-scheduled 'future)))
              (tags-todo "-INBOX"
                         ((org-agenda-overriding-header "Next Actions")
                          (org-agenda-tags-todo-honor-ignore-options t)
                          (org-agenda-todo-ignore-scheduled 'future)
                          (org-agenda-skip-function
                           '(lambda ()
                              (or (org-agenda-skip-subtree-if 'todo '("HOLD" "WAITING"))
                                  (org-agenda-skip-entry-if 'nottodo '("NEXT")))))
                          (org-tags-match-list-sublevels t)
                          (org-agenda-sorting-strategy
                           '(todo-state-down effort-up category-keep))))
              (tags-todo ,active-project-match
                         ((org-agenda-overriding-header "Projects")
                          (org-tags-match-list-sublevels t)
                          (org-agenda-sorting-strategy
                           '(category-keep))))
              (tags-todo "-INBOX/-NEXT"
                         ((org-agenda-overriding-header "Orphaned Tasks")
                          (org-agenda-tags-todo-honor-ignore-options t)
                          (org-agenda-todo-ignore-scheduled 'future)
                          (org-agenda-skip-function
                           '(lambda ()
                              (or (org-agenda-skip-subtree-if 'todo '("PROJECT" "HOLD" "WAITING" "DELEGATED"))
                                  (org-agenda-skip-subtree-if 'nottododo '("TODO")))))
                          (org-tags-match-list-sublevels t)
                          (org-agenda-sorting-strategy
                           '(category-keep))))
              (tags-todo "/WAITING"
                         ((org-agenda-overriding-header "Waiting")
                          (org-agenda-tags-todo-honor-ignore-options t)
                          (org-agenda-todo-ignore-scheduled 'future)
                          (org-agenda-sorting-strategy
                           '(category-keep))))
              (tags-todo "/DELEGATED"
                         ((org-agenda-overriding-header "Delegated")
                          (org-agenda-tags-todo-honor-ignore-options t)
                          (org-agenda-todo-ignore-scheduled 'future)
                          (org-agenda-sorting-strategy
                           '(category-keep))))
              (tags-todo "-INBOX"
                         ((org-agenda-overriding-header "On Hold")
                          (org-agenda-skip-function
                           '(lambda ()
                              (or (org-agenda-skip-subtree-if 'todo '("WAITING"))
                                  (org-agenda-skip-entry-if 'nottodo '("HOLD")))))
                          (org-tags-match-list-sublevels nil)
                          (org-agenda-sorting-strategy
                           '(category-keep))))
              ;; (tags-todo "-NEXT"
              ;;            ((org-agenda-overriding-header "All other TODOs")
              ;;             (org-match-list-sublevels t)))
              )))))


  (add-hook 'org-agenda-mode-hook 'hl-line-mode)

  
  ;;; Org clock

  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (with-eval-after-load 'org
    (org-clock-persistence-insinuate))
  (setq org-clock-persist t)
  (setq org-clock-in-resume t)

  ;; Save clock data and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)
  ;; Save state changes in the LOGBOOK drawer
  (setq org-log-into-drawer t)
  ;; Removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)

  ;; Show clock sums as hours and minutes, not "n days" etc.
  (setq org-time-clocksum-format
        '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))


  
  ;;; Show the clocked-in task - if any - in the header line
  (defun sanityinc/show-org-clock-in-header-line ()
    (setq-default header-line-format '((" " org-mode-line-string " "))))

  (defun sanityinc/hide-org-clock-from-header-line ()
    (setq-default header-line-format nil))

  (add-hook 'org-clock-in-hook 'sanityinc/show-org-clock-in-header-line)
  (add-hook 'org-clock-out-hook 'sanityinc/hide-org-clock-from-header-line)
  (add-hook 'org-clock-cancel-hook 'sanityinc/hide-org-clock-from-header-line)

  (with-eval-after-load 'org-clock
    (define-key org-clock-mode-line-map [header-line mouse-2] 'org-clock-goto)
    (define-key org-clock-mode-line-map [header-line mouse-1] 'org-clock-menu))


  
  (when (and *is-a-mac* (file-directory-p "/Applications/org-clock-statusbar.app"))
    (add-hook 'org-clock-in-hook
              (lambda () (call-process "/usr/bin/osascript" nil 0 nil "-e"
                                       (concat "tell application \"org-clock-statusbar\" to clock in \"" org-clock-current-task "\""))))
    (add-hook 'org-clock-out-hook
              (lambda () (call-process "/usr/bin/osascript" nil 0 nil "-e"
                                       "tell application \"org-clock-statusbar\" to clock out"))))


  
  ;; TODO: warn about inconsistent items, e.g. TODO inside non-PROJECT
  ;; TODO: nested projects!


  
  ;;; Archiving

  (setq org-archive-mark-done nil)
  (setq org-archive-location "%s_archive::* Archive")



  

  (use-package org-pomodoro
    :ensure t)
  (setq org-pomodoro-keep-killed-pomodoro-time t)
  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "P") 'org-pomodoro))


  ;; ;; Show iCal calendars in the org agenda
  ;; (when (and *is-a-mac* (require 'org-mac-iCal nil t))
  ;;   (setq org-agenda-include-diary t
  ;;         org-agenda-custom-commands
  ;;         '(("I" "Import diary from iCal" agenda ""
  ;;            ((org-agenda-mode-hook #'org-mac-iCal)))))

  ;;   (add-hook 'org-agenda-cleanup-fancy-diary-hook
  ;;             (lambda ()
  ;;               (goto-char (point-min))
  ;;               (save-excursion
  ;;                 (while (re-search-forward "^[a-z]" nil t)
  ;;                   (goto-char (match-beginning 0))
  ;;                   (insert "0:00-24:00 ")))
  ;;               (while (re-search-forward "^ [a-z]" nil t)
  ;;                 (goto-char (match-beginning 0))
  ;;                 (save-excursion
  ;;                   (re-search-backward "^[0-9]+:[0-9]+-[0-9]+:[0-9]+ " nil t))
  ;;                 (insert (match-string 0))))))


  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-M-<up>") 'org-up-element)
    (when *is-a-mac*
      (define-key org-mode-map (kbd "M-h") nil)
      (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))

  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     `((R . t)
       (ditaa . t)
       (dot . t)
       (emacs-lisp . t)
       (gnuplot . t)
       (haskell . nil)
       (latex . t)
       (ledger . t)
       (ocaml . nil)
       (octave . t)
       (plantuml . t)
       (python . t)
       (ruby . t)
       (screen . nil)
       (,(if (locate-library "ob-sh") 'sh 'shell) . t)
       (sql . t)
       (sqlite . t))))
#+END_SRC
** Deft
:LOGBOOK:
CLOCK: [2020-08-17 Mon 17:17]--[2020-08-17 Mon 17:18] =>  0:01
:END:
I use deft to take quick notes and search through those notes

#+BEGIN_SRC emacs-lisp
(use-package deft
  :ensure t
  :bind ("C-x t" . deft)
  :config
  (setq deft-extension '("org" "txt" "tex" "text" "md")
        deft-directory "~/personal/org/deft/"
        deft-recursive t
        deft-use-filter-string-for-filename t
        deft-text-mode 'org-mode))
#+END_SRC
* Command completion
** Ivy
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy
  :ensure t
  :demand t
  :diminish ivy-mode
  :bind
  (("C-M-z" . ivy-resume)
   ("C-x C-r" . ivy-switch-buffer)
   ("C-x o" . swiper))
   :init
   (ivy-mode 1)
   :config
   (bind-key "C-s" 'swiper)
   ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
   (setq ivy-use-virtual-buffers t)
   ;; number of result lines to display
   ;; (setq ivy-height 10)
   ;; does not count candidates
   (setq ivy-count-format "%d/%d ")
   ;; no regexp by default
   ;; (setq ivy-initial-inputs-alist nil)
   ;; configure regexp engine.
   ;; (setq ivy-re-builders-alist
   ;;       ;; allow input not in order
   ;;       '((t   . ivy--regex-ignore-order)))
#+END_SRC
** IDO
#+BEGIN_SRC emacs-lisp
(use-package ido
  :init
  (ido-mode 1)
  (use-package ido-completing-read+
    :ensure t
    :init (ido-ubiquitous-mode 1))
  (use-package ido-vertical-mode
    :ensure t
    :init (ido-vertical-mode 1))
  (use-package flx-ido
    :ensure t
    :init (flx-ido-mode 1))
  (use-package smex
    :ensure t
    :init
    (smex-initialize)
    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)))
#+END_SRC
** HELM
There are many helm things. I use it a lot.

A lot of things are taken from taken from
https://tuhdo.github.io/helm-intro.html

Before we load any helm things, need to load [[https://github.com/PythonNut/helm-flx][helm-flx]] so it uses flx instead of
helm's fuzzy matching. This has to happen before helm is loaded, so it goes
here.

Now we can load the big Helm configuration. Here is a breakdown of the helm
bindings I use more frequently:

| Key     | Action                                          |
|---------+-------------------------------------------------|
| M-x     | helm meta-x                                     |
| C-x C-f | helm find files                                 |
| C-x C-d | helm browse project                             |
| C-x f   | helm projectile                                 |
| C-x C-r | helm mini (includes recentf)                    |
| C-x C-o | helm occur (search in buffer)                   |
| M-y     | helm kill ring                                  |
| C-h a   | helm appropos (search functions/vars/commands)  |
| C-h m   | helm man (man pages)                            |
| C-h SPC | helm registers                                  |
| C-x b   | helm mini                                       |
| C-h t   | helm world time (show time in different places) |
| C-x C-i | helm semantic or imenu (depending on the mode)  |


#+BEGIN_SRC emacs-lisp
(use-package helm-flx
  :ensure t
  :init
  (setq helm-flx-for-helm-find-files nil)
  (helm-flx-mode 1))

(use-package helm-config
  :ensure helm
  :demand t ;; demand it be loaded!
  :diminish helm-mode
  :bind
  (("C-M-z" . helm-resume)
   ("C-x C-f" . helm-find-files)
   ("C-x C-r" . helm-mini)
   ("C-x o" . helm-occur)
   ("M-y" . helm-show-kill-ring)
   ("C-h a" . helm-apropos)
   ("C-h m" . helm-man-woman)
   ("C-h SPC" . helm-all-mark-rings)
   ("C-x C-i" . helm-semantic-or-imenu)
   ("M-x" . helm-M-x)
   ("C-x C-b" . helm-buffers-list)
   ("C-x C-r" . helm-mini)
   ("C-x b" . helm-mini)
   ("C-x R" . helm-register)
   ("C-h t" . helm-world-time)
   ("M-g a" . helm-do-grep-ag)
   ("M-g p" . helm-do-ag-project-root)
   ("M-g G" . helm-grep-do-git-grep))
  :init
  (defvar deos/helm-display-help-buffer-regexp '("*.*Helm.*Help.**"))
  (defvar deos/helm-display-buffer-regexp
    `("*.*helm.**"
      (display-buffer-in-side-window)
      (inhibit-same-window . t)
      (side . bottom)
      (window-width . 0.6)
      (window-height . 0.4)))

  (defun deos/display-helm-window (buffer &optional resume)
    "Display the Helm window."
    (let ((display-buffer-alist
           (list deos/helm-display-help-buffer-regexp
                 ;; this or any specialized case of Helm buffer must be
                 ;; added AFTER `deos/helm-display-buffer-regexp'.
                 ;; Otherwise, `deos/helm-display-buffer-regexp' will
                 ;; be used before
                 ;; `deos/helm-display-help-buffer-regexp' and display
                 ;; configuration for normal Helm buffer is applied for helm
                 ;; help buffer, making the help buffer unable to be
                 ;; displayed.
                 deos/helm-display-buffer-regexp)))
      (helm-default-display-buffer buffer)))

  (setq helm-grep-default-command
        "grep -a -d skip %e -n%cH -e %p %f"
        ;; may be overridden if 'ggrep' is in path (see below)
        helm-grep-default-recurse-command
        "grep -a -d recurse %e -n%cH -e %p %f"
        ;; use CURL, not url-retrieve-synchronously
        helm-net-prefer-curl t
        ;; be idle for this many seconds, before updating in delayed sources.
        helm-input-idle-delay 0
        ;; wider buffer name in helm-buffers-list
        helm-buffer-max-length 28 ;; default is 20
        ;; instead of "..." use a smaller unicode ellipsis
        helm-buffers-end-truncated-string "…"
        ;; open helm buffer in another window
        ;;helm-split-window-default-side 'other
        ;; set to nil and use <C-backspace> to toggle it in helm-find-files
        helm-ff-auto-update-initial-value nil
        ;; if I change the resplit state, re-use my settings
        helm-reuse-last-window-split-state t
        ;; don't delete windows to always have 2
        helm-always-two-windows nil
        ;; open helm buffer inside current window, don't occupy whole other window
        helm-split-window-inside-p t
        ;; display using my function, not helm's (helm is too slow here)
        helm-display-function #'deos/display-helm-window
        ;; display helm in a separate frame
        ;; helm-display-function 'helm-display-buffer-in-own-frame
        ;; reuse frame so display is faster on Emacs 26+
        ;; helm-display-buffer-reuse-frame t
        ;; helm-display-buffer-width 144
        ;; helm-display-buffer-height 24
        ;; use undecorated frame on Emacs 26+
        helm-use-undecorated-frame-option t
        ;; don't check if the file exists on remote files
        helm-buffer-skip-remote-checking t
        ;; limit the number of displayed canidates
        helm-candidate-number-limit 100
        ;; don't use recentf stuff in helm-ff, I use C-x C-r for this
        helm-ff-file-name-history-use-recentf nil
        ;; move to end or beginning of source when reaching top or bottom
        ;; of source
        helm-move-to-line-cycle-in-source t
        ;; don't display the header line
        helm-display-header-line nil
        ;; verbosity for helm tramp messages
        helm-tramp-verbose 0
        ;; fuzzy matching
        helm-recentf-fuzzy-match t
        helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
        helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-semantic-fuzzy-match nil
        helm-gtags-fuzzy-match nil
        helm-imenu-fuzzy-match nil
        helm-apropos-fuzzy-match nil
        helm-lisp-fuzzy-completion nil
        helm-completion-in-region-fuzzy-match nil
        ;; autoresize to 25 rows
        helm-autoresize-min-height 25
        helm-autoresize-max-height 25
        ;; Here are the things helm-mini shows, I add `helm-source-bookmarks'
        ;; here to the regular default list
        helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-recentf
                                    helm-source-bookmarks
                                    helm-source-buffer-not-found)
        ;; Reduce the list of things for helm-apropos
        helm-apropos-function-list '(helm-def-source--emacs-commands
                                     helm-def-source--emacs-functions
                                     helm-def-source--emacs-variables
                                     helm-def-source--emacs-faces))
  :config
  (use-package helm-files
    :config (setq helm-ff-file-compressed-list '("gz" "bz2" "zip" "tgz" "xz" "txz")))
  (use-package helm-buffers
    :config
    (add-to-list 'helm-boring-buffer-regexp-list "^TAGS$"))
  (use-package helm-mode
    :diminish helm-mode
    :init
    (add-hook 'after-init-hook #'helm-mode)
    (add-hook 'after-init-hook #'helm-autoresize-mode)
    (add-hook 'after-init-hook #'helm-adaptive-mode)
    (add-hook 'after-init-hook #'helm-popup-tip-mode))
  (use-package helm-sys
    :init (add-hook 'after-init-hook #'helm-top-poll-mode))
  (use-package helm-grep
    :config
    (setq helm-grep-truncate-lines nil)
    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
    (when (executable-find "rg")
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s"
            helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))))
  (use-package helm-man)
  (use-package helm-misc)
  (use-package helm-elisp)
  (use-package helm-imenu)
  (use-package helm-semantic)
  (use-package helm-ring)
  (use-package smex :ensure t)
  (use-package helm-smex :ensure t)
  (use-package helm-bookmark
    :bind ("C-x M-b" . helm-bookmarks))
  (use-package projectile-ripgrep :ensure t)
  (use-package helm-projectile
    :ensure t
    :demand t ;; demand it be loaded!
    :bind (:map projectile-command-map
                ("b" . helm-projectile-switch-to-buffer)
                ("d" . helm-projectile-find-dir)
                ("f" . helm-projectile-find-file)
                ("p" . helm-projectile-switch-project)
                ("s s" . helm-projectile-ag)
                ("s r" . projectile-ripgrep))
    :init
    (setq projectile-switch-project-action 'helm-projectile)
    (helm-projectile-on)
    (helm-delete-action-from-source
     "Grep in projects `C-s'"
     helm-source-projectile-projects)
    (helm-add-action-to-source
     "Ag in project C-s'"
     'helm-do-ag helm-source-projectile-projects)
    (bind-key "C-s" (defun helm-projectile-do-ag ()
                      (interactive)
                      (helm-exit-and-execute-action #'helm-do-ag))
              helm-projectile-projects-map)
    (global-set-key (kbd "C-x f") #'helm-projectile-find-file)
    :config
    (setq-default helm-truncate-lines t
                  helm-projectile-truncate-lines t))

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  ;; Use popwin for helm buffers, otherwise I can't get helm to display the way
  ;; I want (at the bottom, without deleting windows)
  ;; (when (fboundp 'popwin:special-display-config)
  ;;   (push '("^\*helm.+\*$" :regexp t :height 20) popwin:special-display-config)
  ;;   (setq helm-display-function 'popwin:pop-to-buffer))

  ;; Shows helm input in the header instead of the footer
  (setq helm-echo-input-in-header-line t)
  (defun helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)

  ;; Files that helm should know how to open
  (setq helm-external-programs-associations
        '(("avi"  . "mpv")
          ("part" . "mpv")
          ("mkv"  . "mpv")
          ("webm" . "mpv")
          ("mp4"  . "mpv")))

  ;; List of times to show in helm-world-time
  (setq display-time-world-list '(("PST8PDT" "Mountain View")
                                  ("America/Denver" "Denver")
                                  ("EST5EDT" "Boston")
                                  ("UTC" "UTC")
                                  ("Europe/London" "London")
                                  ("Europe/Amsterdam" "Amsterdam")
                                  ("Asia/Bangkok" "Bangkok")
                                  ("Asia/Tokyo" "Tokyo")
                                  ("Australia/Sydney" "Sydney")))

  ;; rebind tab to do persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)

  (define-key helm-map (kbd "C-p")   'helm-previous-line)
  (define-key helm-map (kbd "C-n")   'helm-next-line)
  (define-key helm-map (kbd "C-M-n") 'helm-next-source)
  (define-key helm-map (kbd "C-M-p") 'helm-previous-source)
  (define-key helm-map (kbd "M-N")   'helm-next-source)
  (define-key helm-map (kbd "M-P")   'helm-previous-source)

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ;; ggrep is gnu grep on OSX
  (when (executable-find "ggrep")
    (setq helm-grep-default-command
          "ggrep -a -d skip %e -n%cH -e %p %f"
          helm-grep-default-recurse-command
          "ggrep -a -d recurse %e -n%cH -e %p %f"))

  ;; helm-mini instead of recentf
  (define-key 'help-command (kbd "C-f") 'helm-apropos)
  (define-key 'help-command (kbd "r") 'helm-info-emacs)

  (defvar helm-httpstatus-source
    '((name . "HTTP STATUS")
      (candidates . (("100 Continue") ("101 Switching Protocols")
                     ("102 Processing") ("200 OK")
                     ("201 Created") ("202 Accepted")
                     ("203 Non-Authoritative Information") ("204 No Content")
                     ("205 Reset Content") ("206 Partial Content")
                     ("207 Multi-Status") ("208 Already Reported")
                     ("300 Multiple Choices") ("301 Moved Permanently")
                     ("302 Found") ("303 See Other")
                     ("304 Not Modified") ("305 Use Proxy")
                     ("307 Temporary Redirect") ("400 Bad Request")
                     ("401 Unauthorized") ("402 Payment Required")
                     ("403 Forbidden") ("404 Not Found")
                     ("405 Method Not Allowed") ("406 Not Acceptable")
                     ("407 Proxy Authentication Required") ("408 Request Timeout")
                     ("409 Conflict") ("410 Gone")
                     ("411 Length Required") ("412 Precondition Failed")
                     ("413 Request Entity Too Large")
                     ("414 Request-URI Too Large")
                     ("415 Unsupported Media Type")
                     ("416 Request Range Not Satisfiable")
                     ("417 Expectation Failed") ("418 I'm a teapot")
                     ("421 Misdirected Request")
                     ("422 Unprocessable Entity") ("423 Locked")
                     ("424 Failed Dependency") ("425 No code")
                     ("426 Upgrade Required") ("428 Precondition Required")
                     ("429 Too Many Requests")
                     ("431 Request Header Fields Too Large")
                     ("449 Retry with") ("500 Internal Server Error")
                     ("501 Not Implemented") ("502 Bad Gateway")
                     ("503 Service Unavailable") ("504 Gateway Timeout")
                     ("505 HTTP Version Not Supported")
                     ("506 Variant Also Negotiates")
                     ("507 Insufficient Storage") ("509 Bandwidth Limit Exceeded")
                     ("510 Not Extended")
                     ("511 Network Authentication Required")))
      (action . message)))

  (defvar helm-clj-http-source
    '((name . "clj-http options")
      (candidates
       .
       ((":accept - keyword for content type to accept")
        (":as - output coercion: :json, :json-string-keys, :clojure, :stream, :auto or string")
        (":basic-auth - string or vector of basic auth creds")
        (":body - body of request")
        (":body-encoding - encoding type for body string")
        (":client-params - apache http client params")
        (":coerce - when to coerce response body: :always, :unexceptional, :exceptional")
        (":conn-timeout - timeout for connection")
        (":connection-manager - connection pooling manager")
        (":content-type - content-type for request")
        (":cookie-store - CookieStore object to store/retrieve cookies")
        (":cookies - map of cookie name to cookie map")
        (":debug - boolean to print info to stdout")
        (":debug-body - boolean to print body debug info to stdout")
        (":decode-body-headers - automatically decode body headers")
        (":decompress-body - whether to decompress body automatically")
        (":digest-auth - vector of digest authentication")
        (":follow-redirects - boolean whether to follow HTTP redirects")
        (":form-params - map of form parameters to send")
        (":headers - map of headers")
        (":ignore-unknown-host? - whether to ignore inability to resolve host")
        (":insecure? - boolean whether to accept invalid SSL certs")
        (":json-opts - map of json options to be used for form params")
        (":keystore - file path to SSL keystore")
        (":keystore-pass - password for keystore")
        (":keystore-type - type of SSL keystore")
        (":length - manually specified length of body")
        (":max-redirects - maximum number of redirects to follow")
        (":mime-subtype - type for multipart mime parts")
        (":multipart - vector of multipart options")
        (":oauth-token - oauth token")
        (":proxy-host - hostname of proxy server")
        (":proxy-ignore-hosts - set of hosts to ignore for proxy")
        (":proxy-post - port for proxy server")
        (":query-params - map of query parameters")
        (":raw-headers - boolean whether to return raw headers with response")
        (":response-interceptor - function called for each redirect")
        (":retry-handler - function to handle HTTP retries on IOException")
        (":save-request? - boolean to return original request with response")
        (":socket-timeout - timeout for establishing socket")
        (":throw-entire-message? - whether to throw the entire response on errors")
        (":throw-exceptions - boolean whether to throw exceptions on 5xx & 4xx")
        (":trust-store - file path to trust store")
        (":trust-store-pass - password for trust store")
        (":trust-store-type - type of trust store")))
      (action . message)))

  (defun helm-httpstatus ()
    (interactive)
    (helm-other-buffer '(helm-httpstatus-source) "*helm httpstatus*"))

  (defun helm-clj-http ()
    (interactive)
    (helm-other-buffer '(helm-clj-http-source) "*helm clj-http flags*")))

  (use-package helm-ls-git
    :ensure t
    :bind ("C-x C-d" . helm-browse-project))

  (use-package helm-ls-hg
    :ensure t)

    (use-package helm-ag
  :ensure t)

(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop))
  :config
  ;; When doing isearch, hand the word over to helm-swoop
  (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t
        ;; If this value is t, split window inside the current window
        helm-swoop-split-with-multiple-windows t
        ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
        helm-swoop-split-direction 'split-window-vertically
        ;; don't auto select the thing at point
        helm-swoop-pre-input-function (lambda () "")
        ;; If nil, you can slightly boost invoke speed in exchange for text
        ;; color. If I want pretty I'll use helm-occur since it keeps colors
        helm-swoop-speed-or-color nil))
(use-package helm-descbinds
  :ensure t
  :bind ("C-h b" . helm-descbinds)
  :init (fset 'describe-bindings 'helm-descbinds))

(use-package helm-flyspell
  :ensure t
  :after helm
  :bind (:map flyspell-mode-map
              ("C-;" . helm-flyspell-correct)))

(use-package projectile
  :ensure t
  :defer 5
  :commands projectile-global-mode
  :diminish projectile-mode
  :init (add-hook 'after-init-hook #'projectile-global-mode)
  :config
  (bind-key "C-c p b" #'projectile-switch-to-buffer #'projectile-command-map)
  (bind-key "C-c p K" #'projectile-kill-buffers #'projectile-command-map)

  ;; global ignores
  (add-to-list 'projectile-globally-ignored-files ".tern-port")
  (add-to-list 'projectile-globally-ignored-files "GTAGS")
  (add-to-list 'projectile-globally-ignored-files "GPATH")
  (add-to-list 'projectile-globally-ignored-files "GRTAGS")
  (add-to-list 'projectile-globally-ignored-files "GSYMS")
  (add-to-list 'projectile-globally-ignored-files ".DS_Store")
  ;; always ignore .class files
  (add-to-list 'projectile-globally-ignored-file-suffixes ".class")
  (use-package helm-projectile
    :ensure t
    :init
    (use-package grep) ;; required for helm-ag to work properly
    (setq projectile-completion-system 'helm)
    ;; no fuzziness for projectile-helm
    (setq helm-projectile-fuzzy-match nil)
    (helm-projectile-on)
    :config
    ;; Add multi-compile to the mix for projects
    (defun helm-projectile-multi-compile-project (dir)
      "A Helm action to invoke multi-compile on a project.
`dir' is the project root."
      (let ((default-directory dir))
        (multi-compile-run)))

    ;; Add new projectile binding for multi-compile
    (helm-projectile-define-key helm-projectile-projects-map
      (kbd "M-m")  #'helm-projectile-multi-compile-project)))

#+END_SRC
* Completion
** Company
#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
(add-to-list 'completion-styles 'initials t)

(use-package company
  :ensure t
  :diminish
  :bind ((:map company-mode-map ("M-/" . company-complete))
         (:map company-active-map ("M-/" . company-other-backend)
                                  ("C-n" . company-select-next)
                                  ("C-p" . company-select-previous)
                                  ("C-d" . company-show-doc-buffer)
                                  ("M-." . company-show-location))
         ("M-C-/" . company-complete))
  :hook (after-init . global-company-mode)
  :config
  (setq-default company-dabbrev-other-buffers 'all
                company-tooltip-align-annotations t)

    (use-package company-quickhelp
      :ensure t
      :hook (after-init . company-quickhelp-mode))

    (use-package company-anaconda
      :ensure t
      :config
      (add-to-list 'company-backends 'company-anaconda)))
;; Suspend page-break-lines-mode while company menu is active
;; (see https://github.com/company-mode/company-mode/issues/416)
(with-eval-after-load 'company
  (with-eval-after-load 'page-break-lines
    (defvar-local sanityinc/page-break-lines-on-p nil)

    (defun sanityinc/page-break-lines-disable (&rest ignore)
      (when (setq sanityinc/page-break-lines-on-p (bound-and-true-p page-break-lines-mode))
        (page-break-lines-mode -1)))

    (defun sanityinc/page-break-lines-maybe-reenable (&rest ignore)
      (when sanityinc/page-break-lines-on-p
        (page-break-lines-mode 1)))

    (add-hook 'company-completion-started-hook 'sanityinc/page-break-lines-disable)
    (add-hook 'company-after-completion-hook 'sanityinc/page-break-lines-maybe-reenable)))

#+END_SRC
** Yasnippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode)
    (global-set-key (kbd "M-/") 'company-yasnippet))
#+END_SRC

* Editing
** Skeleton Code
:PROPERTIES:
:CUSTOM_ID: skeletons
:END:
Skeletons are kind of like yasnippet, but they don't mess with my keybindings
all over the place and take forever to load ಠ_ಠ

#+BEGIN_SRC emacs-lisp
(require 'skeleton)

(define-skeleton deos/org-header
  "Insert a standard header for org-mode files"
  "Title: "
  "#+TITLE: " str \n
  "#+AUTHOR: " (user-full-name) \n
  "#+EMAIL: " user-mail-address \n
  "#+SETUPFILE: ~/deos/setupfiles/emacs.setup

| *Author* | {{{author}}} ({{{email}}})    |
| *Date*   | {{{time(%Y-%m-%d %H:%M:%S)}}} |

,* Introduction
" \n)

(define-skeleton deos/org-wrap-elisp
  "Wrap text with #+BEGIN_SRC / #+END_SRC for the emacs-lisp code"
  nil
  > "#+BEGIN_SRC emacs-lisp :tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

  (define-skeleton deos/org-wrap-source
  "Wrap text with #+BEGIN_SRC / #+END_SRC for a code type"
  "Language: "
  > "#+BEGIN_SRC " str ":tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

  (define-skeleton deos/es-make-index
  "Insert boilerplate to create an index with `es-mode' syntax"
  "Index name: "
  "POST /" str \n
  "{" \n
  > "\"settings\": {" \n
  > "\"index\": {" \n
  > "\"number_of_shards\": 1," \n
  > "\"number_of_replicas\": 0" \n
  > "}" \n ;; index
  > "}," \n ;; settings
  > "\"mappings\": {" \n
  > "\"" (skeleton-read "Type name: ") "\": {" \n
  > "\"properties\": {" \n
  > "\"body\": {" \n
  > "\"type\": \"string\"" \n
  > "}" \n ;; body
  > "}" \n ;; properties
  > "}" \n ;; type
  > "}" \n ;; mappings
  > "}" \n)

  (define-skeleton deos/java-try-catch
  "Wrap code in a Java try/catch"
  nil
  > "try {" \n
  > _
  > "} catch (Exception e) {" \n
  > "throw e;" \n
  > "}" \n)
#+END_SRC

And now let's add a hydra for the skeletons

#+BEGIN_SRC emacs-lisp
(defhydra deos/hydra-skeleton nil
  "Insert Skeleton"
  ("e" deos/org-wrap-elisp "Wrap as elisp" :exit t)
  ("s" deos/org-wrap-source "Wrap as source" :exit t)
  ("i" deos/es-make-index "ES Index" :exit t)
  ("h" deos/org-header "Org Header" :exit t)
  ("t" deos/java-try-catch "Wrap with try/catch" :exit t))
#+END_SRC
** Writegood mode
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :ensure t
  :bind ("C-c w" . writegood-mode)
  :config
  (add-to-list 'writegood-weasel-words "actionable"))
#+END_SRC
** Markup
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode (("\\`README\\.md\\'" . gfm-mode)
         ("github\\.com.*\\.txt\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-enable-wiki-links t
        markdown-italic-underscore t
        markdown-make-gfm-checkboxes-buttons t
        markdown-gfm-additional-languages '("sh"))
  (add-hook 'markdown-mode-hook #'flyspell-mode))
#+END_SRC
** Asciidocs
#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)
#+END_SRC
** Thesaurus
#+BEGIN_SRC emacs-lisp
(use-package synosaurus
  :ensure t
  :init
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode))
#+END_SRC
** Fill me in
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :config
  ;; fix for org -> html export
  (defun fci-mode-override-advice (&rest args))
  (use-package org)
  (advice-add 'org-html-fontify-code :around
              (lambda (fun &rest args)
                (advice-add 'fci-mode :override #'fci-mode-override-advice)
                (let ((result (apply fun args)))
                  (advice-remove 'fci-mode #'fci-mode-override-advice)
                  result)))
  (defvar deos/fci-disabled nil)
  (make-variable-buffer-local 'deos/fci-disabled)
   ;; Add a hook that disables fci if enabled when the window changes and it
  ;; isn't wide enough to display it.
  (defun deos/maybe-disable-fci ()
    (interactive)
    ;; Disable FCI if necessary
    (when (and fci-mode
               (< (window-width) (or fci-rule-column fill-column)))
      (fci-mode -1)
      (setq-local deos/fci-disabled t))
    ;; Enable FCI if necessary
    (when (and deos/fci-disabled
               (eq fci-mode nil)
               (> (window-width) (or fci-rule-column fill-column)))
      (fci-mode 1)
      (setq-local deos/fci-disabled nil)))

  (defun deos/add-fci-disabling-hook ()
    (interactive)
    (add-hook 'window-configuration-change-hook
              #'deos/maybe-disable-fci))
  (add-hook 'prog-mode-hook #'deos/add-fci-disabling-hook))
#+END_SRC
** Whitespace
#+BEGIN_SRC emacs-lisp
;; A subset, only training lines and whitespace
(setq whitespace-style '(spaces tabs newline space-mark tab-mark newline-mark))

(setq whitespace-display-mappings
      ;; all numbers are Unicode codepoint in decimal.
      '(;;(space-mark 32 [183] [46])
        ;; (newline-mark 10 [172 10]) ;; the paragraph sign
        (newline-mark 10 [172 10]) ;; mathematical "not"
        (tab-mark 9 [187 9] [92 9])))

(defun deos/turn-on-whitespace-mode ()
  (interactive)
  (setq-local whitespace-line-column fill-column)
  (whitespace-mode +1)
  (diminish 'whitespace-mode)
  (whitespace-newline-mode 1)
  (diminish 'whitespace-newline-mode))

(add-hook 'prog-mode-hook #'deos/turn-on-whitespace-mode)
#+END_SRC

Turn off whitespace mode when exporting org documents
#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (advice-add 'org-html-fontify-code :around
              (lambda (fun &rest args)
                (whitespace-mode -1)
                (let ((result  (apply fun args)))
                  (whitespace-mode +1)
                  result))))
#+END_SRC

** Highlight indentions
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :init
  (setq highlight-indent-guides-method 'character)
  (add-hook 'prog-mode-hook #'highlight-indent-guides-mode))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :hook (after-init . global-flycheck-mode)
      :init
      (defun my/use-eslint-from-node-modules ()
        (let* ((root (locate-dominating-file
          (or (buffer-file-name) default-directory)
            "node_modules"))
            (eslint (and root
              (expand-file-name "node_modules/eslint/bin/eslint.js"
                root))))
            (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
       :config
       (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
       (add-to-list 'flycheck-checkers 'proselint)
       (setq flycheck-display-errors-function #'flycheck-display-error-messages-unless-error-list)
       (use-package flycheck-color-mode-line
         :ensure t)
         :hook (flycheck-mode . flycheck-color-mode-line-mode))
#+END_SRC
** Proselint
Proselint is a cool flycheck checker for the English language, which helps me
right more gooder
#+BEGIN_SRC emacs-lisp
(flycheck-define-checker proselint
  "A linter for prose."
  :command ("proselint" source-inplace)
  :error-patterns
  ((warning line-start (file-name) ":" line ":" column ": "
            (id (one-or-more (not (any " "))))
            (message (one-or-more not-newline)
                     (zero-or-more "\n" (any " ") (one-or-more not-newline)))
            line-end))
  :modes (text-mode markdown-mode gfm-mode org-mode))
#+END_SRC
** Smartparens
Help keep those parenthesys balanced

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'smartparens-mode))
#+END_SRC

** Delimiters
Show me the parenthesys
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

** Highlight colors
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :diminish rainbow-mode
    :config
    (setq rainbow-x-colors nil)
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
(defun sanityinc/newline-at-end-of-line ()
  "Move to end of line, enter a newline, and reindent."
  (interactive)
  (move-end-of-line 1)
  (newline-and-indent))
(global-set-key (kbd "S-<return>") 'sanityinc/newline-at-end-of-line)
#+END_SRC

** Add them parenth pairs
#+BEGIN_SRC emacs-lisp
(when (fboundp 'electric-pair-mode)
  (add-hook 'after-init-hook 'electric-pair-mode))
(add-hook 'after-init-hook 'electric-indent-mode)
#+END_SRC
** A dash of smartness
#+BEGIN_SRC emacs-lisp
  (use-package smart-dash
    :ensure t
    :config
    (add-hook 'python-mode-hook 'smart-dash-mode))
#+END_SRC
** Code Style
I like the google code style
#+BEGIN_SRC emacs-lisp
(use-package google-c-style
  :ensure t)
#+END_SRC

** Dumb-jump
For jumping dumbly
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
    :ensure t
    :diminish dumb-jump-mode
    :bind (("C-M-g" . dumb-jump-go)
           ("C-M-p" . dumb-jump-back)
           ("C-M-q" . dumb-jump-quick-look)))

#+END_SRC
** Watchwords
#+BEGIN_SRC emacs-lisp :tangle yes
(defun deos/add-watchwords ()
  "Highlight FIXME, TODO, and NOCOMMIT in code TODO"
  (font-lock-add-keywords
   nil '(("\\<\\(TODO\\(?:(.*)\\)?:?\\)\\>"  1 'warning prepend)
         ("\\<\\(FIXME\\(?:(.*)\\)?:?\\)\\>" 1 'error prepend)
         ("\\<\\(NOCOMMIT\\(?:(.*)\\)?:?\\)\\>"  1 'error prepend))))

(add-hook 'prog-mode-hook #'deos/add-watchwords)
#+END_SRC
** Editorconfig support
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+END_SRC
** Highlight escape sequences
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-escape-sequences
  :ensure t
  :hook (after-init . hes-mode))
#+END_SRC
** Highlight symbols
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package symbol-overlay
  :ensure t
  :diminish t
  :config
  :bind (:map symbol-overlay-mode-map
              ("M-i" . symbol-overlay-put)
              ("M-I" . symbol-overlay-remove-all)
              ("M-n" . symbol-overlay-jump-next)
              ("M-p" . symbol-overlay-jump-prev)))
#+END_SRC
** Browse the kill ring
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package browse-kill-ring
  :ensure t
  :bind (("M-Y" . browse-kill-ring)
         (:map browse-kill-ring-mode-map
               ("C-g" . browse-kill-ring-quit)
               ("M-n" . browse-kill-ring-forward)
               ("M-p" . browse-kill-ring-previous)))
  :init
  (setq browse-kill-ring-separator "\f")
  :config
  (add-to-list 'page-break-lines-modes 'browse-kill-ring-mode))
#+END_SRC
** Show matching parenthesis
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'after-init-hook 'show-paren-mode)
#+END_SRC
** Cut/copy the line if no region is selected
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package whole-line-or-region
  :ensure t
  :diminish t
  :hook (after-init . whole-line-or-region-global-mode))
#+END_SRC
** Miscellaneous
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'goto-address-prog-mode)
(setq goto-address-mail-face 'link)

(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
(add-hook 'after-save-hook 'sanityinc/set-mode-for-new-scripts)

(defun sanityinc/set-mode-for-new-scripts ()
  "Invoke `normal-mode' if this file is a script and in `fundamental-mode'."
  (and
   (eq major-mode 'fundamental-mode)
   (>= (buffer-size) 2)
   (save-restriction
     (widen)
     (string= "#!" (buffer-substring (point-min) (+ 2 (point-min)))))
   (normal-mode)))

(use-package info-colors
  :ensure t
  :hook (Info-selection . info-colors-fontify-node))

(use-package regex-tool
  :ensure t
  :config
  (setq-default regex-tool-backend 'perl))

(with-eval-after-load 're-builder
  ;; Support a slightly more idiomatic quit binding in re-builder
  (define-key reb-mode-map (kbd "C-c C-k") 'reb-quit))
#+END_SRC
* File Browsing
** Directory Editing and Navigation
#+BEGIN_SRC emacs-lisp
(defun deos/dired-mode-hook ()
      (setq-local truncate-lines t))

    (use-package dired
      :bind ("C-x C-j" . dired-jump)
      :config
      (use-package dired-x
        :init (setq-default dired-omit-files-p t)
        :config
        (add-to-list 'dired-omit-extensions ".DS_Store"))
      (customize-set-variable 'diredp-hide-details-initially-flag nil)
      (use-package dired+
        :disabled t
        :ensure t)
      (use-package dired-aux
        :init
        (use-package dired-async
          :ensure async))
      (put 'dired-find-alternate-file 'disabled nil)
      (setq ls-lisp-dirs-first t
            dired-recursive-copies 'always
            dired-recursive-deletes 'always
            dired-dwim-target t
            ;; -F marks links with @
            dired-ls-F-marks-symlinks t
            delete-by-moving-to-trash t
            ;; Don't auto refresh dired
            global-auto-revert-non-file-buffers nil
            wdired-allow-to-change-permissions t)
      (define-key dired-mode-map (kbd "C-M-u") #'dired-up-directory)
      (define-key dired-mode-map (kbd "M-o") #'my/dired-open)
      (define-key dired-mode-map (kbd "C-x C-q") #'wdired-change-to-wdired-mode)
      (bind-key "l" #'dired-up-directory dired-mode-map)
      (bind-key "M-!" #'async-shell-command dired-mode-map)
      (add-hook 'dired-mode-hook #'deos/dired-mode-hook))
#+END_SRC

** Quick-preview provides a nice preview of the thing under the cursor
#+BEGIN_SRC emacs-lisp
(use-package quick-preview
  :ensure t
  :init
  (global-set-key (kbd "C-c q") 'quick-preview-at-point)
  (define-key dired-mode-map (kbd "Q") 'quick-preview-at-point))
#+END_SRC

** Let's use async for everything in dired
#+BEGIN_SRC emacs-lisp
(use-package async :ensure t)
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+END_SRC

** Filter dired results with a filter
#+BEGIN_SRC emacs-lisp
    (use-package dired-narrow
      :ensure t
      :bind (:map dired-mode-map ("/" . dired-narrow)))
#+END_SRC

** Icons in a buffer
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :ensure t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC

** Neotree
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :config
  (global-set-key (kbd "C-c n") 'neotree-toggle)
  (setq neo-theme 'arrow)
  (setq neo-window-fixed-size nil)
  (setq neo-smart-open t)
  (setq neo-window-width 40)
  (setq neo-default-system-application "open"))
#+END_SRC
* Git
** Magit
The be all, end all mode for all things git
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)
         ("C-x M-g" . magit-dispatch))
  :config
  (setq-default magit-diff-refine-hunk t)
  (defun sanityinc/magit-or-vc-log-file (&optional prompt)
    (interactive "P")
    (if (and (buffer-file-name)
             (eq 'Git (vc-backend (buffer-file-name))))
        (if prompt
            (magit-log-buffer-file-popup)
          (magit-log-buffer-file t))
      (vc-print-log)))

  (with-eval-after-load 'vc
    (define-key vc-prefix-map (kbd "l") 'sanityinc/magit-or-vc-log-file))

  (with-eval-after-load 'magit
    (define-key magit-status-mode-map (kbd "C-M-<up>") 'magit-section-up))

  (use-package magit-todos
    :ensure t)

  (use-package fullframe
    :ensure t
    :config
    (with-eval-after-load 'magit
      (fullframe magit-status magit-mode-quit-window)))

  (when *is-a-mac*
    (with-eval-after-load 'magit
      (add-hook 'magit-mode-hook (lambda () (local-unset-key [(meta h)])))))

  (with-eval-after-load 'vc
    (define-key vc-prefix-map (kbd "f") 'vc-git-grep))

  (with-eval-after-load 'compile
    (dolist (defn (list '(git-svn-updated "^\t[A-Z]\t\\(.*\\)$" 1 nil nil 0 1)
                        '(git-svn-needs-update "^\\(.*\\): needs update$" 1 nil nil 2 1)))
      (add-to-list 'compilation-error-regexp-alist-alist defn)
      (add-to-list 'compilation-error-regexp-alist (car defn))))

  (defvar git-svn--avialable-commands nil "Cached list of git svn subcommands")
  (defun git-svn--available-commands ()
    (or git-svn--available-commands
        (setq git-svn--available-commands
              (sanityinc/string-all-matches
               "^  \\([a-z\\-]+\\) +"
               (shell-command-to-string "git svn help") 1))))
  (autoload 'vc-git-root "vc-git")

  (defun git-svn (dir command)
    "Run a git svn subcommand in DIR."
    (interactive (list (read-directory-name "Directory: ")
                       (completing-read "git-svn command: " (git-svn--available-commands) nil t nil nil (git-svn--available-commands))))
    (let* ((default-directory (vc-git-root dir))
           (compilation-buffer-name-function (lambda (major-mode-name) "*git-svn*")))
      (compile (concat "git svn " command))))
  )
#+END_SRC
** Various Git helpers
#+BEGIN_SRC emacs-lisp
(use-package git-blamed
  :ensure t)

(use-package gitignore-mode
  :ensure t)

(use-package gitconfig-mode
  :ensure t)

(use-package git-timemachine
  :ensure t
  :bind (("C-x v t" . git-timemachine-toggle))
  )
(use-package git-commit
  :ensure t
  :hook (git-commit-mode . goto-address-mode))
#+END_SRC
** Github
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yagist
  :ensure t)
(use-package bug-reference-github
  :ensure t
  :hook (prog-mode . bug-reference-prog-mode))

(use-package github-clone
  :ensure t)

(use-package forge
  :ensure t)

(use-package github-review
  :ensure t)
#+END_SRC
* VC
#+BEGIN_SRC emacs-lisp :tangle yes

(use-package diff-hl
  :ensure t
  :hook ((magit-post-refresh . diff-hl-magit-post-refresh)
         (after-init . global-diff-hl-mode))
  :config
  (with-eval-after-load 'diff-hl
    (define-key diff-hl-mode-map
      (kbd "<left-fringe> <mouse-1>")
      'diff-hl-diff-goto-hunk)))

(use-package browse-at-remote
  :ensure t)
#+END_SRC
* Programming Modes
** Python
#+BEGIN_SRC emacs-lisp
(use-package python
  :config
  (setq-default python-indent-offset 2)
  (define-key python-mode-map (kbd "<backtab>") 'python-back-indent))

(when (executable-find "jupyter")
  (use-package ob-ipython
    :ensure t
    :config
    (use-package company
      :config
      (add-to-list 'company-backends 'company-ob-ipython))
    (add-to-list 'org-latex-minted-langs '(ipython "python"))))

(use-package virtualenvwrapper
  :ensure t
  :defer t
  :init
  (progn
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location (or (getenv "WORKON_HOME")
                            "~/.virtualenvs"))))
;; this requires some setup pip install jedi flake8 autopep8 yapf
;; (use-package elpy
;;   :ensure t
;;   :defer t
;;   :init
;;   (elpy-enable)
;;   :config
;;   (setq elpy-test-django-with-manage t))

(use-package anaconda-mode
  :ensure t
  :config
  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC
*** Kivy
#+BEGIN_SRC emacs-lisp
(use-package kivy-mode
  :ensure t
  :mode ("\\.kv\\'" . kivy-mode))
#+END_SRC
** C
#+BEGIN_SRC emacs-lisp
    (use-package irony
      :ensure t
      :hook (c-mode . irony-mode))
  (use-package company-irony
    :ensure t
    :config
    (add-to-list 'company-backends 'company-irony))
(use-package flycheck-irony
  :ensure t
  :hook (flycheck-mode . flycheck-irony-setup))
#+END_SRC
** C Sharp
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :ensure t)

(use-package omnisharp
  :ensure t
  :hook ((csharp-mode . omnisharp-mode)
         ;; TODO: 'before-save runs globally - make this buffer local?
         (before-save . omnisharp-code-format-entire-file))
  :config
  (add-to-list 'company-backends 'company-omnisharp))
#+END_SRC
** Groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :ensure t
  :config
  (setq groovy-indent-offset 2))
#+END_SRC
** Java
Prior art from https://github.com/dakrone/eos/blob/master/eos-java.org
*** Which major mode
let's try all of the major ones
#+BEGIN_SRC emacs-lisp
(setq deos/use-meghanada 1)
(setq deos/use-eclim nil)
(setq deos/use-lsp nil)
#+END_SRC
*** Setup java mode
#+BEGIN_SRC emacs-lisp
(use-package shut-up :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun deos/setup-java ()
  (interactive)
  (define-key java-mode-map (kbd "M-,") 'pop-tag-mark)
  (define-key java-mode-map (kbd "C-c M-i") 'java-imports-add-import-dwim)
  (define-key java-mode-map (kbd "C-c C-b") 'bool-flip-do-flip)
  (c-set-style "google-c-style" t)
  (subword-mode 1)
  (shut-up (toggle-truncate-lines 1))
  (setq-local fci-rule-column 99)
  (setq-local fill-column 100)
  (when (fboundp 'deos/turn-on-whitespace-mode)
    (whitespace-mode -1)
    (deos/turn-on-whitespace-mode))
  ;; hide the initial comment in the file (usually a license) if hs-minor-mode
  ;; is enabled
  (when (boundp' hs-minor-mode)
    (hs-hide-initial-comment-block)))
(add-hook 'java-mode-hook #'deos/setup-java)
(require 'compile)
(add-to-list 'compilation-error-regexp-alist
             '("^:[^/.\n]+\\(/.+\\):\\([[:digit:]]+\\):" 1 2))
#+END_SRC

*** Backspace deletes whole line
#+BEGIN_SRC emacs-lisp
(use-package smart-backspace
  :ensure t
  :bind ("<C-M-backspace>" . smart-backspace))
#+END_SRC

*** Java imports
#+BEGIN_SRC emacs-lisp
(use-package java-imports
  :ensure t
  :config
  (setq java-imports-find-block-function 'java-imports-find-place-sorted-block)
  (add-hook 'java-mode-hook 'java-imports-scan-file))
#+END_SRC

*** Eclim
#+BEGIN_SRC emacs-lisp
(use-package eclim
  :ensure t
  :disabled t
  :init
  ;; only show errors
  (setq-default eclim--problems-filter "e")
  (when deos/use-eclim
    (add-hook 'java-mode-hook #'eclim-mode)
    (use-package company-emacs-eclim
      :ensure t
      :init (company-emacs-eclim-setup))))
#+END_SRC

*** SDKman
First you have to install sdkman http://sdkman.io
#+BEGIN_SRC emacs-lisp
(add-to-list 'tramp-remote-path "/home/dnewman/.sdkman/candiates/gradle/current/bin")
(add-to-list 'tramp-remote-path "/home/dnewman/.sdkman/candiates/groovy/current/bin")
#+END_SRC

*** GTAGS
#+BEGIN_SRC emacs-lisp :tangle yes
(defun deos/setup-helm-gtags ()
  (interactive)
  ;; this variables must be set before load helm-gtags
  ;; you can change to any prefix key of your choice
  (setq helm-gtags-prefix-key "\C-cg")
  (setq helm-gtags-ignore-case t
        helm-gtags-auto-update t
        helm-gtags-use-input-at-cursor t
        helm-gtags-pulse-at-cursor t
        helm-gtags-suggested-key-mapping t)
  (use-package helm-gtags
    :ensure t
    ;; not needed because of smart-jump
    :init (helm-gtags-mode t)
    :diminish ""
    :bind (:map helm-gtags-mode-map
                ("M-S" . helm-gtags-select)
                ("M-." . helm-gtags-dwim)
                ("M-," . helm-gtags-pop-stack)
                ("C-c <" . helm-gtags-previous-history)
                ("C-c >" . helm-gtags-next-history)))
  (helm-gtags-mode t))

(defun deos/setup-ggtags ()
  (interactive)
  (ggtags-mode 1)
  ;; turn on eldoc with ggtags
  (setq-local eldoc-documentation-function #'ggtags-eldoc-function)
  ;; add ggtags to the hippie completion
  (setq-local hippie-expand-try-functions-list
              (cons 'ggtags-try-complete-tag
                    hippie-expand-try-functions-list))
  ;; use helm for completion
  (setq ggtags-completing-read-function nil))

(use-package ggtags
  :ensure t
  :defer t
  :init
  (progn
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
                  (deos/setup-semantic-mode)
                  ;; helm-gtags
                  (deos/setup-helm-gtags)
                  ;; regular gtags
                  ;;(my/setup-ggtags)
                  )))))
#+END_SRC

*** JAVA debugging
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package realgud
  :ensure t)
#+END_SRC

*** Meghanada
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package meghanada
  :ensure t
  :init
  ;; Don't auto-start
  (setq meghanada-auto-start nil)
  (when deos/use-meghanada
    (add-hook 'java-mode-hook #'meghanada-mode)
    (add-hook 'java-mode-hook 'flycheck-mode)
    (bind-key "C-c M-." 'meghanada-jump-declaration java-mode-map)))
#+END_SRC

*** LSP-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(when (file-exists-p "~/.emacs.d/eclipse.jdt.ls")
  (use-package lsp-mode
    :ensure t
    :init
    (when deos/use-lsp
      (use-package lsp-java
        :ensure t
        :init
        (require 'lsp-java)
        (require 'lsp-mode)
        (add-hook 'java-mode-hook #'lsp-java-enable)))
    :config
    (use-package lsp-ui
      :ensure t)))
#+END_SRC

* Extras
** Stack Overflow
SX is a stack overflow client that you can use in Emacs
#+BEGIN_SRC emacs-lisp
(use-package sx
  :ensure t
  :config
  (bind-keys :prefix "C-c s"
             :prefix-map my-sx-map
             :prefix-docstring "Global keymap for SX."
             ("q" . sx-tab-all-questions)
             ("i" . sx-inbox)
             ("o" . sx-open-link)
             ("u" . sx-tab-unanswered-my-tags)
             ("a" . sx-ask)
             ("s" . sx-search)))
#+END_SRC
** Web Browsing
Browse any url under the cursor
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x m") 'browse-url-at-point)
#+END_SRC
*** EWW
I rather like eww for browsing inside Emacs but some sites don't work well so I open them in an
external browser
#+BEGIN_SRC emacs-lisp
(use-package eww
  :defer t
  :init
  (setq browse-url-browser-function
        '((".*google.*maps.*" . browse-url-generic)
          ;; Github goes to firefox, but not gist
          ("corp.digitalreasoning.com" . browse-url-generic)
          ("http.*\/\/github.com" . browse-url-generic)
          ("groups.google.com" . browse-url-generic)
          ("docs.google.com" . browse-url-generic)
          ("melpa.org" . browse-url-generic)
          ("build.*\.elastic.co" . browse-url-generic)
          (".*-ci\.elastic.co" . browse-url-generic)
          ("internal-ci\.elastic\.co" . browse-url-generic)
          ("zendesk\.com" . browse-url-generic)
          ("salesforce\.com" . browse-url-generic)
          ("stackoverflow\.com" . browse-url-generic)
          ("apache\.org\/jira" . browse-url-generic)
          ("thepoachedegg\.net" . browse-url-generic)
          ("zoom.us" . browse-url-generic)
          ("t.co" . browse-url-generic)
          ("twitter.com" . browse-url-generic)
          ("\/\/a.co" . browse-url-generic)
          ("youtube.com" . browse-url-generic)
          ("amazon.com" . browse-url-generic)
          ("." . eww-browse-url)))
  (setq shr-external-browser 'browse-url-generic)
  (if *is-a-mac*
        (setq browse-url-generic-program "open")
    (setq browse-url-generic-program (executable-find "firefox")))
  (add-hook 'eww-mode-hook #'toggle-word-wrap)
  (add-hook 'eww-mode-hook #'visual-line-mode)
  :config
  (use-package s :ensure t)
  (define-key eww-mode-map "o" 'eww)
  (define-key eww-mode-map "O" 'eww-browse-with-external-browser)
  (define-key eww-mode-map "j" 'next-line)
  (define-key eww-mode-map "k" 'previous-line)

  (use-package eww-lnum
    :ensure t
    :config
    (bind-key "f" #'eww-lnum-follow eww-mode-map)
    (bind-key "U" #'eww-lnum-universal eww-mode-map)))
#+END_SRC

Vimperator for EWW
#+BEGIN_SRC emacs-lisp
(use-package link-hint
  :ensure t
  :bind ("C-c f" . link-hint-open-link))
#+END_SRC
** Chat
Here are some utilities to facilitate text communications between carbon based lifeforms. Nanu-Nanu
#+BEGIN_SRC emacs-lisp :tangle no
(use-package jabber
  :ensure t
  :init
  (setq jabber-history-enabled t)
  :config
  (add-to-list 'jabber-account-list '("dwnewman78@gmail.com"
  (:network-server . "talk.google.com")
  (:connection-type . ssl)))
  (add-hook 'jabber-post-connect-hooks 'jabber-autoaway-start)
  (setq
  jabber-history-enabled t
  jabber-use-global-history nil
  jabber-backlog-number 40
  jabber-backlog-days 30))
#+END_SRC
* Hooks
Run some things after everything loads
#+BEGIN_SRC emacs-lisp :tangle yes
   ;; Hooks
   (setq initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n")
  (require-package 'sudo-edit)
  (require-package 'gnuplot)
  (require-package 'lua-mode)
  (require-package 'htmlize)
  (when *is-a-mac*
    (require-package 'osx-location))
  (unless (eq system-type 'windows-nt)
    (maybe-require-package 'daemons))
  (maybe-require-package 'dotenv-mode)
  (maybe-require-package 'shfmt)

  (when (maybe-require-package 'uptimes)
    (setq-default uptimes-keep-count 200)
    (add-hook 'after-init-hook (lambda () (require 'uptimes))))

  (when (fboundp 'global-eldoc-mode)
    (add-hook 'after-init-hook 'global-eldoc-mode))

;;----------------------------------------------------------------------------
;; Allow access from emacsclient
;;----------------------------------------------------------------------------
(add-hook 'after-init-hook
          (lambda ()
            (require 'server)
            (unless (server-running-p)
              (server-start))))

;;----------------------------------------------------------------------------
;; Variables configured via the interactive 'customize' interface
;;----------------------------------------------------------------------------
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC
