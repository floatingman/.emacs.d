#+TITLE: Daniel Newman's Literate Emacs Configuration
#+AUTHOR: Daniel Newman
#+EMAIL: dwnewman78@gmail.com
#+SETUPFILE: ~/.emacs.d/setupfiles/emacs.setup
#+STARTUP: overview

* The Beginning
:PROPERTIES:
:CUSTOM_ID: init
:END:
I've seen some cool Emacs configs written out using [[http://orgmode.org/worg/org-contrib/babel/][Org-mode Babel]] to
enclose code within paragraphs of text. I think this will be a cool
way to organize my config and also provide some context around why I
did things the way I did

I am going to attempt to arrange my code in modules and provide a
makefile to make installing convenient

#+BEGIN_SRC emacs-lisp
    ;; turn on emacs debugging when starting, turn it off later
    (setq debug-on-error t)
    (setq debug-on-quit t)

    (require 'cl)

    (require 'package)
    (package-initialize)

    ;; orgmode.org unfortunately does not support https
    (add-to-list 'package-archives
                 '("org" . "http://orgmode.org/elpa/") t)
    (add-to-list 'package-archives
                 '("gnu" . "https://elpa.gnu.org/packages/") t)
    (add-to-list 'package-archives
                 '("melpa-stable" . "https://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives
                 '("melpa" . "https://melpa.org/packages/") t)

    (setq custom-file "~/personal/custom.el")
    (when (file-exists-p custom-file)
      (load custom-file))

    (defvar deos/did-refresh-packages nil
      "Flag for whether packages have been refreshed yet")

    (defun install-pkgs (list)
      (dolist (pkg list)
        (progn
          (if (not (package-installed-p pkg))
              (progn
                (if (not deos/did-refresh-packages)
                    (progn (package-refresh-contents)
                           (setq deos/did-refresh-packages t)))
                (package-install pkg))))))

  ;;Pin some of the packages that go wonky if I use the bleeding edge.

  (when (boundp 'package-pinned-packages)
    (setq package-pinned-packages
          '((org-plus-contrib                  . "org")
            (cider                             . "melpa-stable")
            (ac-cider                          . "melpa-stable")
            (clojure-mode                      . "melpa-stable")
            (clojure-mode-extra-font-locking   . "melpa-stable")
            (company-cider                     . "melpa-stable"))))

    (install-pkgs '(use-package))
    ;; Load use-package, used for loading packages everywhere else
    (require 'use-package nil t)
    ;; Set to t to debug package loading or nil to disable
    (setq use-package-verbose nil)

    (add-to-list 'load-path "~/.emacs.d/el-get/el-get")

    (unless (require 'el-get nil 'noerror)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el")
        (goto-char (point-max))
        (eval-print-last-sexp)))

    (add-to-list 'el-get-recipe-path "~/.emacs.d/el-get-user/recipes")
    ;;(el-get 'sync)

    ;; Mitigate Bug#28350 (security) in Emacs 25.2 and earlier.
    (eval-after-load "enriched"
                     '(defun enriched-decode-display-prop (start end &optional param)
                        (list start end)))

    (defvar after-deos-hook nil
      "Hooks to run after all of the DEOS has been loaded")

    (defvar emacs-start-time (current-time)
      "Time Emacs was started.")

    ;; Installed by `make install`
    (add-to-list 'load-path "~/.emacs.d/deos/")
    (add-to-list 'load-path "~/.emacs.d/site-lisp/")
    (defmacro try-load (module)
      "Try to load the given module, logging an error if unable to load"
      `(condition-case ex
           (require ,module)
         ('error
          (message "DEOS: Unable to load [%s] module: %s" ,module ex))))

 ;; Hooks
    (add-hook 'after-deos-hook
              (lambda ()
                (message "The Daniel Newman Emacs System has been loaded")))

    (defun deos/time-since-start ()
      (float-time (time-subtract (current-time)
                                 emacs-start-time)))

    (add-hook 'after-deos-hook
              `(lambda ()
                 (let ((elapsed (deos/time-since-start)))
                   (message "Loading %s...done (%.3fs)"
                            ,load-file-name elapsed))) t)
    (add-hook 'after-init-hook
              `(lambda ()
                 (let ((elapsed (deos/time-since-start)))
                   (message "Loading %s...done (%.3fs) [after-init]"
                            ,load-file-name elapsed))) t)
    (run-hooks 'after-deos-hook)

    (setq initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n")

    ;; turn off debugging after emacs starts
    (setq debug-on-error nil)
    (setq debug-on-quit nil)
#+END_SRC

* The Core
:PROPERTIES:
:CUSTOM_ID: core-config
:END:
This is the place where a lot of default config is set. Most variables
and functions should be in this file

It's about to get personal
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Newman"
      user-mail-address "dwnewman78@gmail.com")
#+END_SRC

UTF-8 all the way!
#+begin_src emacs-lisp
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Raise the maximum number of logs in the =*Messages*= buffer:

#+BEGIN_SRC emacs-lisp
(setq message-log-max 16384)
#+END_SRC

We don't really need to garbage collect as frequently as Emacs would like to by
default, so set the threshold up higher:

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1024 1024)) ;; 50 mb
;; Allow font-lock-mode to do background parsing
(setq jit-lock-defer-time nil
      ;; jit-lock-stealth-nice 0.1
      jit-lock-stealth-time 1
      jit-lock-stealth-verbose nil)
#+END_SRC

Wait a bit longer than the default (0.5 seconds) before assuming Emacs is idle

#+BEGIN_SRC emacs-lisp
(setq idle-update-delay 2)
#+END_SRC

Setup some variables for use in other config files

#+begin_src emacs-lisp
(defconst *spell-check-support-enabled* t) ;; Enable with t if you prefer
(defconst *is-a-mac* (eq system-type 'darwin))
(defconst *is-windows* (eq system-type 'windows-nt))
(defconst *is-linux* (eq system-type 'gnu/linux))
(defconst *is-gui* (not (eq window-system nil)))
(defvar running-alternate-emacs nil)
#+end_src

Make gnutls a bit safer, the default is an absurdly low 256

#+BEGIN_SRC emacs-lisp
(setq gnutls-min-prime-bits 4096)
#+END_SRC

When I select a region and start typing, just delete the region automatically.
This ends up working great with =expand-region=

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

Don't warn me about large files unless they're at least 25mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 25 1024 1024))
#+END_SRC

If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC

Don't indicate empty lines or the end of a buffer with visual
marks (the lines are cleaned up automatically anyway)

#+BEGIN_SRC emacs-lisp
(setq-default indicate-empty-lines nil)
(setq-default indicate-buffer-boundaries nil)
#+END_SRC

Turn off all kinds of modes, I don't need the menu bar, or the tool bar:

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC

Beep bop boop I am a robot no more. Don't show the startup message, I
know Emacs is starting.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda ()))
(setq inhibit-startup-screen t)
#+END_SRC

Why would you not want to know lines/columns in your mode-line?

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

This allows a GUI emacs to inherit =$PATH= and other things from the shell when
run. I use it for the path on OSX and JAVA_HOME everywhere else.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :defer t
    :init
    (progn
      (setq exec-path-from-shell-variables '("JAVA_HOME"
                                             "PATH"
                                             "GRATER_PASSWORD"
                                             "NVM_PATH"
                                             "WORKON_HOME"
                                             "RUST_SRC_PATH"
                                             "GPG_AGENT_INFO"
                                             "MEGHANADA_GRADLE_VERSION"
                                             "MANPATH"))
      (exec-path-from-shell-initialize)))
#+END_SRC

Ignore case when using completion for file names:

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Nobody likes to have to type "yes" to questions, so change it to
just hitting the =y= key to confirm:

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Confirm before killing emacs, but only on graphical sessions

#+BEGIN_SRC emacs-lisp
(when (window-system)
  (setq confirm-kill-emacs 'yes-or-no-p))
#+END_SRC

It's much easier to move around lines based on how they are
displayed, rather than the actual line. This helps a ton with long
log file lines that may be wrapped:

#+BEGIN_SRC emacs-lisp
(setq line-move-visual t)
#+END_SRC

Hide the mouse while typing:

#+BEGIN_SRC emacs-lisp
(setq make-pointer-invisible t)
#+END_SRC

Set up the fill-column to 80 characters and set tab width to 2

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

Fix some weird color escape sequences

#+BEGIN_SRC emacs-lisp
(setq system-uses-terminfo nil)
#+END_SRC

Resolve symlinks:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename t)
#+END_SRC

Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Uniquify buffers, using angle brackets, so you get =foo= and
=foo<2>=:

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

Search (and search/replace) using regex by default, since that's
usually what I want to do:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "M-%") 'query-replace-regexp)
;; This is usually bound to `C-M-l', but that locks the screen on linux, so bind
;; it to something I can use
(global-set-key (kbd "M-L") 'reposition-window)
#+END_SRC

Just kill this buffer, don't prompt me. I'll use helm if I want to kill a
different buffer

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") #'kill-this-buffer)
#+END_SRC

Single space still ends a sentence:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Split windows a bit better (don't split horizontally, I have a
widescreen :P)

#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 180)
#+END_SRC

Make sure auto automatically rescan for imenu changes:

#+BEGIN_SRC emacs-lisp
(set-default 'imenu-auto-rescan t)
#+END_SRC

Seed the random number generator:

#+BEGIN_SRC emacs-lisp
(random t)
#+END_SRC

Switch to unified diffs by default:

#+BEGIN_SRC emacs-lisp
(setq diff-switches "-u")
#+END_SRC

Turn on auto-fill mode in text buffers:

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)

(use-package diminish
  :ensure t
  :init (diminish 'auto-fill-function ""))
#+END_SRC

Set the internal calculator not to go to scientific form quite so quickly:

#+BEGIN_SRC emacs-lisp
(setq calc-display-sci-low -5)
#+END_SRC

Bury the =*scratch*= buffer, never kill it:

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

These are some settings for version control stuff.

Start a server if not running, but a only for gui-only:

#+BEGIN_SRC emacs-lisp
(set-default 'server-socket-dir "~/.emacs.d/server")
(if (functionp 'window-system)
    (when (and (window-system)
           (>= emacs-major-version 24))
(server-start)))

;; Lame, server has bad autoloads :(
;; (require 'server nil t)
;; (use-package server
;;   :if window-system
;;   :init
;;   (when (not (server-running-p server-name))
;;     (server-start)))
#+END_SRC

Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp
(when (boundp 'global-prettify-symbols-mode)
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("lambda" . ?λ) prettify-symbols-alist)))
  (add-hook 'clojure-mode-hook
            (lambda ()
              (push '("fn" . ?ƒ) prettify-symbols-alist)))
  (global-prettify-symbols-mode +1))
#+END_SRC

Emacs (foolishly) defaults to adding the =--insecure= flag. It also supports the
(incredibly broken) SSL version 3. What are you thinking Emacs!?!

Here I set it back to a *sane* value:

#+BEGIN_SRC emacs-lisp
(setq tls-program
      ;; Defaults:
      ;; '("gnutls-cli --insecure -p %p %h"
      ;;   "gnutls-cli --insecure -p %p %h --protocols ssl3"
      ;;   "openssl s_client -connect %h:%p -no_ssl2 -ign_eof")
      '(;;"gnutls-cli -p %p %h"
        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof"))
#+END_SRC

Desktop Save Mode[fn:18:
http://www.gnu.org/software/emacs/manual/html_node/elisp/Desktop-Save-Mode.html]
is the session management system for Emacs; it holds state of open buffers and
session variables across instantiation of Emacs, which is super useful in mobile
setups like laptops which reboot a lot. To make startup sane, I'm choosing to
eagerly restore the 10 most recently used buffers on startup, and then in Idle
the system will restore the remaining buffers.

I've recently disabled this, because I enjoy starting clean when I restart
Emacs, so it's nice to have the option if desired..

Desktop+ will automatically save the desktop when Emacs exits

#+BEGIN_src emacs-lisp
  ;; (desktop-save-mode 1)
  ;; load all values eagerly
  (setq desktop-restore-eager 10)
  ;; Don't save TRAMP, ftp, or "KILL" buffers
  (setq desktop-files-not-to-save "\\(^/[^/:]*:\\|(ftp)$\\|KILL\\)")
  ;; Don't restore different frames, only restore the one frame
  (setq desktop-restore-frames nil)

  (use-package desktop+
    :ensure t
    :disabled t
    :init
    (defun deos/load-default-desktop ()
      "Load the default EOS desktop, assuming one has been saved
  with the name `default'."
      (interactive)
      (desktop+-load "default")
      (message "Loaded \"default\" desktop."))

    (add-hook 'after-init-hook #'deos/load-default-desktop))
#+END_SRC

By default, my machine drops me in to a =*scratch*= buffer. Originally designed
to be an lisp playground that you could dive right in to on start up, it's sort
of eclipsed that for me in to a general purpose buffer, where I will put things
like elisp I am prototyping or playtesting, small snippets of code that I want
to use in dayjob, etc. But when you kill emacs, or it dies, that buffer
disappears. This code will save the Scratch buffer every minute and restores it
on Emacs startup.

#+BEGIN_src emacs-lisp
(defun save-persistent-scratch ()
  "Write the contents of *scratch* to the file name
`persistent-scratch-file-name'."
  (with-current-buffer (get-buffer-create "*scratch*")
    (write-region (point-min) (point-max) "~/.emacs.d/persistent-scratch")))

(defun load-persistent-scratch ()
  "Load the contents of `persistent-scratch-file-name' into the
  scratch buffer, clearing its contents first."
  (if (file-exists-p "~/.emacs-persistent-scratch")
      (with-current-buffer (get-buffer "*scratch*")
        (delete-region (point-min) (point-max))
        (insert-file-contents "~/.emacs.d/persistent-scratch"))))

(add-hook 'after-init-hook 'load-persistent-scratch)
(add-hook 'kill-emacs-hook 'save-persistent-scratch)
#+END_SRC

I restart emacs a lot, and it is nice to have the history of things like =M-x=
saved across those sessions. =savehist= mode gives us that.

#+begin_src emacs-lisp
(require 'savehist)
(setq savehist-file (concat user-emacs-directory "savehist"))
(savehist-mode 1)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
(setq-default save-place t)
#+end_src

Toggle line wrapping with =C-x C-l=

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-l") #'toggle-truncate-lines)
#+end_src

Set up keeping track of recent files, up to 2000 of them.

If emacs has been idle for 10 minutes, clean up the recent files. Also save the
list of recent files every 5 minutes.

#+BEGIN_SRC emacs-lisp
(setq recentf-max-saved-items 300
      recentf-exclude '("/auto-install/" ".recentf" "/repos/" "/elpa/"
                        "\\.mime-example" "\\.ido.last" "COMMIT_EDITMSG"
                        ".gz" "~$" "/tmp/" "/ssh:" "/sudo:" "/scp:")
      recentf-auto-cleanup 600)

;; Enable when running interactively
(when (not noninteractive) (recentf-mode 1))

(defun recentf-save-list ()
  "Save the recent list.
Load the list from the file specified by `recentf-save-file',
merge the changes of your current session, and save it back to
the file."
  (interactive)
  (let ((instance-list (cl-copy-list recentf-list)))
    (recentf-load-list)
    (recentf-merge-with-default-list instance-list)
    (recentf-write-list-to-file)))

(defun recentf-merge-with-default-list (other-list)
  "Add all items from `other-list' to `recentf-list'."
  (dolist (oitem other-list)
    ;; add-to-list already checks for equal'ity
    (add-to-list 'recentf-list oitem)))

(defun recentf-write-list-to-file ()
  "Write the recent files list to file.
Uses `recentf-list' as the list and `recentf-save-file' as the
file to write to."
  (condition-case error
      (with-temp-buffer
        (erase-buffer)
        (set-buffer-file-coding-system recentf-save-file-coding-system)
        (insert (format recentf-save-file-header (current-time-string)))
        (recentf-dump-variable 'recentf-list recentf-max-saved-items)
        (recentf-dump-variable 'recentf-filter-changer-current)
        (insert "\n \n;;; Local Variables:\n"
                (format ";;; coding: %s\n" recentf-save-file-coding-system)
                ";;; End:\n")
        (write-file (expand-file-name recentf-save-file))
        (when recentf-save-file-modes
          (set-file-modes recentf-save-file recentf-save-file-modes))
        nil)
    (error
     (warn "recentf mode: %s" (error-message-string error)))))
#+END_SRC

Change the clipboard settings to better integrate into Linux:

#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

All restoring window placement with Emacs' built-in =winner-mode=

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'winner-mode)
#+END_SRC

Save whatever's in the current (system) clipboard before replacing it with the
Emacs' text.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

Settings for what to do with temporary files. I like to put them all in
=~/.emacs_backups= if it exists, which puts them in a single place instead of
littering everywhere.

#+BEGIN_SRC emacs-lisp
;; delete-auto-save-files
(setq delete-auto-save-files t)
;; Create the directory for backups if it doesn't exist
(when (not (file-exists-p "~/.emacs_backups"))
  (make-directory "~/.emacs_backups"))

(setq-default backup-directory-alist
              '((".*" . "~/.emacs_backups")))
(setq auto-save-file-name-transforms
      '((".*" "~/.emacs_backups/" t)))

;; delete old backups silently
(setq delete-old-versions t)
#+END_SRC

Before saving a buffer, cleans up whitespace only for the lines that I have
touched. I used to have:

: (add-hook 'before-save-hook #'delete-trailing-whitespace)

But this ends up deleting a looot of whitespace in my work codebase ಠ_ಠ, so now
I use [[https://github.com/lewang/ws-butler/][ws-butler]].

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :ensure t
  :diminish ws-butler-mode
  :init
  (add-hook 'prog-mode-hook #'ws-butler-mode)
  (add-hook 'org-mode-hook #'ws-butler-mode)
  (add-hook 'text-mode-hook #'ws-butler-mode))
#+END_SRC

On the other hand, auto-indenting can be really handy.

#+BEGIN_SRC emacs-lisp
(use-package auto-indent-mode
  :ensure t)
#+END_SRC

Let's configure some popup rules, so buffers don't take over the whole workspace
when they are popped up. I do this with Popwin

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :ensure t
  :commands popwin-mode
  :init (popwin-mode 1)
  :config
  (progn
    (defvar popwin:special-display-config-backup popwin:special-display-config)
    (setq display-buffer-function 'popwin:display-buffer
          popwin:popup-window-height 20)

    ;; remove compilation-mode from popwin, I want a full window
    (setq popwin:special-display-config
          (remove '(compilation-mode :noselect t) popwin:special-display-config))

    ;; basic
    (push '("*Help*" :stick t) popwin:special-display-config)
    (push '("*Pp Eval Output*" :stick t) popwin:special-display-config)

    ;; dictionaly
    (push '("*dict*" :stick t) popwin:special-display-config)
    (push '("*sdic*" :stick t) popwin:special-display-config)

    ;; popwin for slime
    (push '(slime-repl-mode :stick t) popwin:special-display-config)

    ;; man
    (push '(Man-mode :stick t :height 20) popwin:special-display-config)

    ;; Elisp
    (push '("*ielm*" :stick t) popwin:special-display-config)
    (push '("*eshell pop*" :stick t) popwin:special-display-config)

    ;; python
    (push '("*Python*"   :stick t) popwin:special-display-config)
    (push '("*Python Help*" :stick t :height 20) popwin:special-display-config)
    (push '("*jedi:doc*" :stick t :noselect t) popwin:special-display-config)

    ;; Haskell
    (push '("*haskell*" :stick t) popwin:special-display-config)
    (push '("*GHC Info*") popwin:special-display-config)

    ;; git-gutter
    (push '("*git-gutter:diff*" :width 0.5 :stick t)
          popwin:special-display-config)

    (push '("*Occur*" :stick t) popwin:special-display-config)

    ;; prodigy
    (push '("*prodigy*" :stick t) popwin:special-display-config)

    ;; org-mode
    (push '("*Org tags*" :stick t :height 30)
          popwin:special-display-config)

    ;; Completions
    (push '("*Completions*" :stick t :noselect t) popwin:special-display-config)

    ;; ggtags
    (push '("*ggtags-global*" :stick t :noselect t :height 30) popwin:special-display-config)

    ;; async shell commands
    (push '("*Async Shell Command*" :stick t) popwin:special-display-config)

    (push '(" *undo-tree*" :width 0.3 :position right) popwin:special-display-config)

    (global-set-key (kbd "C-h e") 'popwin:messages)))
#+END_SRC




Usually =M-SPC= is bound to ~just-one-space~, but [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]] is actually
a better alternative because it can shrink space between lines.

Thanks to
http://pragmaticemacs.com/emacs/delete-blank-lines-and-shrink-whitespace/ for
the link to this package.

#+BEGIN_SRC emacs-lisp
(use-package shrink-whitespace
  :ensure t
  :bind ("M-SPC" . shrink-whitespace))
#+END_SRC

Extended bookmarks, which I've started used for dired buffers and so on. I
always have a bookmark for my Downloads folder as well as some TRAMP bookmarks
for my webserver, in case I want to manually copy things around.

#+BEGIN_SRC emacs-lisp
  (use-package bookmark+
    :disabled t
    :ensure t
    :defer 10
    :init (setq bmkp-replace-EWW-keys-flag t)
    :config
    (setq bookmark-version-control t
          ;; auto-save bookmarks
          bookmark-save-flag 1))
#+END_SRC

Anzu shows the number of search hits in the modeline, which is handy.

It can also be used for a "refactor-like" thing similar to query-replace.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :defer t
  :bind ("M-%" . anzu-query-replace-regexp)
  :config
  (progn
    (use-package thingatpt)
    (setq anzu-mode-lighter ""
          ;; spaceline already takes care of this
          anzu-cons-mode-line-p nil)
    (set-face-attribute 'anzu-mode-line nil :foreground "yellow")))

(add-hook 'prog-mode-hook #'anzu-mode)
(add-hook 'org-mode-hook #'anzu-mode)
#+END_SRC

Also, add a thing for yanking the entire symbol into the query while searching:

#+BEGIN_SRC emacs-lisp
(defun isearch-yank-symbol ()
  (interactive)
  (isearch-yank-internal (lambda () (forward-symbol 1) (point))))

(define-key isearch-mode-map (kbd "C-M-w") #'isearch-yank-symbol)
#+END_SRC

** Avy mode
#+BEGIN_SRC emacs-lisp
(use-package avy
  :init
  (progn (bind-key "M-s M-s" 'avy-isearch isearch-mode-map))
  :config
  (progn
    (use-package dash)

    (defun avy-isearch ()
      "Override to allow avy-background to work as configured."
      (interactive)
      (avy-with avy-isearch
                (avy--process
                 (avy--regex-candidates isearch-string)
                 (avy--style-fn avy-style))
                (isearch-done)))

    (setq avy-background t)
    (setq avy-all-windows 'all-frames)
    (setq avy-style 'de-bruijn)
    (setq avy-keys (-concat (number-sequence ?a ?z) (number-sequence ?A ?Z))))

  :bind (("M-s M-s w" . avy-goto-word-0)
         ("M-s s w"   . avy-goto-word-or-subword-1)
         ("M-s s l"   . avy-goto-line)
         ("M-s s i"   . avy-goto-char-in-line)
         ("M-s s c"   . avy-goto-char)
         ("M-s z t"   . avy-zap-to-char)
         ("M-s z u"   . avy-zap-up-to-char)
         ("M-s c c"   . avy-copy-line)
         ("M-s c m"   . avy-move-line)
         ("M-s c r"   . avy-copy-region)))
#+END_SRC

Automagically resizes the windows to be the golden ratio (1.618), nice when
using a big font size and I need more eshell space

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :defer t
  :init
  (add-hook 'ediff-before-setup-windows-hook (lambda () (golden-ratio-mode -1)))
  (add-hook 'ediff-quit-hook (lambda () (golden-ratio-mode 1)))
  :config
  ;; Default is 1.0, but I find this adjust just slightly less, which is nice
  (setq golden-ratio-adjust-factor .9)

  (defun deos/helm-alive-p ()
    (if (boundp 'helm-alive-p)
        (symbol-value 'helm-alive-p)))
  (defun deos/ispell-running-p ()
    (and (boundp 'ispell-choices-buffer)
         (get-buffer ispell-choices-buffer)))

  ;; Inhibit helm and ispell buffers
  (setq golden-ratio-inhibit-functions '(deos/helm-alive-p deos/ispell-running-p))

  (setq golden-ratio-exclude-buffer-regexp '("\\`\\*[Hh]elm.*\\*\\'")
        golden-ratio-exclude-buffer-names '("*Org Select*")
        golden-ratio-exclude-modes '(messages-buffer-mode
                                     fundamental-mode
                                     ediff-mode
                                     calendar-mode
                                     wget-mode
                                     calc-mode
                                     calc-trail-mode
                                     mu4e-view-mode
                                     mu4e-headers-mode
                                     magit-popup-mode)
        golden-ratio-recenter t))
#+END_SRC

Add a generic cleanup method that can be called everywhere, bound to =C-c n=:

#+BEGIN_SRC emacs-lisp
(defun untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max)))

(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))

(defvar bad-cleanup-modes '(python-mode yaml-mode)
  "List of modes where `cleanup-buffer' should not be used")

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a
buffer. If the buffer is one of the `bad-cleanup-modes' then no
re-indenting and un-tabification is done."
  (interactive)
  (unless (member major-mode bad-cleanup-modes)
    (progn
      (indent-buffer)
      (untabify-buffer)))
  (delete-trailing-whitespace))

;; Perform general cleanup.
(global-set-key (kbd "C-c n") #'cleanup-buffer)
#+END_SRC

Read-only viewing of files is quite useful. Keybindings for paging through stuff
in a less/vim manner.

Make sure you install =mupdf= for the best quality PDFs on Linux and OSX. (=brew
install mupdf= on osx)

#+BEGIN_SRC emacs-lisp
(use-package view
  :defer 15
  :config
  (progn
    (defun View-goto-line-last (&optional line)
      "goto last line"
      (interactive "P")
      (goto-line (line-number-at-pos (point-max))))

    (define-key view-mode-map (kbd "e") 'View-scroll-half-page-forward)
    (define-key view-mode-map (kbd "u") 'View-scroll-half-page-backward)

    ;; less like
    (define-key view-mode-map (kbd "N") 'View-search-last-regexp-backward)
    (define-key view-mode-map (kbd "?") 'View-search-regexp-backward?)
    (define-key view-mode-map (kbd "g") 'View-goto-line)
    (define-key view-mode-map (kbd "G") 'View-goto-line-last)
    ;; vi/w3m like
    (define-key view-mode-map (kbd "h") 'backward-char)
    (define-key view-mode-map (kbd "j") 'next-line)
    (define-key view-mode-map (kbd "k") 'previous-line)
    (define-key view-mode-map (kbd "l") 'forward-char)))

(use-package doc-view
  :config
  (define-key doc-view-mode-map (kbd "j")
    #'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k")
    #'doc-view-previous-line-or-previous-page)
  ;; use 'q' to kill the buffer, not just hide it
  (define-key doc-view-mode-map (kbd "q")
    #'kill-this-buffer))

(defun deos/turn-on-viewing-mode ()
  "Turn on the viewing mode, to make looking through logs easier"
  (interactive)
  (view-mode 1)
  (when (fboundp 'deos/turn-on-hl-line)
    (deos/turn-on-hl-line)))
#+END_SRC

I also use the 'pdf-tools' package, which is *really* nice for viewing PDF
files. The only real caveat for it is that it requires you to do the =M-x
pdf-tools-install= every time the package is updated, to actually *build* the
tool that it uses.

#+BEGIN_SRC emacs-lisp

(use-package pdf-tools
  :ensure t
  :when window-system
  :init (pdf-tools-install))
#+END_SRC

Expand region is useful it's insane.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :defer t
  :bind (("C-c e" . er/expand-region)
         ("C-M-@" . er/contract-region)))
#+END_SRC

Mulitple cursors is like rectangular selection/insertion but on steroids

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+END_SRC

VLF lets me handle things like 2gb files gracefully, which is good, because
sometimes I need to look at someone's 5gb log file.

#+BEGIN_SRC emacs-lisp
(use-package vlf-setup
  :ensure vlf)
#+END_SRC

I use M-x =proced= a lot to get a top-like (or htop-like) display of processes,
kill them and all that, when I do, I want it to auto-update

#+BEGIN_SRC emacs-lisp
(setq-default proced-auto-update-flag t)
(setq-default proced-auto-update-interval 5)
(add-hook 'proced-mode-hook 'deos/turn-on-hl-line)
#+END_SRC

I don't really need bi-directional display, so let's speed up long lines

#+BEGIN_SRC emacs-lisp
(setq-default bidi-display-reordering nil)
#+END_SRC

Don't bother saving things to the kill-ring twice, remove duplicates

#+BEGIN_SRC emacs-lisp
(setq kill-do-not-save-duplicates t)
#+END_SRC

Preserve the window location when opening things

#+BEGIN_SRC emacs-lisp
(setq switch-to-buffer-preserve-window-point t)
#+END_SRC

Use a sane re-builder syntax so I don't have to have crazy escapes, see:
https://masteringemacs.org/article/re-builder-interactive-regexp-builder

#+BEGIN_SRC emacs-lisp
(setq reb-re-syntax 'string)
#+END_SRC

Ignore case when performing completion

#+BEGIN_SRC emacs-lisp
(setq completion-ignore-case t
      read-file-name-completion-ignore-case t)
#+END_SRC

I occasionally use =rgrep= to search through code, and it can be pretty handy to
be able to refactor the name of a method or something by making the ~*grep*~
buffer writable, that's what wgrep does.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :init (require 'wgrep))
#+END_SRC

Increase the auto-revert timer from its default of 5 seconds to a more
reasonable value

#+BEGIN_SRC emacs-lisp
(setq auto-revert-interval 10)
#+END_SRC
** Binding the EOS mega-map with Hydra
:PROPERTIES:
:CUSTOM_ID: eos-hydra-map
:END:

I'm used to not be a fan of hydra, mostly because I don't need popups for every
little thing under the sun. However, I lately decided I wanted a unified
interface to the parts of EOS.

#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)

(defhydra deos/hydra-toggle-map nil
  "
^Toggle^
^^^^^^^^----------------------
_d_: debug-on-error             _+_: monitor jack in
_D_: debug-on-quit              _-_: monitor jack out
_f_: fixed/variable width mode  _0_: monitor reset
_F_: auto-fill-mode             _R_: code reading mode
_l_: toggle-truncate-lines
_h_: hl-line-mode
_r_: read-only-mode
_v_: viewing-mode
_n_: narrow-or-widen-dwim
_g_: golden-ratio-mode
_q_: quit
"
  ("d" toggle-debug-on-error :exit t)
  ("D" toggle-debug-on-quit :exit t)
  ("g" golden-ratio-mode :exit t)
  ("f" variable-pitch-mode :exit t)
  ("F" auto-fill-mode :exit t)
  ("l" toggle-truncate-lines :exit t)
  ("r" read-only-mode :exit t)
  ;; This gets turned on/off unconditionally (not the deos/turn-on-hl-line-mode)
  ("h" hl-line-mode :exit t)
  ("v" deos/turn-on-viewing-mode :exit t)
  ("n" deos/narrow-or-widen-dwim :exit t)
  ("+" deos/monitor-jack-in :exit t)
  ("-" deos/monitor-jack-out :exit t)
  ("0" deos/monitor-reset :exit t)
  ("R" deos/code-reading-mode :exit t)
  ("q" nil :exit t))

(defhydra deos/hydra-next-error nil
  "Error Selection"
  ("`" next-error "next")
  ("j" next-error "next" :bind nil)

  ("n" next-error "next" :bind nil)
  ("k" previous-error "previous" :bind nil)
  ("p" previous-error "previous" :bind nil)
  ("l" flycheck-list-errors "list-errors" :exit t)
  ("q" nil "quit" :color red))

(defhydra deos/hydra-macro
  (:pre
   (when defining-kbd-macro
     (kmacro-end-macro 1)))
  "
  ^Create-Cycle^   ^Basic^           ^Insert^        ^Save^         ^Edit^
╭─────────────────────────────────────────────────────────────────────────╯
     ^_k_^           [_e_] execute    [_n_] insert    [_b_] name      [_'_] previous
     ^^↑^^           [_d_] delete     [_t_] set       [_K_] key       [_,_] last
 ( ←   → )       [_o_] edit       [_a_] add       [_x_] register
     ^^↓^^           [_r_] region     [_f_] format    [_B_] defun
     ^_j_^           [_m_] step
    ^^   ^^          [_s_] swap
"
  ("(" kmacro-start-macro :color blue)
  (")" kmacro-end-or-call-macro-repeat)
  ("k" kmacro-cycle-ring-previous)
  ("j" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("e" kmacro-end-or-call-macro-repeat)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("n" kmacro-insert-counter)
  ("t" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" kmacro-edit-macro)
  ("," edit-kbd-macro)
  ("q" nil :color blue))
#+END_SRC

Here's a Hydra for information about the system (and emacs) that I stole from a
different user:

#+BEGIN_SRC emacs-lisp
(defhydra deos/hydra-about-emacs ()
  "
    About Emacs                                                        [_q_] quit
    ^^--------------------------------------------------------------------------
    PID:             %s(emacs-pid)
    Uptime:          %s(emacs-uptime)
    Init time:       %s(emacs-init-time)
    Directory:       %s(identity user-emacs-directory)
    Invoked from:    %s(concat invocation-directory invocation-name)
    Version:         %s(identity emacs-version)

    User Info
    ^^--------------------------------------------------------------------------
    User name:       %s(user-full-name)
    Login (real):    %s(user-login-name) (%s(user-real-login-name))
      UID (real):    %s(user-uid) (%s(user-real-uid))
      GID (real):    %s(group-gid) (%s(group-real-gid))
    Mail address:    %s(identity user-mail-address)

    System Info
    ^^--------------------------------------------------------------------------
    System name:     %s(system-name)
    System type:     %s(identity system-type)
    System config:   %s(identity system-configuration)
    "
  ("q" nil nil))
#+END_SRC

And finally, the main EOS Hydra for entry:

#+BEGIN_SRC emacs-lisp
(defhydra deos/hydra nil
  "
╭────────────────────────────────────────────────────────╯
  [_a_] Org Agenda       [_E_] ERC       [_m_] Mail
  [_t_] Toggle map       [_T_] Twitter   [_M_] Music
  [_s_] Skeletons        [_P_] Prodigy   [_g_] Gnus
  [_p_] Proced           [_W_] Weather   [(] Macros
  [_c_] Multi-compile    [_R_] RSS       [`] Errors
  [_d_] Downloads        [_D_] Debbugs   [_C_] ES-CC
  [_b_] Project's Eshell [_S_] Smerge    [_B_] Bookmarks
  [_q_] quit
"

  ("`" deos/hydra-next-error/body :exit t)
  ("(" deos/hydra-macro/body :exit t)
  ("a" (org-agenda nil " ") :exit t)
  ("b" deos/popup-project-eshell :exit t)
  ("A" deos/hydra-about-emacs/body :exit t)
  ("t" deos/hydra-toggle-map/body :exit t)
  ("T" deos/start-or-jump-to-twitter :exit t)
  ("g" gnus :exit t)
  ("d" deos/popup-downloads :exit t)
  ("D" debbugs-gnu :exit t)
  ("B" helm-bookmarks :exit t)
  ("C" es-command-center :exit t)
  ("m" deos/switch-to-mail :exit t)
  ("M" deos/hydra-mpd/body :exit t)
  ("c" multi-compile-run :exit t)
  ("E" (when (y-or-n-p "Really start ERC?") (start-erc)) :exit t)
  ("R" elfeed :exit t)
  ("s" deos/hydra-skeleton/body :exit t)
  ("S" deos/hydra-smerge/body :exit t)
  ("p" proced :exit t)
  ("P" prodigy :exit t)
  ("W" wttrin :exit t)
  ("q" nil :exit t))

;; Bind the main EOS hydra to M-t
(global-set-key (kbd "M-t") 'deos/hydra/body)
#+END_SRC

Undo-tree allows me to have sane undo defaults, as well as being able to
visualize it in ascii art if needed.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init (global-undo-tree-mode t)
  :defer t
  :diminish ""
  :config
  (progn
    (define-key undo-tree-map (kbd "C-x u") 'undo-tree-visualize)
    (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)))
(defhydra hydra-undo-tree (:color yello :hint nil)
  "
  _p_: undo _n_: redo _s_: save _l_: load  "
  ("p"   undo-tree-undo)
  ("n"   undo-tree-redo)
  ("s"   undo-tree-save-history)
  ("l"   undo-tree-load-history)
  ("u"   undo-tree-visualize "visualize" :color blue)
  ("q"   nil "quit" :color blue))

(global-set-key (kbd "M-,") 'hydra-undo-tree/undo-tree-undo)
#+END_SRC

** GPG and gpg-agent (as well as SSH agent)
:PROPERTIES:
:CUSTOM_ID: gpg-agent
:END:

I use =gpg-agent= [fn:30:
https://www.debian-administration.org/article/452/Using_gnupg-agent_to_securely_retain_keys]
as an ssh agent.

#+begin_src emacs-lisp
(defun tsp/gpg-version ()
  "Return the version of gpg as a string"
  (save-window-excursion
    (with-temp-buffer
      (shell-command (concat epg-gpg-program " --version") (current-buffer))
      (goto-char (point-min))
      (string-match "gpg (GnuPG) \\(.*\\)" (buffer-string))
      (tsp/str-chomp
       (match-string 1)))))
#+end_src

Before we start, let's install a nice little tool for setting up ssh-agent and
gpg-agent, =keychain=

I use =gpg2= everywhere, including in Emacs.

#+BEGIN_SRC emacs-lisp
(setq epg-gpg-program "gpg2")
#+END_SRC

** OS-specific settings
:PROPERTIES:
:CUSTOM_ID: os-specific-settings
:END:

*** Linux
:PROPERTIES:
:CUSTOM_ID: linux
:END:

#+BEGIN_SRC emacs-lisp
(when *is-linux*

  ;; Whether to use GTK tooltips or emacs ones
  ;; (setq x-gtk-use-system-tooltips nil)
  (setq x-gtk-use-system-tooltips t)

  (defun tsp/max-fullscreen ()
    (interactive)
    (toggle-frame-maximized))

  ;; fullscreen
  (add-hook 'after-init-hook #'tsp/max-fullscreen)

  (setq dired-listing-switches "-lFaGh1v --group-directories-first")

  ;; suspend-frame isn't working on Linux?
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "C-x C-z")))
#+END_SRC

*** Mac OSX
:PROPERTIES:
:CUSTOM_ID: mac-osx
:END:

#+BEGIN_SRC emacs-lisp
(when *is-a-mac*
  (setq ns-use-native-fullscreen nil)
  ;; brew install coreutils
  (if (executable-find "gls")
      (progn
        (setq insert-directory-program "gls")
        (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
    (setq dired-listing-switches "-ahlF"))
  (defun copy-from-osx ()
    "Handle copy/paste intelligently on osx."
    (let ((pbpaste (purecopy "/usr/bin/pbpaste")))
      (if (and *is-a-mac*
               (file-exists-p pbpaste))
          (let ((tramp-mode nil)
                (default-directory "~"))
            (shell-command-to-string pbpaste)))))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "/usr/bin/pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))
  (setq interprogram-cut-function 'paste-to-osx
        interprogram-paste-function 'copy-from-osx)

  (defun move-file-to-trash (file)
    "Use `trash' to move FILE to the system trash.
When using Homebrew, install it using \"brew install trash\"."
    (call-process (executable-find "trash")
                  nil 0 nil
                  file)))
#+END_SRC

Sometimes I use the OSX =emacs-mac= port:
https://github.com/railwaycat/emacs-mac-port , which has a whole other set of
issues, so this is special handling of it...

#+BEGIN_SRC emacs-lisp
(when *is-a-mac*

  (defun deos/max-fullscreen ()
    (interactive)
    (set-frame-parameter nil 'fullscreen 'fullboth))

  ;; fullscreen
  (add-hook 'after-init-hook #'deos/max-fullscreen)
  ;; use alt as hyper
  (setq mac-option-modifier 'meta)
  ;; use command as meta
  (setq mac-command-modifier 'hyper))
#+END_SRC

** Spell check and flyspell settings
:PROPERTIES:
:CUSTOM_ID: spellcheck
:END:
I use Hunspell and Aspell checking spelling, ignoring words under 3 characters
and running very quickly. My personal word dictionary is at =~/.flydict=.

While I used to use Hunspell, I've gone back to aspell because it's a bit easier
to get up and running with.

#+BEGIN_SRC emacs-lisp
;; Standard location of personal dictionary
(setq ispell-personal-dictionary "~/.flydict")

;; Mostly taken from
;; http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html
(when (executable-find "aspell")
  (setq ispell-program-name (executable-find "aspell"))
  (setq ispell-extra-args
        (list "--sug-mode=fast" ;; ultra|fast|normal|bad-spellers
              "--lang=en_US"
              "--ignore=4")))

;; hunspell
(when (executable-find "hunspell")
  (setq ispell-program-name (executable-find "hunspell"))
  (setq ispell-extra-args '("-d en_US"
                            "-p ~/.flydict")))

(add-to-list 'ispell-skip-region-alist '("[^\000-\377]+"))
(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))
#+END_SRC

In most non-programming modes, =M-.= can be used to spellcheck the word
(otherwise it would jump to the definition)

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :defer t
  :diminish ""
  :init
  ;; So previously, I used to do this:
  ;;(add-hook 'prog-mode-hook #'flyspell-prog-mode)

  ;; start with it turned off
  (setq deos/programming-spellcheck nil)

  (use-package shut-up :ensure t)
  (defun deos/flyspell-buffer-quietly ()
    (interactive)
    (when deos/programming-spellcheck
      (save-excursion (shut-up (flyspell-buffer)))))

  ;; But, the problem then is that you get spell checking as you go, instead,
  ;; I think I'd rather have the buffer spellchecked when it's saved, and still
  ;; be able to go through the errors
  (defun deos/turn-on-programming-spellcheck ()
    (interactive)
    (flyspell-mode -1)
    (when (not (and (boundp 'org-src-mode)
                    org-src-mode))
      ;; Tell the local buffer it's safe to flyspell this after save
      (setq-local deos/programming-spellcheck t)
      ;; Automatically becomes local
      (setq flyspell-generic-check-word-predicate
            #'flyspell-generic-progmode-verify)
      ;; C-, is normally set in flyspell mode, but since we're not turning it on,
      ;; we still need to be able to hit it, so bind it locally
      (local-set-key (kbd "C-,") 'flyspell-goto-next-error)))
  ;; Turned off right now, as I'm still tweaking this
  ;;(add-hook 'after-save-hook #'deos/flyspell-buffer-quietly)
  (add-hook 'prog-mode-hook #'deos/turn-on-programming-spellcheck)
  :config
  (define-key flyspell-mode-map (kbd "C-.") 'company-complete))
#+END_SRC

** Multiple Emacs Perspectives with Eyebrowse
:PROPERTIES:
:CUSTOM_ID: eyebrowse
:END:
Eyebrowse is a great package for workspaces in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :init
  (defun deos/create-eyebrowse-setup ()
     (interactive)
     "Create a default window config, if none is present"
     (when (not (eyebrowse--window-config-present-p 4))
       ;; there's probably a better way to do this, creating four workspaces
       (eyebrowse-switch-to-window-config-2)
       (eyebrowse-switch-to-window-config-3)
       (eyebrowse-switch-to-window-config-4)
       (eyebrowse-switch-to-window-config-1)))
     (setq eyebrowse-wrap-around t
           eyebrowse-new-workspace t
           eyebrowse-mode-line-separator " ")
     (eyebrowse-mode 1)
     (global-set-key (kbd "C-'") 'eyebrowse-next-window-config)
     (add-hook 'after-init-hook #'deos/create-eyebrowse-setup))
#+END_SRC

** Automatically saving files
:PROPERTIES:
:CUSTOM_ID: h:1feb51db-6ea9-49bb-86b3-295f03c0d3fe
:END:

I've experimented a bit with the different auto-save features that Emacs has,
=super-save=, =auto-save-mode=, and =auto-save-mode-enhanced=. They can be nice,
but they also have a bit of downsides...

#+BEGIN_SRC emacs-lisp
(use-package auto-save-buffers-enhanced
  :ensure t
  :disabled t
  :init (auto-save-buffers-enhanced t)
  :config
  (setq auto-save-buffers-enhanced-interval 3.0
        ;; Don't auto-save org source popups
        auto-save-buffers-enhanced-exclude-regexps '("Org Src")
        ;; Save things quietly
        auto-save-buffers-enhanced-quiet-save-p t))
#+END_SRC

** Handling excessively long lines
:PROPERTIES:
:CUSTOM_ID: h:d610191c-44ba-40b4-9d07-9e26d1c50395
:END:

#+BEGIN_SRC emacs-lisp
(when (require 'so-long nil :noerror)
  ;; 750 columns means it's too long! (default is 250)
  (setq so-long-threshold 750)
  (add-to-list 'so-long-minor-modes 'rainbow-delimiters-mode)
  (add-to-list 'so-long-minor-modes 'paren-face-mode)
  (add-to-list 'so-long-minor-modes 'electric-indent-mode)
  (add-to-list 'so-long-minor-modes 'electric-pair-mode)
  (add-to-list 'so-long-minor-modes 'electric-layout-mode)
  (add-to-list 'so-long-minor-modes 'idle-highlight-mode)
  (add-to-list 'so-long-minor-modes 'show-paren-mode)
  (add-to-list 'so-long-minor-modes 'git-gutter-mode)
  (so-long-enable)

  (defun deos/so-long-hook () "Used in `so-long-hook'.")

  (add-hook 'so-long-hook #'deos/so-long-hook))
#+END_SRC

** Lastpass
#+BEGIN_SRC emacs-lisp
(use-package lastpass
  :ensure t
  :config
  ;; Set lastpass user
  (setq lastpass-user "dwnewman78@gmail.com")
  ;; Enable lastpass custom auth-source
  (lastpass-auth-source-enable))
#+END_SRC

** Which Key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC
** Key-chords
#+BEGIN_SRC emacs-lisp
  (use-package use-package-chords
    :ensure t
    :config
    (key-chord-mode 1))
#+END_SRC
** Open the config file
#+BEGIN_SRC emacs-lisp
(defun find-config ()
  "Edit config.org"
  (interactive)
  (find-file "~/.emacs.d/config.org"))
(global-set-key (kbd "C-c I") 'find-config)
#+END_SRC
* Appearance
** Theme

I vant to suck your blood
#+BEGIN_SRC emacs-lisp
(use-package dracula-theme
  :ensure t
  :config
  (load-theme 'dracula t))
#+END_SRC

For kicks
#+BEGIN_SRC emacs-lisp
(use-package apropospriate-theme
  :ensure t)
#+END_SRC

This panda theme seems cool
#+BEGIN_SRC emacs-lisp
(use-package panda-theme
  :ensure t
  :config
  (load-theme 'panda t))
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
;; The original font height (so it can be restored too at a later time)
(setq deos/original-height 180)

(defun deos/setup-fonts ()
(when *is-gui*
;; default font and variable-pitch fonts
(set-face-attribute 'default nil
                    :family "Iosevka"
                    :height deos/original-height)
    (dolist (face '(mode-line mode-line-inactive minibuffer-prompt))
      (set-face-attribute face nil :family "Iosevka"
                          :height deos/original-height))
    (set-face-attribute 'variable-pitch nil
                        :family "DejaVu Sans" :height deos/original-height)
    ;; font for all unicode characters
    ;;(set-fontset-font t 'unicode "DejaVu Sans Mono" nil 'prepend)
    ))

(when *is-gui*
  (add-hook 'after-init-hook #'deos/setup-fonts))
#+END_SRC
** Monitor Switching
Sometimes I want to plug my laptop into a larger monitor, or give presentations,
so I'd like to have a single function I can call to adjust any sizes that are
necessary.

The =deos/height-modifier= can be added or subtracted to the size of the font for
Emacs. I usually bind this in the Hydra toggle map.

#+BEGIN_SRC emacs-lisp
(defvar deos/height-modifier 15
  "Default value to increment the size by when jacking into a monitor.")

(defun deos/monitor-jack-in ()
  "Increase the font size by `deos/height-modifier' amount, for
when you jack into an external monitor."
  (interactive)
  (dolist (face '(default
                   mode-line
                   mode-line-inactive
                   minibuffer-prompt
                   variable-pitch))
    (set-face-attribute face nil :height (+ (face-attribute face :height)
                                            deos/height-modifier))))

(defun deos/monitor-jack-out ()
  "Decreas the font size by `deos/height-modifier' amount, for
when you jack out of an external monitor."
  (interactive)
  (dolist (face '(default
                   mode-line
                   mode-line-inactive
                   minibuffer-prompt
                   variable-pitch))
    (set-face-attribute face nil :height (- (face-attribute face :height)
                                            deos/height-modifier))))

(defun deos/monitor-reset ()
  "Go back to the default font size and `line-spacing'"
  (interactive)
  (dolist (face '(default
                   mode-line
                   mode-line-inactive
                   minibuffer-prompt
                   variable-pitch))
    (set-face-attribute face nil :height deos/original-height))
  (text-scale-adjust 0)
  (when (fboundp 'minimap-mode)
    (condition-case err
        (minimap-mode 0)
      ('error 0)))
  (setq line-spacing 0))

(defun deos/code-reading-mode ()
  "Do a bunch of fancy stuff to make reading/browsing code
easier. When you're done, `deos/monitor-jack-out' is a great way
to go back to a normal setup."
  (interactive)
  (delete-other-windows)
  (text-scale-increase 1)
  (setq line-spacing 5)
  (use-package minimap :ensure t)
  (when (not minimap-mode)
    (minimap-mode 1)))
#+END_SRC
** Highlighting
#+BEGIN_SRC emacs-lisp
(setq deos/hl-line-enabled t)
(defun deos/turn-on-hl-line ()
  (interactive)
  (when deos/hl-line-enabled
    (hl-line-mode 1)))

(defun deos/turn-off-hl-line ()
  (interactive)
  (hl-line-mode -1))

(add-hook 'prog-mode-hook #'deos/turn-on-hl-line)
#+END_SRC
** Mode line
*** Powerline mode
#+BEGIN_SRC emacs-lisp
(use-package powerline
  :ensure t
  :config
  (setq powerline-default-separator 'utf-8))
#+END_SRC
*** Feebleline mode
Minimalist mode line
#+BEGIN_SRC emacs-lisp
(use-package feebleline
  :ensure t)
#+END_SRC
*** Emoji
#+BEGIN_SRC emacs-lisp
(use-package emojify
  :ensure t)
#+END_SRC
*** Nyan Cat
Just for fun
#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :ensure t)
#+END_SRC
** Codenotes
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\<\\(NOTE\\|FIXME\\|TODO\\|BUG\\|HACK\\|REFACTOR\\|THE HORROR\\)" 1 font-lock-warning-face t)))))
#+END_SRC
* Navigation
Here are some navigation tricks that I've acquired over the years
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x +") 'balance-windows-area)

(global-set-key (kbd "C-c y") #'bury-buffer)
(global-set-key (kbd "C-c C-y") #'bury-buffer)
(global-set-key (kbd "C-c r") #'revert-buffer)

;; ==== Window switching ====
(defun deos/other-window-backwards ()
  (interactive)
  (other-window -1))

(global-set-key (kbd "M-'") #'other-window)
(global-set-key (kbd "M-\"") #'deos/other-window-backwards)
(global-set-key (kbd "H-'") #'other-window)
(global-set-key (kbd "H-\"") #'deos/other-window-backwards)
(global-set-key (kbd "<C-tab>") #'other-window)
(global-set-key (kbd "C-x C-o") #'other-window)
#+END_SRC
Transpose the buffers
#+BEGIN_SRC emacs-lisp :tangle yes
(defun transpose-buffers (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

(global-set-key (kbd "C-x 4 t") 'transpose-buffers)
#+END_SRC

Some random navigation keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x C-l") 'toggle-truncate-lines)

;; join line to next line
(global-set-key (kbd "M-j")
                (lambda ()
                  (interactive)
                  (join-line -1)))

;; Completion that uses many different methods to find options.
(global-set-key (kbd "M-/") 'hippie-expand)

;; Font size
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)

;; Start or switch to eshell
(global-set-key (kbd "C-x C-m") 'eshell)

;; If you want to be able to M-x without meta (phones, etc)
(global-set-key (kbd "C-c C-x") 'execute-extended-command)
#+END_SRC

Highlight helpers
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hl-anything
  :ensure t
  :diminish hl-highlight-mode
  :commands hl-highlight-mode
  :init
  (global-set-key (kbd "<f7> <f7>") 'hl-highlight-thingatpt-local)
  (global-set-key (kbd "<f7> u") 'hl-unhighlight-all-local)
  (global-set-key (kbd "<f7> U") 'hl-unhighlight-all-global)
  (global-set-key (kbd "<f7> n") 'hl-find-next-thing)
  (global-set-key (kbd "<f7> p") 'hl-find-prev-thing))
#+END_SRC

** Isearch
#+BEGIN_SRC emacs-lisp :tangle yes
; Use regex searches by default.
;;(global-set-key (kbd "C-s") 'isearch-forward-regexp)
;;(global-set-key (kbd "C-r") 'isearch-backward-regexp)
;; Case-fold regex by default
(setq search-default-mode 'character-fold-to-regexp)
;; Non regex search gets the meta also
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)

;; Activate occur easily inside isearch
(define-key isearch-mode-map (kbd "C-o")
  (lambda () (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))

(defun deos/add-watchword (string)
  "Highlight whatever `string' is in the current buffer
permanently."
  (font-lock-add-keywords
   nil `((,(if isearch-regexp isearch-string (regexp-quote isearch-string))
          1 '((:background "yellow") (:weight bold)) t))))

(define-key isearch-mode-map (kbd "M-h")
  (lambda () (interactive)
    (deos/add-watchword
     (if isearch-regexp isearch-string (regexp-quote isearch-string)))))
#+END_SRC

** Mices
#+BEGIN_SRC emacs-lisp :tangle yes
;; mouse integration
(require 'mouse)
(xterm-mouse-mode t)
(global-set-key [mouse-4] '(lambda ()
                           (interactive)
                           (scroll-down 1)))
(global-set-key [mouse-5] '(lambda ()
                           (interactive)
                           (scroll-up 1)))
(setq mouse-sel-mode t)
(defun track-mouse (e))
#+END_SRC

** Move text
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package move-text
  :ensure t
  :init (move-text-default-bindings))
#+END_SRC

** Navigating without control
For those who are a little less evil
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra :ensure t)
(require 'view)

(defhydra deos/nav-mode (:foreign-keys run)
  "[NAV-MODE] q or i to exit"
  ("C-h" hl-line-mode)
  ("t" toggle-truncate-lines)
  ("a" beginning-of-line)
  ("l" forward-char)
  ("<right>" forward-char)
  ("h" backward-char)
  ("<left>" backward-char)
  ("n" next-line)
  ("j" next-line)
  ("<down>" next-line)
  ("p" previous-line)
  ("k" previous-line)
  ("<up>" previous-line)
  ("e" View-scroll-half-page-forward)
  ("u" View-scroll-half-page-backward)
  ("SPC" scroll-up-command)
  ("S-SPC" scroll-down-command)
  ("<" beginning-of-buffer)
  (">" end-of-buffer)
  ("." end-of-buffer)
  ("C-'" nil)
  ("d" (when (y-or-n-p "Kill buffer?")
         (kill-this-buffer))
   :exit t)
  ("/" isearch-forward-regexp :exit t)
  ("?" isearch-backward-regexp :exit t)
  ("i" nil :exit t)
  ("q" nil :exit t))

(global-set-key (kbd "M-V") 'deos/nav-mode/body)
#+END_SRC
* Org-mode
** Initial configuration
#+BEGIN_SRC emacs-lisp
(install-pkgs '(org-plus-contrib htmlize plantuml-mode gnuplot gnuplot-mode))
(require 'org)
(require 'org-habit)
#+END_SRC

Some things org-mode overwrites, I change them back

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-'") #'eyebrowse-next-window-config)
(define-key org-mode-map (kbd "C-c C-x C-f") #'org-refile)
(define-key org-mode-map (kbd "<C-tab>") #'other-window)
(define-key org-mode-map (kbd "C-c M-p") 'org-babel-previous-src-block)
(define-key org-mode-map (kbd "C-c M-n") 'org-babel-next-src-block)
#+END_SRC

Turn on some defaults
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented 'f)
(defun deos/org-mode-hook ()
  (interactive)
  (setq-local fill-column 100)
  (when (fboundp 'turn-on-auto-fill)
    (turn-on-auto-fill))
  (when (fboundp 'turn-on-flyspell)
    (turn-on-flyspell))
  (when (fboundp 'yas-minor-mode)
    (yas-minor-mode 1))
  (when (fboundp 'my/enable-abbrev-mode)
    (my/enable-abbrev-mode))

  (diminish 'org-indent-mode)
  (when (boundp 'org-agenda-mode-map)
    (define-key org-agenda-mode-map (kbd "C-c C-x C-f") #'org-agenda-refile)))
#+END_SRC

Global bindings

#+BEGIN_SRC emacs-lisp
        (global-set-key (kbd "C-c l") 'org-store-link)
        (global-set-key (kbd "C-c a") 'org-agenda)
        (when (fboundp 'org-iswitchb)
          (global-set-key (kbd "C-c b") 'org-iswitchb))
        (when (fboundp 'org-switchb)
          (global-set-key (kbd "C-c b") 'org-switchb))
        (global-set-key (kbd "C-c b") 'org-iswitchb)
        (global-set-key (kbd "C-c c") 'org-capture)

        (add-hook 'org-mode-hook #'hl-line-mode)
        (add-hook 'org-agenda-mode-hook #'hl-line-mode)
        (add-hook 'org-mode-hook #'deos/org-mode-hook)
        (when (boundp 'org-export-backends)
          (custom-set-variables '(org-export-backends '(ascii beamer html latex md))))
        ;; Allow's electric-pair-mode to surround things with = and ~ in org-mode
        (modify-syntax-entry ?~ "(~" org-mode-syntax-table)
        (modify-syntax-entry ?= "(=" org-mode-syntax-table)

        (setq org-directory (file-truename "~/personal/org"))

        (when (file-exists-p "~/personal/org")
          (setq org-agenda-files `(,(file-truename "~/personal/org/refile.org")
                                   ,(file-truename "~/personal/org/todo.org")
                                   ,(file-truename "~/personal/org/digitalreasoning.org")
                                   ,(file-truename "~/personal/org/learning.org")
                                   ,(file-truename "~/personal/org/gratitude.org")
                                   ,(file-truename "~/personal/org/notes.org")
                                   ,(file-truename "~/personal/org/bibliography.org")
                                   ,(file-truename "~/personal/org/journal.org")
                                   ,(file-truename "~/personal/org/emacs.org")
                                   ,(file-truename "~/personal/org/gcal.org")
                                   ,(file-truename "~/personal/org/workgcal.org"))))

#+END_SRC

Keybindings from http://doc.norang.ca/org-mode.html

#+BEGIN_SRC emacs-lisp
;; Custom Key Bindings
(global-set-key (kbd "<f12>") 'org-agenda)
(global-set-key (kbd "<f5>") 'bh/org-todo)
(global-set-key (kbd "<S-f5>") 'bh/widen)
(global-set-key (kbd "<f8>") 'org-cycle-agenda-files)
(global-set-key (kbd "<f9> <f9>") 'bh/show-org-agenda)
(global-set-key (kbd "<f9> b") 'bbdb)
(global-set-key (kbd "<f9> c") 'calendar)
(global-set-key (kbd "<f9> f") 'boxquote-insert-file)
(global-set-key (kbd "<f9> h") 'bh/hide-other)
(global-set-key (kbd "<f9> n") 'bh/toggle-next-task-display)

(global-set-key (kbd "<f9> I") 'bh/punch-in)
(global-set-key (kbd "<f9> O") 'bh/punch-out)

(global-set-key (kbd "<f9> r") 'boxquote-region)

(global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
(global-set-key (kbd "<f9> T") 'bh/toggle-insert-inactive-timestamp)

(global-set-key (kbd "<f9> v") 'visible-mode)
(global-set-key (kbd "<f9> l") 'org-toggle-link-display)
(global-set-key (kbd "<f9> SPC") 'bh/clock-in-last-task)
(global-set-key (kbd "C-<f9>") 'previous-buffer)
(global-set-key (kbd "M-<f9>") 'org-toggle-inline-images)
(global-set-key (kbd "C-<f10>") 'next-buffer)
(global-set-key (kbd "<f11>") 'org-clock-goto)
(global-set-key (kbd "C-<f11>") 'org-clock-in)
(global-set-key (kbd "C-s-<f12>") 'bh/save-then-publish)
(global-set-key (kbd "C-c c") 'org-capture)

(defun bh/hide-other ()
  (interactive)
  (save-excursion
    (org-back-to-heading 'invisible-ok)
    (hide-other)
    (org-cycle)
    (org-cycle)
    (org-cycle)))
#+END_SRC

** Tasks and States
*** Todo keywords
#+BEGIN_SRC emacs-lisp
  ;; Org todo keywords
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "NEEDSREVIEW(N@/!)" "|" "DONE(d)")
          (sequence "MEETING" "|" "DONE(d)")
          (sequence "WAITING(w@/!)" "HOLD(h@/!)"
                    "|" "CANCELLED(c@/!)" "MEETING")))
  (setq org-todo-keyword-faces
        '(("TODO" :foreground "red" :weight bold)
          ("NEXT" :foreground "blue" :weight bold)
          ("NEEDSREVIEW" :foreground "#edd400" :weight bold)
          ("WAITING" :foreground "orange" :weight bold)
          ("HOLD" :foreground "magenta" :weight bold)
          ("DONE" :foreground "forest green" :weight bold)
          ("MEETING" :foreground "forest green" :weight bold)
          ("CANCELLED" :foreground "forest green" :weight bold)))
#+END_SRC

The following diagram shows the possible state transitions for a task. Different than BH’s because I use a NEEDSREVIEW state to indicate a pull request is waiting for review

#+BEGIN_SRC plantuml :file images/normal_task_states.png :cache yes
title Task States
[*] -> TODO
TODO -> NEXT
TODO -> NEEDSREVIEW
TODO -> WAITING
TODO -> DONE
TODO --> HOLD
TODO --> CANCELLED
NEXT -> DONE
NEXT -> NEEDSREVIEW
NEXT -> CANCELLED
NEXT --> HOLD
NEXT --> WAITING
NEEDSREVIEW -> DONE
NEEDSREVIEW -> NEXT
NEEDSREVIEW -> CANCELLED
WAITING --> TODO
WAITING --> NEXT
WAITING --> CANCELLED
HOLD --> CANCELLED
HOLD --> TODO
DONE -> [*]
CANCELLED --> [*]
TODO: t
NEXT: n
note right of NEEDSREVIEW: Note records\nlocation of review
NEEDSREVIEW: N
DONE: d
note right of WAITING: Note records\nwhat it is waiting for
WAITING:w
note right of HOLD: Note records\nwhy it is on hold
HOLD:h
note right of CANCELLED: Note records\nwhy it was cancelled
CANCELLED:c
WAITING --> DONE
#+END_SRC

*** Project Task States

I use a lazy project definition. I don’t like to bother with manually stating ‘this is a project’ and ‘that is not a project’. For me a project definition is really simple. If a task has subtasks with a todo keyword then it’s a project. That’s it.

Projects can be defined at any level - just create a task with a todo state keyword that has at least one subtask also with a todo state keyword and you have a project. Projects use the same todo keywords as regular tasks. One subtask of a project needs to be marked NEXT so the project is not on the stuck projects list.

*** Meetings

Meetings are special. They are created in a done state by a capture task. I use the MEETING capture template when someone interrupts what I’m doing with a question or discussion. I clock the amount of time spent with whomever it is and record some notes of what was discussed (either during or after the meeting) depending on content, length, and complexity of the discussion.

The time of the meeting is recorded for as long as the capture task is active. If I need to look up other details and want to close the capture task early I can just C-c C-c to close the capture task (stopping the clock) and then f9 SPC to resume the clock in the meeting task while I do other things.

#+begin_src plantuml :file images/meeting_states.png :cache yes
title Meeting Task State
[*] -> MEETING
MEETING -> [*]
#+end_src

The setting

#+BEGIN_SRC emacs-lisp
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

allows changing todo states with S-left and S-right skipping all of the normal processing when
entering or leaving a todo state. This cycles through the todo states but skips setting timestamps
and entering notes which is very convenient when all you want to do is fix up the status of an
entry.

*** Todo state triggers
:PROPERTIES:
:CUSTOM_ID: h:42ae1cf6-0ca0-4283-9d6f-00129c8612ce
:END:

I have a few triggers that automatically assign tags to tasks based on state changes. If a task
moves to =CANCELLED= state then it gets a =CANCELLED= tag. Moving a =CANCELLED= task back to =TODO=
removes the =CANCELLED= tag. These are used for filtering tasks in agenda views.

The triggers break down to the following rules:

- Moving a task to =CANCELLED= adds a =CANCELLED= tag
- Moving a task to =WAITING= adds a =WAITING= tag
- Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
- Moving a task to =NEEDSREVIEW= adds a =REVIEW= tag
- Moving a task to a done state removes =WAITING= and =HOLD= tags
- Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags

The tags are used to filter tasks in the agenda views conveniently.

#+BEGIN_SRC emacs-lisp
(setq org-todo-state-tags-triggers
      '(("CANCELLED" ("CANCELLED" . t))
        ("WAITING" ("WAITING" . t))
        ("NEEDSREVIEW" ("REVIEW" . t))
        ("HOLD" ("WAITING") ("HOLD" . t))
        (done ("WAITING") ("HOLD") ("REVIEW"))
        ("TODO" ("WAITING") ("CANCELLED") ("HOLD") ("REVIEW"))
        ("NEXT" ("WAITING") ("CANCELLED") ("HOLD") ("REVIEW"))
        ("DONE" ("WAITING") ("CANCELLED") ("HOLD") ("REVIEW"))))
#+END_SRC

** Adding tasks with org capture
:PROPERTIES:
:CUSTOM_ID: h:a35f1183-5230-4d37-8ddb-9a0f91a4fd91
:END:

Org Capture mode replaces remember mode for capturing tasks and notes.

To add new tasks efficiently I use a minimal number of capture
templates.  I used to have lots of capture templates, one for each
org-file.  I'd start org-capture with =C-c c= and then pick a template
that filed the task under =* Tasks= in the appropriate file.

I found I still needed to refile these capture tasks again to the
correct location within the org-file so all of these different capture
templates weren't really helping at all.  Since then I've changed my
workflow to use a minimal number of capture templates -- I create the
new task quickly and refile it once.  This also saves me from
maintaining my org-capture templates when I add a new org file.

*** Capture Templates
:PROPERTIES:
:CUSTOM_ID: h:e89de864-0f06-4c5e-a54d-0d37e45be3b7
:END:

When a new task needs to be added I categorize it into one of a few
things:

- A meeting (m)
- An email I need to respond to (r)
- A new task (t)
- A new note (n)

  #+BEGIN_SRC emacs-lisp
;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
(setq org-capture-templates
      '(("t" "Todo" entry (file "~/personal/org/refile.org")
         "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
        ("r" "respond" entry (file "~/personal/org/refile.org")
         "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n"
         :clock-in t :clock-resume t :immediate-finish t)
        ("m" "Meeting" entry (file "~/personal/org/refile.org")
         "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
        ("n" "Note" entry (file+headline "~/personal/org/notes.org" "Notes")
         "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
        ("j" "Journal" entry (file+datetree "~/personal/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("w" "org-protocol" entry (file "~/personal/org/refile.org")
         "* TODO Review %c\n%U\n" :immediate-finish t)
        ("b" "Book/Bibliography" entry
         (file+headline "~/personal/org/bibliography.org" "Refile")
         "* %?%^{TITLE}p%^{AUTHOR}p%^{TYPE}p")
        ("e" "Emacs Issues" entry (file+headline "~/personal/org/emacs.org" "Issues")
         "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)))
  #+END_SRC

Capture mode now handles automatically clocking in and out of a capture task. This all works out of
the box now without special hooks. When I start a capture mode task the task is clocked in as
specified by =:clock-in t= and when the task is filed with =C-c C-c= the clock resumes on the
original clocking task.

The quick clocking in and out of capture mode tasks (often it takes less than a minute to capture
some new task details) can leave empty clock drawers in my tasks which aren't really useful. Since I
remove clocking lines with 0:00 length I end up with a clock drawer like this:

#+begin_src org :exports src
,* TODO New Capture Task
  :LOGBOOK:
  :END:
  [2010-05-08 Sat 13:53]
#+end_src

I have the following setup to remove these empty =LOGBOOK= drawers if they occur.

#+begin_src emacs-lisp
;; Remove empty LOGBOOK drawers on clock out
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))

(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
#+end_src

*** Separate files for Capture Tasks
:PROPERTIES:
:CUSTOM_ID: h:6a297830-08f4-4662-8223-8f5728d8aa93
:END:

I have a single org file which is the target for my capture templates.

I store notes, tasks, phone calls, and org-protocol tasks in =refile.org=. I used to use multiple
files but found that didn't really have any advantage over a single file.

Normally this file is empty except for a single line at the top which creates a =REFILE= tag for
anything in the file.

The file has a single permanent line at the top like this
#+begin_src org :exports src
,#+FILETAGS: REFILE
#+end_src

*** Capture Tasks is about being Fast
:PROPERTIES:
:CUSTOM_ID: h:a2a73df1-243c-406d-9677-c38da32d87f5
:END:

Okay I'm in the middle of something and oh yeah - I have to remember to do that. I don't stop what
I'm doing. I'm probably clocking a project I'm working on and I don't want to lose my focus on that
but I can't afford to forget this little thing that just came up.

So what do I do? Hit =C-c c= to start capture mode and select =t= since it's a new task and I get a
buffer like this:

#+begin_src org :exports src
,* TODO
  [2010-08-05 Thu 21:06]

  [[file:~/deos/init-org.org::*Capture%20Tasks%20is%20about%20being%20Fast][Capture Tasks is about being Fast]]
#+end_src

Enter the details of the TODO item and =C-c C-c= to file it away in refile.org and go right back to
what I'm really working on secure in the knowledge that that item isn't going to get lost and I
don't have to think about it anymore at all now.

The amount of time I spend entering the captured note is clocked. The capture templates are set to
automatically clock in and out of the capture task. This is great for interruptions and telephone
calls too.

** Refiling Tasks
:PROPERTIES:
:CUSTOM_ID: h:0104e42d-b6ba-48a6-ae62-d8a5c596cbe6
:END:

Refiling tasks is easy. After collecting a bunch of new tasks in my refile.org file using capture
mode I need to move these to the correct org file and topic. All of my active org-files are in my
=org-agenda-files= variable and contribute to the agenda.

I collect capture tasks in refile.org for up to a week. These now stand out daily on my block agenda
and I usually refile them during the day. I like to keep my refile task list empty.

*** Refile Setup
:PROPERTIES:
:CUSTOM_ID: RefileSetup
:END:

To refile tasks in org you need to tell it where you want to refile things.

In my setup I let any file in =org-agenda-files= and the current file contribute to the list of
valid refile targets.

I use Helm to list the refile targets. Now when I want to refile something I do =C-c C-w= to start
the refile process, then type something to get some matching targets, then

I now exclude =DONE= state tasks as valid refile targets. This helps to keep the refile target list
to a reasonable size.

#+BEGIN_SRC emacs-lisp
;; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))

;; Use full outline paths for refile targets - we file directly with Helm
(setq org-refile-use-outline-path t)

;; Targets complete directly with Helm
(setq org-outline-path-complete-in-steps nil)

;; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

;;;; Refile settings
;; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_SRC

*** Task Refiling
:PROPERTIES:
:CUSTOM_ID: h:d53d8043-dc5a-460d-a105-d55ee02bfee9
:END:

Tasks to refile are in their own section of the block agenda. To find tasks to refile I run my
agenda view with =M-t a= and scroll down to second section of the block agenda: =Tasks to Refile=.
This view shows all tasks (even ones marked in a =done= state).

Bulk refiling in the agenda works very well for multiple tasks going to the same place. Just mark
the tasks with =m= and then =B r= to refile all of them to a new location. Occasionally I'll also
refile tasks as subtasks of the current clocking task using =C-2 C-c C-w= from the =refile.org=
file.

Refiling all of my tasks tends to take less than a minute so I normally do this a couple of times a
day.

*** Refiling Notes
:PROPERTIES:
:CUSTOM_ID: h:6380e500-1b93-43a7-9fd3-f3076d51f8d1
:END:

I keep a =* Notes= headline in most of my org-mode files. Notes have a =NOTE= tag which is created
by the capture template for notes. This allows finding notes across multiple files easily using the
agenda search functions.

Notes created by capture tasks go first to =refile.org= and are later refiled to the appropriate
project file. Some notes that are project related get filed to the appropriate project instead of
under the catchall =* NOTES= task. Generally these types of notes are specific to the project and
not generally useful -- so removing them from the notes list when the project is archived makes
sense.

*** Refiling Phone Calls and Meetings
:PROPERTIES:
:CUSTOM_ID: RefilingMeetings
:END:

Meetings are handled using capture mode. I time my calls and meetings using the capture mode
template settings to clock in and out the capture task while the phone call or meeting is in
progress.

Meeting tasks collect in =refile.org= and are later refiled to the appropriate location.

** Custom Agenda Views
:PROPERTIES:
:CUSTOM_ID: h:9a97e87a-3cf8-4a5d-af40-7c3af201ec34
:END:

I now have one block agenda view that has everything on it. I also keep separate single view agenda
commands for use on slower machines - since it takes prohibitively long to generate my block agenda.
I'm striving to simplify my layout with everything at my fingertips in a single agenda on my
workstation which is where I spend the bulk of my time.

Custom agenda views are used for:
- Single block agenda shows the following
  - overview of today
  - Finding tasks to be refiled
  - Finding stuck projects
  - Finding NEXT tasks to work on
  - Show all related tasks
  - Reviewing projects
  - Finding tasks waiting on something
  - Findings tasks to be archived
- Finding notes

If I want just today's calendar view then =F12 a= is still faster than generating the block agenda -
especially if I want to view a week or month's worth of information, or check my clocking data. In
that case the extra detail on the block agenda view is never really needed and I don't want to spend
time waiting for it to be generated.

#+BEGIN_SRC emacs-lisp
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Custom agenda command definitions
(setq
 org-agenda-custom-commands
 (quote
  (("N" "Notes" tags "NOTE"
    ((org-agenda-overriding-header "Notes")
     (org-tags-match-list-sublevels t)))
   (" " "Agenda"
    ((agenda "" nil)
     (tags "REFILE"
           ((org-agenda-overriding-header "Tasks to Refile")
            (org-tags-match-list-sublevels nil)))
     (tags-todo "-CANCELLED/!"
                ((org-agenda-overriding-header "Stuck Projects")
                 (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-HOLD-CANCELLED/!"
                ((org-agenda-overriding-header "Projects")
                 (org-agenda-skip-function 'bh/skip-non-projects)
                 (org-tags-match-list-sublevels 'indented)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-CANCELLED/!NEXT"
                ((org-agenda-overriding-header
                  (concat "Project Next Tasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function
                  'bh/skip-projects-and-habits-and-single-tasks)
                 (org-tags-match-list-sublevels t)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-with-date
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-sorting-strategy
                  '(todo-state-down effort-up category-keep))))
     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD-REVIEW/!"
                ((org-agenda-overriding-header
                  (concat "Project Subtasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function 'bh/skip-non-project-tasks)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-with-date
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD-REVIEW/!"
                ((org-agenda-overriding-header
                  (concat "Standalone Tasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function 'bh/skip-project-tasks)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-with-date
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-CANCELLED+WAITING|HOLD|REVIEW/!"
                ((org-agenda-overriding-header
                  (concat "Review and Waiting Tasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function 'bh/skip-non-tasks)
                 (org-tags-match-list-sublevels nil)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)))
     (tags "-REFILE/"
           ((org-agenda-overriding-header "Tasks to Archive")
            (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
            (org-tags-match-list-sublevels nil))))
    nil))))
#+END_SRC

After selecting a project (with =P= on any task in the agenda) the block agenda changes to show the
project and any subprojects in the Projects section. Tasks show project-related tasks that are
hidden when not narrowed to a project. This makes it easy to focus on the task at hand.

I generally work top-down on the agenda. Things with deadlines and scheduled dates (planned to work
on today or earlier) show up in the agenda at the top.

My day goes generally like this:

- Clock in (usually on the Meta task)
- Look at the agenda and make a mental note of anything important to deal with today
- Read email and news (clocked in to "Meta")
  - create notes, and tasks for things that need responses with org-capture
- Check refile tasks and respond to emails
- Look at my agenda and work on important tasks for today
  - Clock it in
  - Work on it until it is =DONE= or it gets interrupted
- Work on tasks
- Clock out for lunch and clock back in after lunch
- work on more tasks
- Refile tasks to empty the list
  - Tag tasks to be refiled with =m= collecting all tasks for the same target
  - Bulk refile the tasks to the target location with =B r=
  - Repeat (or refile individually with =C-c C-x C-f=) until all refile tasks are gone
- Clock out at the end of the work day

** What should I work on next?
:PROPERTIES:
:CUSTOM_ID: h:1242a154-66fe-47ec-923f-c53e4f6012b5
:END:

Start with deadlines and tasks scheduled today or earlier from the daily agenda view. Then move on
to tasks in the =Next Tasks= list in the block agenda view. I tend to schedule current projects to
'today' when I start work on them and they sit on my daily agenda reminding me that they need to be
completed. I normally only schedule one or two projects to the daily agenda and unschedule things
that are no longer important and don't deserve my attention today.

When I look for a new task to work on I generally hit =F12 SPC= to get
the block agenda and follow this order:

- Pick something off today's agenda
  - deadline for today (do this first - it's not late yet)
  - deadline in the past (it's already late)
  - a scheduled task for today (it's supposed to be done today)
  - a scheduled task that is still on the agenda
  - deadline that is coming up soon
- pick a NEXT task
- If you run out of items to work on look for a NEXT task in the current context
  pick a task from the Tasks list of the current project.

*** Why keep it all on the =NEXT= list?
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewsNextList
:END:

I've moved to a more GTD way of doing things. Now I just use a =NEXT= list. Only projects get tasks
with =NEXT= keywords since stuck projects initiate the need for marking or creating =NEXT= tasks. A
=NEXT= task is something that is available to work on /now/, it is the next logical step in some
project.

Having an agenda view that shows =NEXT= tasks makes it easy to pick the thing to clock. The =NEXT=
list is basically 'what is current' - any task that moves a project forward. I want to find the
thing to work on as fast as I can and actually do work on it - not spend time hunting through my org
files for the task that needs to be clocked-in.

To drop a task off the =NEXT= list simply move it back to the =TODO= state.

** Reading Email, RSS, Twitter and IRC
:PROPERTIES:
:CUSTOM_ID: h:22c574a2-c9c3-44b7-8cb2-6c65a719d145
:END:

When reading email, RSS, and conversations on IRC I just let the default task (normally =* Meta=)
clock the time I spend on these tasks. To read email I go to Mu4e and read everything in my inboxes.
If there are emails that require a response I use org-capture to create a new task with a heading of
'Respond to <user>' for each one. This automatically links to the email in the task and makes it
easy to find later. Some emails are quick to respond to and some take research and a significant
amount of time to complete. I clock each one in it's own task just in case I need that clocked time
later. The capture template for Repond To tasks is now scheduled for today so I can refile the task
to the appropriate org file without losing the task for a week.

Next, I go to my newly created tasks to be refiled from the agenda with =M-t a= and clock in an
email task and deal with it. Repeat this until all of the 'Respond to <user>' tasks are marked
=DONE=.

** Filtering
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFiltering
:END:

So many tasks, so little time. I have lots of tasks at any given time. There is so much stuff to
look at it can be daunting. This is where agenda filtering saves the day.

It's 11:53AM and I'm in work mode just before lunch. I don't want to see tasks that are not work
related right now. I also don't want to work on a big project just before lunch... so I need to find
small tasks that I can knock off the list.

How do we do this? Get a list of NEXT tasks from the block agenda and then narrow it down with
filtering. Tasks are ordered in the NEXT agenda view by estimated effort so the short tasks are
first -- just start at the top and work your way down. I can limit the displayed agenda tasks to
those estimates of 10 minutes or less with =/ + 1= and I can pick something that fits the minutes I
have left before I take off for lunch.

*** Automatically removing context based tasks with / RET
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFilteringContext
:END:

=/ RET= in the agenda is really useful. This awesome feature was added to org-mode by John Wiegley.
It removes tasks automatically by filtering based on a user-provided function.

At work I have projects I'm working on which are assigned by my manager. Sometimes priorities
changes and projects are delayed to sometime in the future. This means I need to stop working on
these immediately. I put the project task on =HOLD= and work on something else. The =/ RET= filter
removes =HOLD= tasks and subtasks (because of tag inheritance).

I have the following setup to allow =/ RET= to filter tasks based on the description above.

#+begin_src emacs-lisp
(defun bh/org-auto-exclude-function (tag)
  "Automatic task exclusion in the agenda with / RET"
  (and (cond
        ((string= tag "hold")
         t))
       (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
#+end_src

This lets me filter tasks with just =/ RET= on the agenda which removes tasks I'm not supposed to be
working on now from the list of returned results.

This helps to keep my agenda clutter-free.

** Time Clocking
:PROPERTIES:
:CUSTOM_ID: h:24165e9e-2122-44d3-ad26-aca98a7d68d3
:END:

Okay, I admit it.  I'm a clocking fanatic.

I clock everything at work. Org-mode makes this really easy. I'd rather clock too much stuff than
not enough so I find it's easier to get in the habit of clocking everything.

This makes it possible to look back at the day and see where I'm spending too much time, or not
enough time on specific projects. This also helps a lot when you need to estimate how long something
is going to take to do -- you can use your clocking data from similar tasks to help tune your
estimates so they are more accurate.

Without clocking data it's hard to tell how long something took to do after the fact.

My clocking setup basically works like this:

- Clock in to the "Meta" task
  - This clocks in a predefined task by =org-id= that is the default task to clock in whenever the
    clock normally stops
- Clock in tasks normally, and let moving to a DONE state clock out
  - clocking out automatically clocks time on a parent task or moves back to the predefined default
    task if no parent exists.
- Continue clocking whatever tasks you work on
- Clock out (stop the clock)

I'm free to change the default task multiple times during the day but with the clock moving up the
project tree on clock out I no longer need to do this. I simply have a single task that gets clocked
in when I punch-in.

If I punch-in with a prefix on a task in =Project X= then that task automatically becomes the
default task and all clocked time goes on that project until I either punch out or punch in some
other task.

My org files look like this:
=todo.org=:
#+begin_src org :exports src
,#+FILETAGS: PERSONAL
...
,* Tasks
,** Organization
:PROPERTIES:
:CLOCK_MODELINE_TOTAL: today
:ID:       eb155a82-92b2-4f25-a3c6-0304591af2f9
:END:
...
#+end_src

If I am working on some task, then I simply clock in on the task. Clocking out moves the clock up to
a parent task with a todo keyword (if any) which keeps the clock time in the same subtree. If there
is no parent task with a todo keyword then the clock moves back to the default clocking task until I
punch out or clock in some other task. When an interruption occurs I start a capture task which
keeps clocked time on the interruption task until I close it with C-c C-c.

This works really well for me.

For example, consider the following org file:

#+begin_src org :exports src
,* TODO Project A
,** NEXT TASK 1
,** TODO TASK 2
,** TODO TASK 3
,* Tasks
,** TODO Some miscellaneous task
#+end_src

I'll work on this file in the following sequence:

1. I punch in with =F9-I= at the start of my day

   That clocks in the =Organization= task by id in my =todo.org= file.

2. =F12-SPC= to review my block agenda

   Pick 'TODO Some miscellaneous task' to work on next and clock that in with =I= The clock is now
   on 'TODO Some miscellaneous task'

3. I complete that task and mark it done with =C-c C-t d=

   This stops the clock and moves it back to the =Organization= task.

4. Now I want to work on =Project A= so I clock in =Task 1=

   I work on Task 1 and mark it =DONE=. This clocks out =Task 1= and moves the clock to =Project A=.
   Now I work on =Task 2= and clock that in.

The entire time I'm working on and clocking some subtask of =Project A= all of the clock time in the
interval is applied somewhere to the =Project A= tree. When I eventually mark =Project A= done then
the clock will move back to the default organization task.

** Clock Setup
:PROPERTIES:
:CUSTOM_ID: ClockSetup
:END:

To get started we need to punch in which clocks in the default task and keeps the clock running.
This is now simply a matter of punching in the clock with =F9 I=. You can do this anywhere. Clocking
out will now clock in the parent task (if there is one with a todo keyword) or clock in the default
task if not parent exists.

Keeping the clock running when moving a subtask to a =DONE= state means clocking continues to apply
to the project task. I can pick the next task from the parent and clock that in without losing a
minute or two while I'm deciding what to work on next.

I keep clock times, state changes, and other notes in the =:LOGBOOK:= drawer.

I have the following org-mode settings for clocking:

#+begin_src emacs-lisp
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)
;; Show lot of clocking history so it's easy to pick items off the `C-c I` list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change tasks to NEXT when clocking in
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks
;; with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
;; don't use pretty things for the clocktable
(setq org-pretty-entities nil)
;; If idle for more than 15 minutes, resolve the things by asking what to do
;; with the clock time
;;(setq org-clock-idle-time 15)

(defun deos/org-clock-in ()
  (interactive)
  (org-clock-in '(4)))

(global-set-key (kbd "<f12>") #'org-clock-out)
(global-set-key (kbd "C-c O") #'org-clock-out)

(setq bh/keep-clock-running nil)

(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects. Switch projects
and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task. If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
                                        ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "a9dcbd77-e45a-44d3-82e9-80867526bd67")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+end_src

I used to clock in tasks by ID using the following function but with the new punch-in and punch-out
I don't need these as much anymore. =f9-SPC= calls =bh/clock-in-last-task= which switches the clock
back to the previously clocked task.

#+begin_src emacs-lisp
(require 'org-id)
(defun bh/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))

(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+end_src

** Clocking in
:PROPERTIES:
:CUSTOM_ID: clocking-in
:END:

When I start or continue working on a task I clock it in with any of the following:

- =C-c C-x C-i=
- =I= in the agenda
- =I= speed key on the first character of the heading line
- =f9 I= while on the task in the agenda
- =f9 I= while in the task in an org file

*** Setting a default clock task
:PROPERTIES:
:CUSTOM_ID: ClockingInDefaultTask
:END:

I have a default =** Meta= task in my todo.org file that I tend to put miscellaneous clock time on.
This is the task I clock in on when I punch in at the start of my work day with =C-c I=. While
reorganizing my org-files, reading email, clearing my inbox, and doing other planning work that
isn't for a specific project I'll clock in this task. Punching-in anywhere clocks in this
Organization task as the default task.

If I want to change the default clocking task I just visit the new task in any org buffer and clock
it in with =C-c C-x C-i=. Now this new task that collects miscellaneous clock minutes when the clock
would normally stop.

You can quickly clock in the default clocking task with =C-u C-c C-x C-i d=. Another option is to
repeatedly clock out so the clock moves up the project tree until you clock out the top-level task
and the clock moves to the default task.

*** Using the clock history to clock in old tasks
:PROPERTIES:
:CUSTOM_ID: ClockingInByClockHistory
:END:

You can use the clock history to restart clocks on old tasks you've clocked or to jump directly to a
task you have clocked previously. I use this mainly to clock in whatever got interrupted by
something.

Consider the following scenario:

- You are working on and clocking =Task A= (Organization)
- You get interrupted and switch to =Task B= (Document my use of org-mode)
- You complete =Task B= (Document my use of org-mode)
- Now you want to go back to =Task A= (Organization) again to continue

This is easy to deal with.

1. Clock in =Task A=, work on it
2. Go to =Task B= (or create a new task) and clock it in
3. When you are finished with =Task B= hit =C-u C-c C-x C-i i=

This displays a clock history selection window like the following and selects the interrupted =[i]=
entry.

*Clock history selection buffer for C-u C-c C-x C-i*
#+begin_example
Default Task
[d] todo            Meta                                  <-- Task B
The task interrupted by starting the last one
[i] todo            Organization                          <-- Task B
Current Clocking Task
[c] org             NEXT Document my use of org-mode      <-- Task A
Recent Tasks
[1] org             NEXT Document my use of org-mode      <-- Task A
[2] todo            Organization                          <-- Task B
...
[Z] org             DONE Fix default section links        <-- 35 clock task entries ago
#+end_example

** Clock Everything - Create New Tasks
:PROPERTIES:
:CUSTOM_ID: ClockEverythingWithNewTasks
:END:

In order to clock everything you need a task for everything. That's fine for planned projects but
interruptions inevitably occur and you need some place to record whatever time you spend on that
interruption.

To deal with this we create a new capture task to record the thing we are about to do. The workflow
goes something like this:

- You are clocking some task and an interruption occurs
- Create a quick capture task journal entry =C-c c j=
- Type the heading
- go do that thing (eat lunch, whatever)
- file it =C-c C-c=, this restores the clock back to the previous clocking task
- clock something else in or continue with the current clocking task

This means you can ignore the details like where this task really belongs in your org file layout
and just get on with completing the thing. Refiling a bunch of tasks later in a group when it is
convenient to refile the tasks saves time in the long run.

If it's a one-shot uninteresting task (like a coffee break) I create a capture journal entry for it
that goes to the diary.org date tree. If it's a task that actually needs to be tracked and marked
done, and applied to some project then I create a capture task instead which files it in refile.org.

** Finding tasks to clock in
:PROPERTIES:
:CUSTOM_ID: FindTasksToClockIn
:END:

To find a task to work on I use one of the following options (generally listed most frequently used
first)

- Use the clock history =C-c I=
  Go back to something I was clocking that is not finished
- Pick something off today's block agenda
  =SCHEDULED= or =DEADLINE= items that need to be done soon
- Pick something off the =NEXT= tasks agenda view
  Work on some unfinished task to move to completion
- Pick something off the other task list
- Use an agenda view with filtering to pick something to work on

Punching in on the task you select will restrict the agenda view to that project so you can focus on
just that thing for some period of time.

** Editing clock entries
:PROPERTIES:
:CUSTOM_ID: EditingClockEntries
:END:

Sometimes it is necessary to edit clock entries so they reflect reality. I find I do this for maybe
2-3 entries in a week.

Occasionally I cannot clock in a task on time because I'm away from my computer. In this case the
previous clocked task is still running and counts time for both tasks which is wrong.

I make a note of the time and then when I get back to my computer I clock in the right task and edit
the start and end times to correct the clock history.

To visit the clock line for an entry quickly use the agenda log mode. =F12 a l= shows all clock
lines for today. I use this to navigate to the appropriate clock lines quickly. F11 goes to the
current clocked task but the agenda log mode is better for finding and visiting older clock entries.

Use =F12 a l= to open the agenda in log mode and show only logged clock times. Move the cursor down
to the clock line you need to edit and hit =TAB= and you're there.

To edit a clock entry just put the cursor on the part of the date you want to edit (use the keyboard
not the mouse - since the clicking on the timestamp with the mouse goes back to the agenda for that
day) and hit the =S-<up arrow>= or =S-<down arrow>= keys to change the time.

The following setting makes time editing use discrete 5-minute intervals (no rounding) increments:

#+begin_src emacs-lisp
(setq org-time-stamp-rounding-minutes (quote (0 5)))
#+end_src

Editing the time with the shift arrow combination also updates the total for the clock line which is
a nice convenience.

I always check that I haven't created task overlaps when fixing time clock entries by viewing them
with log mode on in the agenda. There is a new view in the agenda for this -- just hit =v c= in the
daily agenda and clock gaps and overlaps are identified.

I want my clock entries to be as accurate as possible.

The following setting shows things with > 10 minute clocking gaps.

#+begin_src emacs-lisp
(setq org-agenda-clock-consistency-checks
      '(:max-duration "4:00" :min-duration 0 :max-gap 10 :gap-ok-around ("4:00")))
#+end_src

** Time reporting and tracking
:PROPERTIES:
:CUSTOM_ID: h:192ee7ba-4634-497f-b417-8e38c4d8cb51
:END:

*** Verify that the clock data is complete and correct
:PROPERTIES:
:CUSTOM_ID: h:d616c023-a1e2-4f58-9377-a4e2dc4137b4
:END:

Since I change tasks often (sometimes more than once in a minute) I use the following setting to
remove clock entries with a zero duration.

#+begin_src emacs-lisp
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
#+end_src

This setting just keeps my clocked log entries clean - only keeping clock entries that contribute to
the clock report.

To check for unclosed clock times I use the agenda-view clock check (=v c= in the agenda). This view
shows clocking gaps and overlaps in the agenda.

To check the last month's clock data I use =F12 a v m b v c= which shows a full month in the agenda,
moves to the previous month, and shows the clocked times only. It's important to remove any agenda
restriction locks and filters when checking the logs for gaps and overlaps.

The clocked-time only display in the agenda makes it easy to quickly scan down the list to see if an
entry is missing an end time. If an entry is not closed you can manually fix the clock entry based
on other clock info around that time.

**** Using clock reports to summarize time spent
:PROPERTIES:
:CUSTOM_ID: ClockReports
:END:

To get a report of time spent on tasks for =XYZ.org= you simply visit the =XYZ.org= file and run an
agenda clock report for the last month with =F12 < a v m b R=. This limits the agenda to this one
file, shows the agenda for a full month, moves to last month, and generates a clock report.

My agenda org clock report settings show 6 levels of detail with links
to the tasks.  I like wider reports than the default compact setting
so I override the =:narrow= value.

#+begin_src emacs-lisp
;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      '(:link t :maxlevel 6 :fileskip0 t :compact t :narrow 60 :score 0))
#+end_src

I have since moved to using agenda clock reports shortly after that feature was added. I find this
much more convenient. The data isn't normally for consumption by anyone else so the format of the
agenda clock report format is great for my use-case.

*** Task Estimates and column view
:PROPERTIES:
:CUSTOM_ID: TaskEstimates
:END:

Estimating how long tasks take to complete is a difficult skill to master. Org-mode makes it easy to
practice creating estimates for tasks and then clock the actual time it takes to complete.

By repeatedly estimating tasks and reviewing how your estimate relates to the actual time clocked
you can tune your estimating skills.

**** Creating a task estimate with column mode
:PROPERTIES:
:CUSTOM_ID: creating-task-estimates
:END:

I use =properties= and =column view= to do project estimates.

I set up column view globally with the following headlines

#+begin_src emacs-lisp
;; Set default column view headings: Task Priority Effort Clock_Summary
(setq org-columns-default-format "%50ITEM(Task) %2PRIORITY %10Effort(Effort){:} %10CLOCKSUM")
#+end_src

This makes column view show estimated task effort and clocked times side-by-side which is great for
reviewing your project estimates.

A property called =Effort= records the estimated amount of time a given task will take to complete.
The estimate times I use are one of:

- 10 minutes
- 30 minutes
- 1 hour
- 2 hours
- 3 hours
- 4 hours
- 5 hours
- 6 hours
- 7 hours
- 8 hours

These are stored for easy use in =column mode= in the global property =Effort_ALL=.
#+header: :tangle yes
#+begin_src emacs-lisp
;; global Effort estimate values
(setq org-global-properties
      (quote (("Effort_ALL" .
               "0:15 0:30 1:00 2:00 3:00 6:00 12:00 18:00 0:00"))))
#+end_src

To create an estimate for a task or subtree start column mode with =C-c C-x C-c= and collapse the
tree with =c=. This shows a table overlayed on top of the headlines with the task name, effort
estimate, and clocked time in columns.

With the cursor in the =Effort= column for a task you can easily set the estimated effort value with
the quick keys =1= through =9=.

After setting the effort values exit =column mode= with =q=.

**** Reviewing your estimate
:PROPERTIES:
:CUSTOM_ID: ReviewingEstimates
:END:

=Column view= is great for reviewing your estimate. This shows your estimated time value and the
total clock time for the project side-by-side.

Creating a dynamic clock table with =C-c C-x i RET= is a great way to save this project review if
you need to make it available to other applications.

=C-c C-x C-d= also provides a quick summary of clocked time for the current org file.

*** Providing progress reports to others
:PROPERTIES:
:CUSTOM_ID: ProgressReporting
:END:

When someone wants details of what I've done recently I simple generate a log report in the agenda
with tasks I've completed and state changes combined with a clock report for the appropriate time
period.

The following setting shows closed tasks and state changes in the agenda. Combined with the agenda
clock report ('R') I can quickly generate all of the details required.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed state)))
#+end_src

To generate the report I pull up the agenda for the appropriate time frame (today, yesterday, this
week, or last week) and hit the key sequence =l R= to add the log report (without clocking data
lines) and the agenda clock report at the end.

Then it's simply a matter of exporting the resulting agenda in some useful format to provide to
other people. =C-x C-w /tmp/agenda.html RET= exports to HTML and =C-x C-w /tmp/agenda.txt RET=
exports to plain text. Other formats are available but I use these two the most.

Combining this export with tag filters and =C-u R= can limit the report to exactly the tags that
people are interested in.

** Tags
:PROPERTIES:
:CUSTOM_ID: tags
:END:

Tasks can have any number of arbitrary tags.  Tags are used for:

- filtering todo lists and agenda views
- providing context for tasks
- tagging notes
- tagging meetings
- tagging tasks to be refiled
- tagging tasks in a WAITING state because a parent task is WAITING
- tagging cancelled tasks because a parent task is CANCELLED
- preventing export of some subtrees when publishing

I use tags mostly for filtering in the agenda. This means you can find tasks with a specific tag
easily across your large number of org-mode files.

Some tags are mutually exclusive. These are defined in a group so that only one of the tags can be
applied to a task at a time (disregarding tag inheritance). I use these types for tags for applying
context to a task.

Tasks are grouped together in org-files and a =#+FILETAGS:= entry applies a tag to all tasks in the
file. I use this to apply a tag to all tasks in the file. My refile.org file creates a REFILE file
tag so I can filter tasks in the agenda in the refile.org file easily.

*** Tags
:PROPERTIES:
:CUSTOM_ID: OrgTagAlist
:END:

Here are my tag definitions with associated keys for filtering in the agenda views.

The startgroup - endgroup (=@XXX=) tags are mutually exclusive - selecting one removes a similar tag
already on the task. These are the context tags - you can't be in two places at once so if a task is
marked with @work and you add @home then the @work tag is removed automagically.

The other tags =WAITING= .. =FLAGGED= are not mutually exclusive and
multiple tags can appear on a single task.  Some of those tags are
created by todo state change triggers.  The shortcut key is used to
add or remove the tag using =C-c C-q= or to apply the task for
filtering on the agenda.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            ("work" . ?w)
                            ("home" . ?h)
                            (:endgroup)
                            ("oss" . ?o)
                            ("xpack" . ?x)
                            ("book" . ?b)
                            ("support" . ?s)
                            ("docs" . ?d)
                            ("emacs" . ?e)
                            ("tech" . ?t)
                            ("noexport" . ?n)
                            ("recurring" . ?r)
                            ("WAITING" . ?W) ("HOLD" . ?H)
                            ("NOTE" . ?n) ("CANCELLED" . ?c))))

;; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src

*** Filetags
:PROPERTIES:
:CUSTOM_ID: FileTags
:END:

Filetags are a convenient way to apply one or more tags to all of the headings in a file.

Filetags look like this:

#+begin_src org :exports src
,#+FILETAGS: REFILE work
#+end_src

*** State Trigger Tags
:PROPERTIES:
:CUSTOM_ID: StateTriggerTags
:END:

The following tags are automatically added or removed by todo state triggers described previously in
[[#h:42ae1cf6-0ca0-4283-9d6f-00129c8612ce][Todo state triggers]]

- =REVIEW=
- =WAITING=
- =HOLD=
- =CANCELLED=

** Handling Notes
:PROPERTIES:
:CUSTOM_ID: HandlingNotes
:END:

Notes are little gems of knowledge that you come across during your day. They are just like tasks
except there is nothing to do (except learn and memorize the gem of knowledge). Unfortunately
there are way too many gems to remember and my head explodes just thinking about it.

org-mode to the rescue!

Often I'll find some cool feature or thing I want to remember while reading the org-mode and git
mailing lists in Gnus. To create a note I use my note capture template =C-c c n=, type a heading
for the note and =C-c C-c= to save it. The only other thing to do is to refile it (later) to the
appropriate project file.

I have an agenda view just to find notes. Notes are refiled to an appropriate project file and
task. If there is no specific task it belongs to it goes to the catchall =* Notes= task. I
generally have a catchall notes task in every project file. Notes are created with a =NOTE= tag
already applied by the capture template so I'm free to refile the note anywhere. As long as the
note is in a project file that contributes to my agenda (ie. in org-agenda-files) then I can find
the note back easily with my notes agenda view by hitting the key combination =F12 N=. I'm free to
limit the agenda view of notes using standard agenda tag filtering.

Short notes with a meaningful headline are a great way to remember technical details without the
need to actually remember anything - other than how to find them back when you need them using
=F12 N=.

Notes that are project related and not generally useful can be archived with the project and
removed from the agenda when the project is removed.

** GTD Stuff
:PROPERTIES:
:CUSTOM_ID: h:994613d4-d221-43e5-bf87-fe2be8ccd586
:END:

*** Project definition and finding stuck projects
:PROPERTIES:
:CUSTOM_ID: Projects
:END:

I'm using a new lazy project definition to mark tasks as projects. This requires zero effort from
me. Any task with a subtask using a todo keyword is a project. Period.

Projects are 'stuck' if they have no subtask with a =NEXT= todo keyword task defined.

The org-mode stuck projects agenda view lists projects that have no =NEXT= task defined. Stuck
projects show up on my block agenda and I tend to assign a =NEXT= task so the list remains empty.
This helps to keep projects moving forward.

I disable the default org-mode stuck projects agenda view with the following setting.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-stuck-projects (quote ("" nil nil "")))
#+end_src

This prevents org-mode from trying to show incorrect data if I select the default stuck project view
with =F12 #= from the agenda menu. My customized stuck projects view is part of my block agenda
displayed with =F12 SPC=.

Projects can have subprojects - and these subprojects can also be stuck. Any project that is stuck
shows up on the stuck projects list so I can indicate or create a =NEXT= task to move that project
forward.

In the following example =Stuck Project A= is stuck because it has no subtask which is =NEXT=.
=Project C= is not stuck because it has =NEXT= tasks =SubTask G= and =Task I=. =Stuck Sub Project D=
is stuck because =SubTask E= is not =NEXT= and there are no other tasks available in this project.

#+begin_src org :exports src
,* Category
,** TODO Stuck Project A
,*** TODO Task B
,** TODO Project C
,*** TODO Stuck Sub Project D
,**** TODO SubTask E
,*** TODO Sub Project F
,**** NEXT SubTask G
,**** TODO SubTask H
,*** NEXT Task I
,*** TODO Task J
#+end_src

All of the stuck projects and subprojects show up in the stuck projects list and that is my
indication to assign or create =NEXT= tasks until the stuck projects list is empty. Occasionally
some subtask is =WAITING= for something and the project is stuck until that condition is satisfied.
In this case I leave it on the stuck project list and just work on something else. This stuck
project 'bugs' me regularly when I see it on the block agenda and this prompts me to follow up on
the thing that I'm waiting for.

I have the following helper functions defined for projects which are used by agenda views.

#+begin_src emacs-lisp
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))
#+end_src

** Archiving
:PROPERTIES:
:CUSTOM_ID: h:60f1ef2e-f543-4296-8036-8dcb7b8379b3
:END:

*** Archiving Subtrees
:PROPERTIES:
:CUSTOM_ID: ArchivingSubtrees
:END:

My archiving procedure has changed. I used to move entire subtrees to a separate archive file for
the project. Task subtrees in =FILE.org= get archived to =FILE.org_archive= using the =a y= command
in the agenda.

I still archive to the same archive file as before but now I archive any done state todo task that
is old enough to archive. Tasks to archive are listed automatically at the end of my block agenda
and these are guaranteed to be old enough that I've already billed any time associated with these
tasks. This cleans up my project trees and removes the old tasks that are no longer interesting. The
archived tasks get extra property data created during the archive procedure so that it is possible
to reconstruct exactly where the archived entry came from in the rare case where you want to
unarchive something.

My archive files are huge but so far I haven't found a need to split them by year (or decade) :)

Archivable tasks show up in the last section of my block agenda when a new month starts. Any tasks
that are done but have no timestamps this month or last month (ie. they are over 30 days old) are
available to archive. Timestamps include closed dates, notes, clock data, etc - any active or
inactive timestamp in the task.

Archiving is trivial. Just mark all of the entries in the block agenda using the =m= key and then
archive them all to the appropriate place with =B $=. This normally takes less than 5 minutes once a
month.

*** Archive Setup
:PROPERTIES:
:CUSTOM_ID: ArchiveSetup
:END:

I no longer use an =ARCHIVE= property in my subtrees. Tasks can just archive normally to the
=Archived Tasks= heading in the archive file.

The following setting ensures that task states are untouched when they are archived. This makes it
possible to archive tasks that are not marked =DONE=. By default tasks are archived under the
heading =* Archived Tasks= in the archive file.

This archiving function does not keep your project trees intact. It archives done state tasks after
they are old enough to they are removed from the main org file. It should be possible to reconstruct
the original tree from the archive detail properties but I've never needed to do this yet. The
archived detail is very useful the few times a year I actually need to look for some archived data
but most of the time I just move it out of the way and keep it for historical purposes.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::* Archived Tasks")
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving"
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (if (member (org-get-todo-state) org-todo-keywords-1)
          (if (member (org-get-todo-state) org-done-keywords)
              (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    subtree-end ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or subtree-end (point-max)))
        next-headline))))
#+end_src

*** Archive Tag - Hiding Information
:PROPERTIES:
:CUSTOM_ID: ArchiveTagHidesInfo
:END:

The only time I set the ARCHIVE tag on a task is to prevent it from opening by default because it
has tons of information I don't really need to look at on a regular basis. I can open the task with
C-TAB if I need to see the gory details (like a huge table of data related to the task) but normally
I don't need that information displayed.

*** When to Archive
:PROPERTIES:
:CUSTOM_ID: WhenToArchive
:END:

Archiving monthly works well for me. I keep completed tasks around for at least 30 days before
archiving them. This keeps current clocking information for the last 30 days out of the archives.
This keeps my files that contribute to the agenda fairly current (this month, and last month, and
anything that is unfinished). I only rarely visit tasks in the archive when I need to pull up
ancient history for something.

Archiving keeps my main working files clutter-free. If I ever need the detail for the archived tasks
they are available in the appropriate archive file.

** Publishing and Exporting
:PROPERTIES:
:CUSTOM_ID: h:df364aaf-f315-4162-ba8d-f9bb280d2b87
:END:

I don't do a lot of publishing for other people but I do keep a set of private client system
documentation online. Most of this documentation is a collection of notes exported to HTML.

Everything at [[https://writequit.org]] is generated by publishing org-files. This includes the index
pages on this site.

Org-mode can export to a variety of publishing formats including (but not limited to)

- ASCII
  (plain text - but not the original org-mode file)
- HTML
- LaTeX
- Docbook
  which enables getting to lots of other formats like ODF, XML, etc
- PDF via LaTeX or Docbook

I use org-publishing combined with TRAMP to publish org-mode files to https://writequit.org so
others can see them, there's a nice built in way of doing it, so I don't even have to change
anything!

#+BEGIN_SRC emacs-lisp
;; don't show the "validate" link on org-html exports
(setq org-html-validation-link nil)

;; The big list of projects
(setq org-publish-project-alist
      `(;; Main website at http://writequit.org
        ("writequit-org"
         :base-directory ,(file-truename "~/org/writequit/")
         :base-extension "org"
         :publishing-directory "/ssh:writequit.org:~/www/"
         :publishing-function org-html-publish-to-html
         :with-toc nil
         :html-preamble t
         :html-head-extra
         "<link rel=\"alternate\" type=\"application/rss+xml\"
                href=\"https://writequit.org/posts.xml\"
                title=\"RSS feed for writequit.org\">")
        ("writequit-rss"
         :base-directory ,(file-truename  "~/org/writequit")
         :base-extension "org"
         :publishing-directory "/ssh:writequit.org:~/www/"
         :publishing-function org-rss-publish-to-rss
         :html-link-home "http://writequit.org/"
         :exclude ".*"
         :include ("posts.org")
         :html-link-use-abs-url t)

        ;; Denver emacs site
        ("denver-emacs"
         :base-directory ,(file-truename "~/org/denver-emacs-meetup/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/denver-emacs"
         :publishing-function org-html-publish-to-html
         :with-toc nil
         :html-preamble t)

        ;; Org-mode files for ~/.emacs.d/settings.org
        ("dotfiles"
         :base-directory ,(file-truename "~/.emacs.d/../")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode files for DEOS itself
        ("DEOS"
         :base-directory ,(file-truename "~/deos/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/deos/"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode files for ~/org files
        ("org-org"
         :base-directory ,(file-truename "~/org/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode for the ~/org/es files
        ("org-es-org"
         :base-directory ,(file-truename "~/org/es/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/es"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode for the ~/org/es/design files
        ("org-es-design-org"
         :base-directory ,(file-truename "~/org/es/design")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/es/design"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode for the ~/org/es/presentations files
        ("org-es-presentations-org"
         :base-directory ,(file-truename "~/org/es/presentations")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/es/presentations"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)))
#+END_SRC

Then, when I'm editing ~/org/es/feature-foo.org, I can hit =C-c C-e P f= and export the file to show
up in http://p.writequit.org/org

*** exporting to Github-flavored markdown
:PROPERTIES:
:CUSTOM_ID: ox-gfm
:END:

By and large, 90% of the exports I do are to Github's markdown. Usually to share for an issue. So
there's a nice exporter that does this for me: =ox-gfm=. While Github does support org-mode as a
file format (or in gists), it doesn't support org syntax in the body of issues or PR comments, so I
need a way to generate that syntax.

#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :ensure t
  :init
  (when (boundp 'org-export-backends)
    (customize-set-variable 'org-export-backends
                            (cons 'gfm org-export-backends))))
#+END_SRC

*** exporting to tufte html
:PROPERTIES:
:CUSTOM_ID: h:456bf59e-a548-4e53-b7dc-2c8c868029fe
:END:

I wrote [[https://github.com/dakrone/ox-tufte][a project]] to do this, and even though it's available on MELPA, it's still useful to be able
to use the development (read: local) version of it when available.

#+BEGIN_SRC emacs-lisp
(if (file-exists-p "~/src/elisp/ox-tufte")
    (progn
      (add-to-list 'load-path "~/src/elisp/ox-tufte")
      (require 'ox-tufte))
  (use-package ox-tufte
    :ensure t
    :init (require 'ox-tufte)))
#+END_SRC

** Org Babel
#+BEGIN_SRC emacs-lisp
;; org-babel stuff
(use-package ob-clojure :ensure clojure-mode)
(use-package ob-elasticsearch :ensure es-mode)

(defadvice org-babel-execute-src-block (around load-language nil activate)
  "Load language if needed"
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    ad-do-it))


;; don't run stuff automatically on export
(setq org-export-babel-evaluate nil
      ;; always enable noweb, results as code and exporting both
      org-babel-default-header-args
      (cons '(:noweb . "yes")
            (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
            (assq-delete-all :exports org-babel-default-header-args))
      ;; I don't want to be prompted on every code block evaluation
      org-confirm-babel-evaluate nil)

;; Load the languages we want to allow execution of
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (elasticsearch . t)
   (clojure . t)
   (shell . t)
   (ruby . t)
   (python . t)))

   ;; this is where Fedora installs it, YMMV
(setq org-plantuml-jar-path "~/personal/bin/plantuml.jar")
(setq plantuml-jar-path "~/personal/bin/plantuml.jar")

;; Use org.css from the :wq website for export document stylesheets
(setq org-html-head-include-default-style nil)

;; ensure this variable is defined
(unless (boundp 'org-babel-default-header-args:sh)
  (setq org-babel-default-header-args:sh '()))

;; add a default shebang header argument shell scripts
(add-to-list 'org-babel-default-header-args:sh
             '(:shebang . "#!/usr/bin/env bash"))

;; add a default shebang header argument for python
(add-to-list 'org-babel-default-header-args:python
             '(:shebang . "#!/usr/bin/env python"))

;; Make babel results blocks lowercase
(setq org-babel-results-keyword "results")

;; Automatically show images after execution
(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))
(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Don't enable this because it breaks access to emacs from my Android phone
(setq org-startup-with-inline-images nil)
#+END_SRC

Allow asynchronously executing org-babel blocks. Sometimes I run long-running
babel executions, and this allows Emacs not to hang while executing them
#+BEGIN_SRC emacs-lisp
(eval-after-load "org"
  (use-package ob-async
    :ensure t
    :disabled t
    :init (require 'ob-async)))
#+END_SRC

** Reminders
:PROPERTIES:
:CUSTOM_ID: Reminders
:END:

I use appt for reminders.  It's simple and unobtrusive -- putting
pending appointments in the status bar and beeping as 12, 9, 6, 3,
and 0 minutes before the appointment is due.

Everytime the agenda is displayed (and that's lots for me) the
appointment list is erased and rebuilt from the current agenda
details for today.  This means everytime I reschedule something, add
or remove tasks that are time related the appointment list is
automatically updated the next time I look at the agenda.

*** Reminder Setup
:PROPERTIES:
:CUSTOM_ID: ReminderSetup
:END:

#+begin_src emacs-lisp
(setq appt-message-warning-time 15
      appt-display-interval 5)

;; Erase all reminders and rebuilt reminders for today from the agenda
(defun bh/org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

;; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

;; This is at the end of my .emacs - so appointments are set up when Emacs starts
(bh/org-agenda-to-appt)

;; Activate appointments so we get notifications
(appt-activate t)

;; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)
#+end_src

*** Automatically save org-mode files
:PROPERTIES:
:CUSTOM_ID: h:594541f3-7d46-4163-a1c6-77f30e8f02d4
:END:

#+BEGIN_SRC emacs-lisp
;; Automatically save all org files every minute
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+END_SRC

** Org-mode look & feel
:PROPERTIES:
:CUSTOM_ID: h:e0386813-3caf-4ffe-b5e2-c7be2e029fe5
:END:

*** Tweaking the various org settings
:PROPERTIES:
:CUSTOM_ID: h:a6e2c173-2368-452b-b9e8-4687916381b0
:END:

#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t ;; follow links by pressing ENTER on them
      ;; syntax highlight code in source blocks
      org-src-fontify-natively t
      ;; for the leuven theme, fontify the whole heading line
      org-fontify-whole-heading-line t
      ;; force UTF-8
      org-export-coding-system 'utf-8
      ;; don't start up org files with indentation
      ;; (same as #+STARTUP: noindent)
      org-startup-indented t
      ;; *don't* hide things like = and / for emphasis markers
      org-hide-emphasis-markers nil
      ;; don't indent source code
      org-edit-src-content-indentation 0
      ;; don't adapt indentation
      org-adapt-indentation nil
      ;; preserve the indentation inside of source blocks
      org-src-preserve-indentation t
      ;; Imenu should use 3 depth instead of 2
      org-imenu-depth 3
      ;; Use inline footnotes by default
      org-footnote-define-inline t
      ;; put state change log messages into a drawer
      org-log-into-drawer t
      ;; special begin/end of line to skip tags and stars
      org-special-ctrl-a/e t
      ;; special keys for killing a headline
      org-special-ctrl-k t
      ;; don't adjust subtrees that I copy
      org-yank-adjusted-subtrees nil
      ;; try to be smart when editing hidden things
      org-catch-invisible-edits 'smart
      ;; blank lines are removed when exiting the code edit buffer
      org-src-strip-leading-and-trailing-blank-lines t
      ;; how org-src windows are set up when hitting C-c '
      org-src-window-setup 'current-window
      ;; leave this many empty lines in collapsed view
      org-cycle-separator-lines 2
      ;; export tables as CSV instead of tab-delineated
      org-table-export-default-format "orgtbl-to-csv"
      ;; use #+ATTR: if defined, or real width otherwise
      org-image-actual-width nil)

;; org-mode bindings
(define-key org-mode-map (kbd "C-c t") 'org-todo)
(define-key org-mode-map (kbd "RET") 'org-return-indent)
#+END_SRC

This makes the bullets into fancy Unicode bullets, rather than ASCII '*' values. Depending on the
theme, it may look better or worse. I also customize the list of bullets because the defaults are a
little wonky looking.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :init
  (setq org-bullets-bullet-list '("✸" "•" "◦" "•" "◦" "•" "◦"))
  (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

*** Automatically making source code background the same color as the theme
:PROPERTIES:
:CUSTOM_ID: h:a48460d4-f1d4-40c0-9627-bbc71c500db4
:END:

#+BEGIN_SRC emacs-lisp
(defun deos/org-inline-css-hook (exporter)
  "Insert custom inline css to automatically set the
   background of code to whatever theme I'm using's background"
  (when (eq exporter 'html)
    (let* ((my-pre-bg (face-background 'default))
           (my-pre-fg (face-foreground 'default)))
      ;;(setq org-html-head-include-default-style nil)
      (setq
       org-html-head-extra
       (concat
        org-html-head-extra
        (format
         "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
         my-pre-bg my-pre-fg))))))

#+END_SRC

Uncomment to automatically set background color to theme background

#+BEGIN_SRC emacs-lisp
;; (add-hook 'org-export-before-processing-hook #'deos/org-inline-css-hook)
#+END_SRC

*** Automatically adding CUSTOM_ID to headlines in a file
:PROPERTIES:
:CUSTOM_ID: h:abeafd05-8947-4ee7-9786-5d665a77873b
:END:

#+BEGIN_SRC emacs-lisp
(use-package org-id
  :init
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  (defun deos/org-custom-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker POM.
   If POM is nil, refer to the entry at point. If the entry does
   not have an CUSTOM_ID, the function returns nil. However, when
   CREATE is non nil, create a CUSTOM_ID if none is present
   already. PREFIX will be passed through to `org-id-new'. In any
   case, the CUSTOM_ID of the entry is returned."
    (interactive)
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
          id)))))

  (defun deos/org-add-ids-to-headlines-in-file ()
    "Add CUSTOM_ID properties to all headlines in the current
   file which do not already have one. Only adds ids if the
   `auto-id' option is set to `t' in the file somewhere. ie,
   ,#+OPTIONS: auto-id:t"
    (interactive)
    (save-excursion
      (widen)
      (goto-char (point-min))
      (when (re-search-forward "^#\\+OPTIONS:.*auto-id:t" (point-max) t)
        (org-map-entries (lambda () (deos/org-custom-id-get (point) 'create))))))

  ;; automatically add ids to saved org-mode headlines
  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'before-save-hook
                        (lambda ()
                          (when (and (eq major-mode 'org-mode)
                                     (eq buffer-read-only nil))
                            (deos/org-add-ids-to-headlines-in-file)))))))
#+END_SRC

*** Tuning the way Agenda looks
:PROPERTIES:
:CUSTOM_ID: h:9675c2c2-6262-44f3-bf7b-2a053daaacbf
:END:

**** Keep tasks with timestamps visible on the global todo lists
:PROPERTIES:
:CUSTOM_ID: GlobalTodoListsShowAllTasks
:END:

Tasks with dates (=SCHEDULED:=, =DEADLINE:=, or active dates) show up in the agenda when
appropriate. The block agenda view (=F12 a=) tries to keep tasks showing up only in one location
(either in the calendar or other todo lists in later sections of the block agenda.) I now rarely use
the global todo list search in org-mode (=F12 t=, =F12 m=) and when I do I'm trying to find a
specific task quickly. These lists now include _everything_ so I can just search for the item I want
and move on.

The block agenda prevents display of tasks with deadlines or scheduled dates in the future so you
can safely ignore these until the appropriate time.

#+begin_src emacs-lisp
;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)
#+end_src

**** Use the Diary for Holidays and Appointments
:PROPERTIES:
:CUSTOM_ID: DiaryForAppointments
:END:

I don't use the emacs Diary for anything other than birthdays but I like seeing the holidays on my
agenda. This helps with planning for those days when you're not supposed to be working.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-include-diary t)
(setq org-agenda-diary-file "~/diary")
#+end_src

The diary file keeps =date-tree= entries created by the capture mode 'appointment' template. I use
this also for miscellaneous tasks I want to clock during interruptions.

I don't use a =~/diary= file anymore. That is just there as a zero-length file to keep Emacs happy.
I use org-mode's diary functions instead. Inserting entries with =i= in the emacs agenda creates
date entries in the =~/git/org/diary.org= file.

I include holidays from the calendar in my =todo.org= file as follows:

#+begin_src org :exports src
,#+FILETAGS: PERSONAL
,* Appointments
  :PROPERTIES:
  :CATEGORY: Appt
  :ARCHIVE:  %s_archive::* Appointments
  :END:
,** Holidays
   :PROPERTIES:
   :Category: Holiday
   :END:
   %%(org-calendar-holiday)
,** Some other Appointment
   ...
#+end_src

I use the following setting so any time strings in the heading are shown in the agenda.

#+begin_src emacs-lisp
(setq org-agenda-insert-diary-extract-time t)
#+end_src

**** Searches include archive files
:PROPERTIES:
:CUSTOM_ID: SearchesIncludeArchiveFiles
:END:

I keep a single archive file for each of my org-mode project files. This allows me to search the
current file and the archive when I need to dig up old information from the archives.

I don't need this often but it sure is handy on the occasions that I do need it.

#+begin_src emacs-lisp
;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))
#+end_src

**** Agenda view tweaks
:PROPERTIES:
:CUSTOM_ID: AgendaViewTweaks
:END:

The following agenda customizations control
- display of repeating tasks
- display of empty dates on the agenda
- task sort order
- start the agenda weekly view with Sunday
- display of the grid
- habits at the bottom

I use a custom sorting function so that my daily agenda lists tasks in order of importance. Tasks on
the daily agenda are listed in the following order:

1. tasks with times at the top so they are hard to miss
2. entries for today (active timestamp headlines that are not scheduled or deadline tasks)
3. deadlines due today
4. late deadline tasks
5. scheduled items for today
6. pending deadlines (due soon)
7. late scheduled items
8. habits

The lisp for this isn't particularly pretty but it works.

Here are the =.emacs= settings:

#+begin_src emacs-lisp
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      '((agenda habit-down time-up priority-down
                user-defined-up effort-up category-keep)
        (todo category-up effort-up)
        (tags category-up effort-up)
        (search category-up)))

;; Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid
      '((daily today remove-match)
         (0900 1100 1300 1500 1700)
         "......"
         "----------------"))

;; Display tags farther right
(setq org-agenda-tags-column -110
      ;; keep the agenda filter until manually removed
      org-agenda-persistent-filter t
      ;; show all occurrences of repeating tasks
      org-agenda-repeating-timestamp-show-all t
      ;; always start the agenda on Monday
      org-agenda-start-on-weekday 1
      ;; show 4 agenda days
      org-agenda-span 4
      ;; Do not dim blocked tasks
      org-agenda-dim-blocked-tasks nil
      ;; include the diary in the agenda
      org-agenda-include-diary t
      ;; Compact the block agenda view
      org-agenda-compact-blocks t
      ;; Show all agenda dates - even if they are empty
      org-agenda-show-all-dates t
      ;; Overwrite the current window with the agenda
      org-agenda-window-setup 'current-window)

;;
;; Agenda sorting functions
;;
(setq org-agenda-cmp-user-defined 'bh/agenda-sort)

(defun bh/agenda-sort (a b)
  "Sorting strategy for agenda items.
Late deadlines first, then scheduled, then non-late deadlines"
  (let (result num-a num-b)
    (cond
     ;; time specific items are already sorted first by org-agenda-sorting-strategy
     ;; non-deadline and non-scheduled items next
     ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))
     ;; deadlines for today next
     ((bh/agenda-sort-test 'bh/is-due-deadline a b))
     ;; late deadlines next
     ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))
     ;; scheduled items for today next
     ((bh/agenda-sort-test 'bh/is-scheduled-today a b))
     ;; late scheduled items next
     ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))
     ;; pending deadlines last
     ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))
     ;; finally default to unsorted
     (t (setq result nil)))
    result))

(defmacro bh/agenda-sort-test (fn a b)
  "Test for agenda sort"
  `(cond
    ;; if both match leave them unsorted
    ((and (apply ,fn (list ,a))
          (apply ,fn (list ,b)))
     (setq result nil))
    ;; if a matches put a first
    ((apply ,fn (list ,a))
     (setq result -1))
    ;; otherwise if b matches put b first
    ((apply ,fn (list ,b))
     (setq result 1))
    ;; if none match leave them unsorted
    (t nil)))

(defmacro bh/agenda-sort-test-num (fn compfn a b)
  `(cond
    ((apply ,fn (list ,a))
     (setq num-a (string-to-number (match-string 1 ,a)))
     (if (apply ,fn (list ,b))
         (progn
           (setq num-b (string-to-number (match-string 1 ,b)))
           (setq result (if (apply ,compfn (list num-a num-b))
                            -1
                          1)))
       (setq result -1)))
    ((apply ,fn (list ,b))
     (setq result 1))
    (t nil)))

(defun bh/is-not-scheduled-or-deadline (date-str)
  (and (not (bh/is-deadline date-str))
       (not (bh/is-scheduled date-str))))

(defun bh/is-due-deadline (date-str)
  (string-match "Deadline:" date-str))

(defun bh/is-late-deadline (date-str)
  (string-match "\\([0-9]*\\) d\. ago:" date-str))

(defun bh/is-pending-deadline (date-str)
  (string-match "In \\([^-]*\\)d\.:" date-str))

(defun bh/is-deadline (date-str)
  (or (bh/is-due-deadline date-str)
      (bh/is-late-deadline date-str)
      (bh/is-pending-deadline date-str)))

(defun bh/is-scheduled (date-str)
  (or (bh/is-scheduled-today date-str)
      (bh/is-scheduled-late date-str)))

(defun bh/is-scheduled-today (date-str)
  (string-match "Scheduled:" date-str))

(defun bh/is-scheduled-late (date-str)
  (string-match "Sched\.\\(.*\\)x:" date-str))
#+end_src
** Presentations in Org-mode
:PROPERTIES:
:CUSTOM_ID: h:b456458e-3a2c-4a4e-9913-3e3f6d2eed7c
:END:

There are a bunch of different ways to present things

*** Presentations with beamer
:PROPERTIES:
:CUSTOM_ID: h:a40400bb-3995-4963-9e45-183f1822e172
:END:

Beamer is actually built-into org-mode, but requires a few extra libraries I wanted to document
here:

- texlive
- texlive-latex
- texlive-wrapfig
- texlive-ulem
- texlive-capt-of
- texlive-minted

#+BEGIN_SRC emacs-lisp
(use-package ox-latex
  :config
  (add-to-list 'org-latex-packages-alist '("" "minted" nil))
  (setq org-latex-listings 'minted)
  (setq
   org-latex-pdf-process
   '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))
#+END_SRC

*** Presentations with org-present
:PROPERTIES:
:CUSTOM_ID: h:8a107aa5-26dc-4db0-b868-dd937a57cb6c
:END:

A simple presentation mode for org-mode

#+BEGIN_SRC emacs-lisp
(use-package org-present
;;  :ensure t
  :defer 20
  :init
  (add-hook 'org-present-mode-hook
            (lambda ()
              (org-present-big)
              (org-display-inline-images)
              (org-present-hide-cursor)
              (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
            (lambda ()
              (org-present-small)
              (org-remove-inline-images)
              (org-present-show-cursor)
              (org-present-read-write))))
#+END_SRC

*** Presentations with =epresent=
:PROPERTIES:
:CUSTOM_ID: epresent
:END:

Right now the default keybindings are annoying

#+BEGIN_SRC emacs-lisp
(use-package epresent
  :ensure t
  :disabled t)
#+END_SRC

*** Presentations with =org-reveal=
https://github.com/yjwen/org-reveal
:PROPERTIES:
:CUSTOM_ID: h:3c34dc2c-3334-4f44-8cce-facef8541c5a
:END:

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :ensure t
  :config
  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"))
#+END_SRC

** Org Brain
:PROPERTIES:
:CUSTOM_ID: h:ffb95129-c50e-41fc-86ab-c9b5e6541dfc
:END:

TODO: document me

#+BEGIN_SRC emacs-lisp
(use-package org-brain
  :ensure t)
#+END_SRC

** Deft
I use deft to take quick notes and search through those notes

#+BEGIN_SRC emacs-lisp
(use-package deft
  :ensure t
  :bind ("C-x t" . deft)
  :config
  (setq deft-extension '("org" "txt" "tex" "text" "md")
        deft-directory "~/personal/org/deft/"
        deft-recursive t
        deft-use-filter-string-for-filename t
        deft-text-mode 'org-mode))
#+END_SRC
** More Configuration from Brent

*** 18.7.6 Searching and showing results
Org-mode's searching capabilities are really effective at finding data in your org files. C-c / /
does a regular expression search on the current file and shows matching results in a collapsed view
of the org-file.


I have org-mode show the hierarchy of tasks above the matched entries and also the immediately
following sibling task (but not all siblings) with the following settings:
#+BEGIN_SRC emacs-lisp
(setq org-show-following-heading t)
(setq org-show-hierarchy-above t)
(setq org-show-siblings (quote ((default))))
#+END_SRC
This keeps the results of the search relatively compact and mitigates accidental errors by cutting
too much data from your org file with C-k. Cutting folded data (including the …) can be really
dangerous since it cuts text (including following subtrees) which you can't see. For this reason I
always show the following headline when displaying search results.


*** 18.7.7 Editing and Special key handling
Org-mode allows special handling of the C-a, C-e, and C-k keys while editing headlines. I also use
the setting that pastes (yanks) subtrees and adjusts the levels to match the task I am pasting to.
See the docstring (C-h v org-yank-adjust-subtrees) for more details on each variable and what it
does.

I have org-special-ctrl-a/e set to enable easy access to the beginning and end of headlines. I use
M-m or C-a C-a to get to the beginning of the line so the speed commands work and C-a to give easy
access to the beginning of the heading text when I need that.

#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t)
(setq org-special-ctrl-k t)
(setq org-yank-adjusted-subtrees t)
#+END_SRC
*** Speed Commands
There's an exciting feature called org-speed-commands in the org-mode.

Speed commands allow access to frequently used commands when on the beginning of a headline -
similar to one-key agenda commands. Speed commands are user configurable and org-mode provides a
good set of default commands.


I have the following speed commands set up in addition to the defaults. I don't use priorities so I
override the default settings for the 1, 2, and 3 keys. I also disable cycling with 'c' and add 'q'
as a quick way to get back to the agenda and update the current view.
#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
(setq org-speed-commands-user (quote (("0" . ignore)
                                      ("1" . ignore)
                                      ("2" . ignore)
                                      ("3" . ignore)
                                      ("4" . ignore)
                                      ("5" . ignore)
                                      ("6" . ignore)
                                      ("7" . ignore)
                                      ("8" . ignore)
                                      ("9" . ignore)

                                      ("a" . ignore)
                                      ("d" . ignore)
                                      ("h" . bh/hide-other)
                                      ("i" progn
                                       (forward-char 1)
                                       (call-interactively 'org-insert-heading-respect-content))
                                      ("k" . org-kill-note-or-show-branches)
                                      ("l" . ignore)
                                      ("m" . ignore)
                                      ("q" . bh/show-org-agenda)
                                      ("r" . ignore)
                                      ("s" . org-save-all-org-buffers)
                                      ("w" . org-refile)
                                      ("x" . ignore)
                                      ("y" . ignore)
                                      ("z" . org-add-note)

                                      ("A" . ignore)
                                      ("B" . ignore)
                                      ("E" . ignore)
                                      ("F" . bh/restrict-to-file-or-follow)
                                      ("G" . ignore)
                                      ("H" . ignore)
                                      ("J" . org-clock-goto)
                                      ("K" . ignore)
                                      ("L" . ignore)
                                      ("M" . ignore)
                                      ("N" . bh/narrow-to-org-subtree)
                                      ("P" . bh/narrow-to-org-project)
                                      ("Q" . ignore)
                                      ("R" . ignore)
                                      ("S" . ignore)
                                      ("T" . bh/org-todo)
                                      ("U" . bh/narrow-up-one-org-level)
                                      ("V" . ignore)
                                      ("W" . bh/widen)
                                      ("X" . ignore)
                                      ("Y" . ignore)
                                      ("Z" . ignore))))

(defun bh/show-org-agenda ()
  (interactive)
  (if org-agenda-sticky
      (switch-to-buffer "*Org Agenda( )*")
    (switch-to-buffer "*Org Agenda*"))
  (delete-other-windows))
#+END_SRC

This requires setting up access to the calendar api
Follow these steps https://github.com/myuhe/org-gcal.el/blob/master/README.org
#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :init
  (use-package request-deferred
    :ensure t)
  (use-package alert
    :ensure t)
  :config
  ;; (setq org-gcal-client-id "oauth client id"
  ;;       org-gcal-client-secret "client secret"
  ;;       org-gcal-file-alist '(("calendar email" . "gcal.org")
  ;;                             ("another calendar email" . "workgcal.org")))
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package calfw
  :ensure t
  :init
  (use-package calfw-org
  :ensure t)
  (use-package calfw-ical
  :ensure t)
  :config
  (require 'calfw)
  (require 'calfw-org)
  (setq cfw:org-overwrite-default-keybinding t)
  (require 'calfw-ical)

  (defun mycalendar ()
    (interactive)
    (cfw:open-calendar-buffer
     :contents-sources
     (list
      (cfw:org-create-source "Green")  ; orgmode source
      ;;(cfw:ical-create-source "gcal" "some public ical address" "IndianRed")
      ;;(cfw:ical-create-source "gcal" "another public ical address" "IndianRed")
      )))
  (setq cfw:org-overwrite-default-keybinding t))

(use-package calfw-gcal
  :ensure t
  :config
  (require 'calfw-gcal))
#+END_SRC
* Command completion
** Ivy
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy
  :ensure t
  :demand t
  :diminish ivy-mode
  :bind
  (("C-M-z" . ivy-resume)
   ("C-x C-r" . ivy-switch-buffer)
   ("C-x o" . swiper))
   :init
   (ivy-mode 1)
   :config
   (bind-key "C-s" 'swiper)
   ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
   (setq ivy-use-virtual-buffers t)
   ;; number of result lines to display
   ;; (setq ivy-height 10)
   ;; does not count candidates
   (setq ivy-count-format "%d/%d ")
   ;; no regexp by default
   ;; (setq ivy-initial-inputs-alist nil)
   ;; configure regexp engine.
   ;; (setq ivy-re-builders-alist
   ;;       ;; allow input not in order
   ;;       '((t   . ivy--regex-ignore-order)))
#+END_SRC
** IDO
#+BEGIN_SRC emacs-lisp
(use-package ido
  :init
  (ido-mode 1)
  (use-package ido-ubiquitous
    :ensure t
    :init (ido-ubiquitous 1))
  (use-package ido-vertical-mode
    :ensure t
    :init (ido-vertical-mode 1))
  (use-package flx-ido
    :ensure t
    :init (flx-ido-mode 1))
  (use-package smex
    :ensure t
    :init
    (smex-initialize)
    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)))
  #+END_SRC
** HELM
There are many helm things. I use it a lot.

A lot of things are taken from taken from
https://tuhdo.github.io/helm-intro.html

Before we load any helm things, need to load [[https://github.com/PythonNut/helm-flx][helm-flx]] so it uses flx instead of
helm's fuzzy matching. This has to happen before helm is loaded, so it goes
here.

Now we can load the big Helm configuration. Here is a breakdown of the helm
bindings I use more frequently:

| Key     | Action                                          |
|---------+-------------------------------------------------|
| M-x     | helm meta-x                                     |
| C-x C-f | helm find files                                 |
| C-x C-d | helm browse project                             |
| C-x f   | helm projectile                                 |
| C-x C-r | helm mini (includes recentf)                    |
| C-x C-o | helm occur (search in buffer)                   |
| M-y     | helm kill ring                                  |
| C-h a   | helm appropos (search functions/vars/commands)  |
| C-h m   | helm man (man pages)                            |
| C-h SPC | helm registers                                  |
| C-x b   | helm mini                                       |
| C-h t   | helm world time (show time in different places) |
| C-x C-i | helm semantic or imenu (depending on the mode)  |


#+BEGIN_SRC emacs-lisp
(use-package helm-flx
  :ensure t
  :init
  (setq helm-flx-for-helm-find-files nil)
  (helm-flx-mode 1))

(use-package helm-config
  :ensure helm
  :demand t ;; demand it be loaded!
  :diminish helm-mode
  :bind
  (("C-M-z" . helm-resume)
   ("C-x C-f" . helm-find-files)
   ("C-x C-r" . helm-mini)
   ("C-x o" . helm-occur)
   ("M-y" . helm-show-kill-ring)
   ("C-h a" . helm-apropos)
   ("C-h m" . helm-man-woman)
   ("C-h SPC" . helm-all-mark-rings)
   ("C-x C-i" . helm-semantic-or-imenu)
   ("M-x" . helm-M-x)
   ("C-x C-b" . helm-buffers-list)
   ("C-x C-r" . helm-mini)
   ("C-x b" . helm-mini)
   ("C-x R" . helm-register)
   ("C-h t" . helm-world-time)
   ("M-g a" . helm-do-grep-ag)
   ("M-g p" . helm-do-ag-project-root)
   ("M-g G" . helm-grep-do-git-grep))
  :init
  (defvar deos/helm-display-help-buffer-regexp '("*.*Helm.*Help.**"))
  (defvar deos/helm-display-buffer-regexp
    `("*.*helm.**"
      (display-buffer-in-side-window)
      (inhibit-same-window . t)
      (side . bottom)
      (window-width . 0.6)
      (window-height . 0.4)))

  (defun deos/display-helm-window (buffer &optional resume)
    "Display the Helm window."
    (let ((display-buffer-alist
           (list deos/helm-display-help-buffer-regexp
                 ;; this or any specialized case of Helm buffer must be
                 ;; added AFTER `deos/helm-display-buffer-regexp'.
                 ;; Otherwise, `deos/helm-display-buffer-regexp' will
                 ;; be used before
                 ;; `deos/helm-display-help-buffer-regexp' and display
                 ;; configuration for normal Helm buffer is applied for helm
                 ;; help buffer, making the help buffer unable to be
                 ;; displayed.
                 deos/helm-display-buffer-regexp)))
      (helm-default-display-buffer buffer)))

  (setq helm-grep-default-command
        "grep -a -d skip %e -n%cH -e %p %f"
        ;; may be overridden if 'ggrep' is in path (see below)
        helm-grep-default-recurse-command
        "grep -a -d recurse %e -n%cH -e %p %f"
        ;; use CURL, not url-retrieve-synchronously
        helm-net-prefer-curl t
        ;; be idle for this many seconds, before updating in delayed sources.
        helm-input-idle-delay 0
        ;; wider buffer name in helm-buffers-list
        helm-buffer-max-length 28 ;; default is 20
        ;; instead of "..." use a smaller unicode ellipsis
        helm-buffers-end-truncated-string "…"
        ;; open helm buffer in another window
        ;;helm-split-window-default-side 'other
        ;; set to nil and use <C-backspace> to toggle it in helm-find-files
        helm-ff-auto-update-initial-value nil
        ;; if I change the resplit state, re-use my settings
        helm-reuse-last-window-split-state t
        ;; don't delete windows to always have 2
        helm-always-two-windows nil
        ;; open helm buffer inside current window, don't occupy whole other window
        helm-split-window-inside-p t
        ;; display using my function, not helm's (helm is too slow here)
        helm-display-function #'deos/display-helm-window
        ;; display helm in a separate frame
        ;; helm-display-function 'helm-display-buffer-in-own-frame
        ;; reuse frame so display is faster on Emacs 26+
        ;; helm-display-buffer-reuse-frame t
        ;; helm-display-buffer-width 144
        ;; helm-display-buffer-height 24
        ;; use undecorated frame on Emacs 26+
        helm-use-undecorated-frame-option t
        ;; don't check if the file exists on remote files
        helm-buffer-skip-remote-checking t
        ;; limit the number of displayed canidates
        helm-candidate-number-limit 100
        ;; don't use recentf stuff in helm-ff, I use C-x C-r for this
        helm-ff-file-name-history-use-recentf nil
        ;; move to end or beginning of source when reaching top or bottom
        ;; of source
        helm-move-to-line-cycle-in-source t
        ;; don't display the header line
        helm-display-header-line nil
        ;; verbosity for helm tramp messages
        helm-tramp-verbose 0
        ;; fuzzy matching
        helm-recentf-fuzzy-match t
        helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
        helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-semantic-fuzzy-match nil
        helm-gtags-fuzzy-match nil
        helm-imenu-fuzzy-match nil
        helm-apropos-fuzzy-match nil
        helm-lisp-fuzzy-completion nil
        helm-completion-in-region-fuzzy-match nil
        ;; autoresize to 25 rows
        helm-autoresize-min-height 25
        helm-autoresize-max-height 25
        ;; Here are the things helm-mini shows, I add `helm-source-bookmarks'
        ;; here to the regular default list
        helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-recentf
                                    helm-source-bookmarks
                                    helm-source-buffer-not-found)
        ;; Reduce the list of things for helm-apropos
        helm-apropos-function-list '(helm-def-source--emacs-commands
                                     helm-def-source--emacs-functions
                                     helm-def-source--emacs-variables
                                     helm-def-source--emacs-faces))
  :config
  (use-package helm-files
    :config (setq helm-ff-file-compressed-list '("gz" "bz2" "zip" "tgz" "xz" "txz")))
  (use-package helm-buffers
    :config
    (add-to-list 'helm-boring-buffer-regexp-list "^TAGS$")
    (add-to-list 'helm-boring-buffer-regexp-list "git-gutter:diff"))
  (use-package helm-mode
    :diminish helm-mode
    :init
    (add-hook 'after-init-hook #'helm-mode)
    (add-hook 'after-init-hook #'helm-autoresize-mode)
    (add-hook 'after-init-hook #'helm-adaptive-mode)
    (add-hook 'after-init-hook #'helm-popup-tip-mode))
  (use-package helm-sys
    :init (add-hook 'after-init-hook #'helm-top-poll-mode))
  (use-package helm-grep
    :config
    (setq helm-grep-truncate-lines nil)
    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
    (when (executable-find "rg")
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s"
            helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))))
  (use-package helm-man)
  (use-package helm-misc)
  (use-package helm-elisp)
  (use-package helm-imenu)
  (use-package helm-semantic)
  (use-package helm-ring)
  (use-package smex :ensure t)
  (use-package helm-smex :ensure t)
  (use-package helm-bookmark
    :bind ("C-x M-b" . helm-bookmarks))
  (use-package projectile-ripgrep :ensure t)
  (use-package helm-projectile
    :ensure t
    :demand t ;; demand it be loaded!
    :bind (:map projectile-command-map
                ("b" . helm-projectile-switch-to-buffer)
                ("d" . helm-projectile-find-dir)
                ("f" . helm-projectile-find-file)
                ("p" . helm-projectile-switch-project)
                ("s s" . helm-projectile-ag)
                ("s r" . projectile-ripgrep))
    :init
    (setq projectile-switch-project-action 'helm-projectile)
    (helm-projectile-on)
    (helm-delete-action-from-source
     "Grep in projects `C-s'"
     helm-source-projectile-projects)
    (helm-add-action-to-source
     "Ag in project C-s'"
     'helm-do-ag helm-source-projectile-projects)
    (bind-key "C-s" (defun helm-projectile-do-ag ()
                      (interactive)
                      (helm-exit-and-execute-action #'helm-do-ag))
              helm-projectile-projects-map)
    (global-set-key (kbd "C-x f") #'helm-projectile-find-file)
    :config
    (setq-default helm-truncate-lines t
                  helm-projectile-truncate-lines t))

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  ;; Use popwin for helm buffers, otherwise I can't get helm to display the way
  ;; I want (at the bottom, without deleting windows)
  ;; (when (fboundp 'popwin:special-display-config)
  ;;   (push '("^\*helm.+\*$" :regexp t :height 20) popwin:special-display-config)
  ;;   (setq helm-display-function 'popwin:pop-to-buffer))

  ;; Shows helm input in the header instead of the footer
  (setq helm-echo-input-in-header-line t)
  (defun helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)

  ;; Files that helm should know how to open
  (setq helm-external-programs-associations
        '(("avi"  . "mpv")
          ("part" . "mpv")
          ("mkv"  . "mpv")
          ("webm" . "mpv")
          ("mp4"  . "mpv")))

  ;; List of times to show in helm-world-time
  (setq display-time-world-list '(("PST8PDT" "Mountain View")
                                  ("America/Denver" "Denver")
                                  ("EST5EDT" "Boston")
                                  ("UTC" "UTC")
                                  ("Europe/London" "London")
                                  ("Europe/Amsterdam" "Amsterdam")
                                  ("Asia/Bangkok" "Bangkok")
                                  ("Asia/Tokyo" "Tokyo")
                                  ("Australia/Sydney" "Sydney")))

  ;; rebind tab to do persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)

  (define-key helm-map (kbd "C-p")   'helm-previous-line)
  (define-key helm-map (kbd "C-n")   'helm-next-line)
  (define-key helm-map (kbd "C-M-n") 'helm-next-source)
  (define-key helm-map (kbd "C-M-p") 'helm-previous-source)
  (define-key helm-map (kbd "M-N")   'helm-next-source)
  (define-key helm-map (kbd "M-P")   'helm-previous-source)

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ;; ggrep is gnu grep on OSX
  (when (executable-find "ggrep")
    (setq helm-grep-default-command
          "ggrep -a -d skip %e -n%cH -e %p %f"
          helm-grep-default-recurse-command
          "ggrep -a -d recurse %e -n%cH -e %p %f"))

  ;; helm-mini instead of recentf
  (define-key 'help-command (kbd "C-f") 'helm-apropos)
  (define-key 'help-command (kbd "r") 'helm-info-emacs)

  (defvar helm-httpstatus-source
    '((name . "HTTP STATUS")
      (candidates . (("100 Continue") ("101 Switching Protocols")
                     ("102 Processing") ("200 OK")
                     ("201 Created") ("202 Accepted")
                     ("203 Non-Authoritative Information") ("204 No Content")
                     ("205 Reset Content") ("206 Partial Content")
                     ("207 Multi-Status") ("208 Already Reported")
                     ("300 Multiple Choices") ("301 Moved Permanently")
                     ("302 Found") ("303 See Other")
                     ("304 Not Modified") ("305 Use Proxy")
                     ("307 Temporary Redirect") ("400 Bad Request")
                     ("401 Unauthorized") ("402 Payment Required")
                     ("403 Forbidden") ("404 Not Found")
                     ("405 Method Not Allowed") ("406 Not Acceptable")
                     ("407 Proxy Authentication Required") ("408 Request Timeout")
                     ("409 Conflict") ("410 Gone")
                     ("411 Length Required") ("412 Precondition Failed")
                     ("413 Request Entity Too Large")
                     ("414 Request-URI Too Large")
                     ("415 Unsupported Media Type")
                     ("416 Request Range Not Satisfiable")
                     ("417 Expectation Failed") ("418 I'm a teapot")
                     ("421 Misdirected Request")
                     ("422 Unprocessable Entity") ("423 Locked")
                     ("424 Failed Dependency") ("425 No code")
                     ("426 Upgrade Required") ("428 Precondition Required")
                     ("429 Too Many Requests")
                     ("431 Request Header Fields Too Large")
                     ("449 Retry with") ("500 Internal Server Error")
                     ("501 Not Implemented") ("502 Bad Gateway")
                     ("503 Service Unavailable") ("504 Gateway Timeout")
                     ("505 HTTP Version Not Supported")
                     ("506 Variant Also Negotiates")
                     ("507 Insufficient Storage") ("509 Bandwidth Limit Exceeded")
                     ("510 Not Extended")
                     ("511 Network Authentication Required")))
      (action . message)))

  (defvar helm-clj-http-source
    '((name . "clj-http options")
      (candidates
       .
       ((":accept - keyword for content type to accept")
        (":as - output coercion: :json, :json-string-keys, :clojure, :stream, :auto or string")
        (":basic-auth - string or vector of basic auth creds")
        (":body - body of request")
        (":body-encoding - encoding type for body string")
        (":client-params - apache http client params")
        (":coerce - when to coerce response body: :always, :unexceptional, :exceptional")
        (":conn-timeout - timeout for connection")
        (":connection-manager - connection pooling manager")
        (":content-type - content-type for request")
        (":cookie-store - CookieStore object to store/retrieve cookies")
        (":cookies - map of cookie name to cookie map")
        (":debug - boolean to print info to stdout")
        (":debug-body - boolean to print body debug info to stdout")
        (":decode-body-headers - automatically decode body headers")
        (":decompress-body - whether to decompress body automatically")
        (":digest-auth - vector of digest authentication")
        (":follow-redirects - boolean whether to follow HTTP redirects")
        (":form-params - map of form parameters to send")
        (":headers - map of headers")
        (":ignore-unknown-host? - whether to ignore inability to resolve host")
        (":insecure? - boolean whether to accept invalid SSL certs")
        (":json-opts - map of json options to be used for form params")
        (":keystore - file path to SSL keystore")
        (":keystore-pass - password for keystore")
        (":keystore-type - type of SSL keystore")
        (":length - manually specified length of body")
        (":max-redirects - maximum number of redirects to follow")
        (":mime-subtype - type for multipart mime parts")
        (":multipart - vector of multipart options")
        (":oauth-token - oauth token")
        (":proxy-host - hostname of proxy server")
        (":proxy-ignore-hosts - set of hosts to ignore for proxy")
        (":proxy-post - port for proxy server")
        (":query-params - map of query parameters")
        (":raw-headers - boolean whether to return raw headers with response")
        (":response-interceptor - function called for each redirect")
        (":retry-handler - function to handle HTTP retries on IOException")
        (":save-request? - boolean to return original request with response")
        (":socket-timeout - timeout for establishing socket")
        (":throw-entire-message? - whether to throw the entire response on errors")
        (":throw-exceptions - boolean whether to throw exceptions on 5xx & 4xx")
        (":trust-store - file path to trust store")
        (":trust-store-pass - password for trust store")
        (":trust-store-type - type of trust store")))
      (action . message)))

  (defun helm-httpstatus ()
    (interactive)
    (helm-other-buffer '(helm-httpstatus-source) "*helm httpstatus*"))

  (defun helm-clj-http ()
    (interactive)
    (helm-other-buffer '(helm-clj-http-source) "*helm clj-http flags*")))

  (use-package helm-ls-git
    :ensure t
    :bind ("C-x C-d" . helm-browse-project))

  (use-package helm-ls-hg
    :ensure t)

    (use-package helm-ag
  :ensure t)

(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop))
  :config
  ;; When doing isearch, hand the word over to helm-swoop
  (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t
        ;; If this value is t, split window inside the current window
        helm-swoop-split-with-multiple-windows t
        ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
        helm-swoop-split-direction 'split-window-vertically
        ;; don't auto select the thing at point
        helm-swoop-pre-input-function (lambda () "")
        ;; If nil, you can slightly boost invoke speed in exchange for text
        ;; color. If I want pretty I'll use helm-occur since it keeps colors
        helm-swoop-speed-or-color nil))
(use-package helm-descbinds
  :ensure t
  :bind ("C-h b" . helm-descbinds)
  :init (fset 'describe-bindings 'helm-descbinds))

(use-package helm-flyspell
  :ensure t
  :after helm
  :bind (:map flyspell-mode-map
              ("C-;" . helm-flyspell-correct)))

(use-package projectile
  :ensure t
  :defer 5
  :commands projectile-global-mode
  :diminish projectile-mode
  :init (add-hook 'after-init-hook #'projectile-global-mode)
  :config
  (bind-key "C-c p b" #'projectile-switch-to-buffer #'projectile-command-map)
  (bind-key "C-c p K" #'projectile-kill-buffers #'projectile-command-map)

  ;; global ignores
  (add-to-list 'projectile-globally-ignored-files ".tern-port")
  (add-to-list 'projectile-globally-ignored-files "GTAGS")
  (add-to-list 'projectile-globally-ignored-files "GPATH")
  (add-to-list 'projectile-globally-ignored-files "GRTAGS")
  (add-to-list 'projectile-globally-ignored-files "GSYMS")
  (add-to-list 'projectile-globally-ignored-files ".DS_Store")
  ;; always ignore .class files
  (add-to-list 'projectile-globally-ignored-file-suffixes ".class")
  (use-package helm-projectile
    :ensure t
    :init
    (use-package grep) ;; required for helm-ag to work properly
    (setq projectile-completion-system 'helm)
    ;; no fuzziness for projectile-helm
    (setq helm-projectile-fuzzy-match nil)
    (helm-projectile-on)
    :config
    ;; Add multi-compile to the mix for projects
    (defun helm-projectile-multi-compile-project (dir)
      "A Helm action to invoke multi-compile on a project.
`dir' is the project root."
      (let ((default-directory dir))
        (multi-compile-run)))

    ;; Add new projectile binding for multi-compile
    (helm-projectile-define-key helm-projectile-projects-map
      (kbd "M-m")  #'helm-projectile-multi-compile-project)))

              #+END_SRC
* Completion
** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish
    :config
    (add-hook 'after-init-hook 'global-company-mode)

    (setq company-idle-delay t)

    (use-package company-anaconda
      :ensure t
      :config
      (add-to-list 'company-backends 'company-anaconda)))

(setq company-dabbrev-downcase nil)
#+END_SRC
** Yasnippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode)
    (global-set-key (kbd "M-/") 'company-yasnippet))
#+END_SRC

* Writing
** Skeleton Code
:PROPERTIES:
:CUSTOM_ID: skeletons
:END:
Skeletons are kind of like yasnippet, but they don't mess with my keybindings
all over the place and take forever to load ಠ_ಠ

#+BEGIN_SRC emacs-lisp
(require 'skeleton)

(define-skeleton deos/org-header
  "Insert a standard header for org-mode files"
  "Title: "
  "#+TITLE: " str \n
  "#+AUTHOR: " (user-full-name) \n
  "#+EMAIL: " user-mail-address \n
  "#+SETUPFILE: ~/deos/setupfiles/emacs.setup

| *Author* | {{{author}}} ({{{email}}})    |
| *Date*   | {{{time(%Y-%m-%d %H:%M:%S)}}} |

,* Introduction
" \n)

(define-skeleton deos/org-wrap-elisp
  "Wrap text with #+BEGIN_SRC / #+END_SRC for the emacs-lisp code"
  nil
  > "#+BEGIN_SRC emacs-lisp :tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

  (define-skeleton deos/org-wrap-source
  "Wrap text with #+BEGIN_SRC / #+END_SRC for a code type"
  "Language: "
  > "#+BEGIN_SRC " str ":tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

  (define-skeleton deos/es-make-index
  "Insert boilerplate to create an index with `es-mode' syntax"
  "Index name: "
  "POST /" str \n
  "{" \n
  > "\"settings\": {" \n
  > "\"index\": {" \n
  > "\"number_of_shards\": 1," \n
  > "\"number_of_replicas\": 0" \n
  > "}" \n ;; index
  > "}," \n ;; settings
  > "\"mappings\": {" \n
  > "\"" (skeleton-read "Type name: ") "\": {" \n
  > "\"properties\": {" \n
  > "\"body\": {" \n
  > "\"type\": \"string\"" \n
  > "}" \n ;; body
  > "}" \n ;; properties
  > "}" \n ;; type
  > "}" \n ;; mappings
  > "}" \n)

  (define-skeleton deos/java-try-catch
  "Wrap code in a Java try/catch"
  nil
  > "try {" \n
  > _
  > "} catch (Exception e) {" \n
  > "throw e;" \n
  > "}" \n)
#+END_SRC

And now let's add a hydra for the skeletons

#+BEGIN_SRC emacs-lisp
(defhydra deos/hydra-skeleton nil
  "Insert Skeleton"
  ("e" deos/org-wrap-elisp "Wrap as elisp" :exit t)
  ("s" deos/org-wrap-source "Wrap as source" :exit t)
  ("i" deos/es-make-index "ES Index" :exit t)
  ("h" deos/org-header "Org Header" :exit t)
  ("t" deos/java-try-catch "Wrap with try/catch" :exit t))
#+END_SRC
** Writegood mode
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :ensure t
  :bind ("C-c w" . writegood-mode)
  :config
  (add-to-list 'writegood-weasel-words "actionable"))
#+END_SRC
** Markup
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode (("\\`README\\.md\\'" . gfm-mode)
         ("github\\.com.*\\.txt\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-enable-wiki-links t
        markdown-italic-underscore t
        markdown-make-gfm-checkboxes-buttons t
        markdown-gfm-additional-languages '("sh"))
  (add-hook 'markdown-mode-hook #'flyspell-mode))
#+END_SRC
** Asciidocs
#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)
#+END_SRC
** Thesaurus
#+BEGIN_SRC emacs-lisp
(use-package synosaurus
  :ensure t
  :init
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode))
#+END_SRC
** Fill me in
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :config
  ;; fix for org -> html export
  (defun fci-mode-override-advice (&rest args))
  (use-package org)
  (advice-add 'org-html-fontify-code :around
              (lambda (fun &rest args)
                (advice-add 'fci-mode :override #'fci-mode-override-advice)
                (let ((result (apply fun args)))
                  (advice-remove 'fci-mode #'fci-mode-override-advice)
                  result)))
  (defvar deos/fci-disabled nil)
  (make-variable-buffer-local 'deos/fci-disabled)
   ;; Add a hook that disables fci if enabled when the window changes and it
  ;; isn't wide enough to display it.
  (defun deos/maybe-disable-fci ()
    (interactive)
    ;; Disable FCI if necessary
    (when (and fci-mode
               (< (window-width) (or fci-rule-column fill-column)))
      (fci-mode -1)
      (setq-local deos/fci-disabled t))
    ;; Enable FCI if necessary
    (when (and deos/fci-disabled
               (eq fci-mode nil)
               (> (window-width) (or fci-rule-column fill-column)))
      (fci-mode 1)
      (setq-local deos/fci-disabled nil)))

  (defun deos/add-fci-disabling-hook ()
    (interactive)
    (add-hook 'window-configuration-change-hook
              #'deos/maybe-disable-fci))
  (add-hook 'prog-mode-hook #'deos/add-fci-disabling-hook))
#+END_SRC
** Whitespace
#+BEGIN_SRC emacs-lisp
;; A subset, only training lines and whitespace
(setq whitespace-style '(spaces tabs newline space-mark tab-mark newline-mark))

(setq whitespace-display-mappings
      ;; all numbers are Unicode codepoint in decimal.
      '(;;(space-mark 32 [183] [46])
        ;; (newline-mark 10 [172 10]) ;; the paragraph sign
        (newline-mark 10 [172 10]) ;; mathematical "not"
        (tab-mark 9 [187 9] [92 9])))

(defun deos/turn-on-whitespace-mode ()
  (interactive)
  (setq-local whitespace-line-column fill-column)
  (whitespace-mode +1)
  (diminish 'whitespace-mode)
  (whitespace-newline-mode 1)
  (diminish 'whitespace-newline-mode))

(add-hook 'prog-mode-hook #'deos/turn-on-whitespace-mode)
#+END_SRC

Turn off whitespace mode when exporting org documents
#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (advice-add 'org-html-fontify-code :around
              (lambda (fun &rest args)
                (whitespace-mode -1)
                (let ((result  (apply fun args)))
                  (whitespace-mode +1)
                  result))))
#+END_SRC

** Highlight indentions
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :init
  (setq highlight-indent-guides-method 'character)
  (add-hook 'prog-mode-hook #'highlight-indent-guides-mode))
#+END_SRC
* Coding
** Flycheck
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :config
      (add-hook 'after-init-hook 'global-flycheck-mode)
      (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
(add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
      (add-to-list 'flycheck-checkers 'proselint)
      (setq-default flycheck-highlighting-mode 'lines)
      ;; Define fringe indicator / warning levels
      (define-fringe-bitmap 'flycheck-fringe-bitmap-ball
        (vector #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00011100
                #b00111110
                #b00111110
                #b00111110
                #b00011100
                #b00000000
                #b00000000
                #b00000000
                #b00000000
                #b00000000))
      (flycheck-define-error-level 'error
        :severity 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap 'flycheck-fringe-bitmap-ball
        :fringe-face 'flycheck-fringe-error)
      (flycheck-define-error-level 'warning
        :severity 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap 'flycheck-fringe-bitmap-ball
        :fringe-face 'flycheck-fringe-warning)
      (flycheck-define-error-level 'info
        :severity 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap 'flycheck-fringe-bitmap-ball
        :fringe-face 'flycheck-fringe-info))
#+END_SRC
** Proselint
Proselint is a cool flycheck checker for the English language, which helps me
right more gooder
#+BEGIN_SRC emacs-lisp
(flycheck-define-checker proselint
  "A linter for prose."
  :command ("proselint" source-inplace)
  :error-patterns
  ((warning line-start (file-name) ":" line ":" column ": "
            (id (one-or-more (not (any " "))))
            (message (one-or-more not-newline)
                     (zero-or-more "\n" (any " ") (one-or-more not-newline)))
            line-end))
  :modes (text-mode markdown-mode gfm-mode org-mode))
#+END_SRC
** Smartparens
Help keep those parenthesys balanced

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'smartparens-mode))
#+END_SRC

** Delimiters
Show me the parenthesys
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

** Highlight colors
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :diminish rainbow-mode
    :config
    (setq rainbow-x-colors nil)
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :ensure t)
#+END_SRC

** Add them parenth pairs
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'electric-pair-mode)
#+END_SRC

** A dash of smartness
#+BEGIN_SRC emacs-lisp
  (use-package smart-dash
    :ensure t
    :config
    (add-hook 'python-mode-hook 'smart-dash-mode))
#+END_SRC

** Eshell Popup
Here's a neat function that [[https://github.com/dakrone/eos][dakrone]] wrote that will find an associated eshell to a project and pop
it up at the bottom of the screen
#+BEGIN_SRC emacs-lisp
(defun deos/popup-project-eshell ()
  (interactive)
  (when (projectile-project-p)
    (save-excursion
      (let ((project (projectile-project-name))
            (candidate nil)
            (i 0)
            (buffers (buffer-list))
            (found-p nil))
        (while (and (not candidate)
                    (<= i (length buffers)))
          (let ((buffer (elt buffers i)))
            (with-current-buffer buffer
              (when (and (eq major-mode 'eshell-mode)
                         (equal (projectile-project-name) project))
                (setq candidate buffer))))
          (setq i (+ i 1)))
        (if candidate
            (popwin:popup-buffer-tail candidate)
          (message "No projectile eshell buffer found"))))))

(global-set-key (kbd "C-x M-B") #'deos/popup-project-eshell)
#+END_SRC

** Code Style
I like the google code style
#+BEGIN_SRC emacs-lisp
(use-package google-c-style
  :ensure t)
#+END_SRC

** Dumb-jump
For jumping dumbly
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
    :ensure t
    :diminish dumb-jump-mode
    :bind (("C-M-g" . dumb-jump-go)
           ("C-M-p" . dumb-jump-back)
           ("C-M-q" . dumb-jump-quick-look)))

#+END_SRC
* Shell
Things for running shells inside of emacs



Sets up the =with-editor= package so things that invoke =$EDITOR= will use the
current emacs if I'm already inside of emacs

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :ensure t
  :init
  (progn
    (add-hook 'shell-mode-hook  'with-editor-export-editor)
    (add-hook 'eshell-mode-hook 'with-editor-export-editor)))
#+END_SRC

Also, let's set up any SSH or GPG keychains that the [[http://www.funtoo.org/Keychain][Keychain]] tool has set up
for us (which I use at the shell)

#+BEGIN_SRC emacs-lisp
(use-package keychain-environment
  :ensure t
  :init
  (add-hook 'after-init-hook #'keychain-refresh-environment))
#+END_SRC

First, Emacs doesn't handle =less= well, so use =cat= instead for the shell
pager:

#+BEGIN_SRC emacs-lisp
(setenv "PAGER" "cat")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq comint-scroll-to-bottom-on-input t ;; always insert at the bottom
      ;; always add output at the bottom
      comint-scroll-to-bottom-on-output nil
      ;; scroll to show max possible output
      comint-scroll-show-maximum-output t
      ;; no duplicates in command history
      comint-input-ignoredups t
      ;; insert space/slash after file completion
      comint-completion-addsuffix t
      ;; if this is t, it breaks shell-command
      comint-prompt-read-only nil)

(defun deos/shell-kill-buffer-sentinel (process event)
  (when (memq (process-status process) '(exit signal))
    (kill-buffer)))

(defun deos/kill-process-buffer-on-exit ()
  (set-process-sentinel (get-buffer-process (current-buffer))
                        #'deos/shell-kill-buffer-sentinel))

(dolist (hook '(ielm-mode-hook term-exec-hook comint-exec-hook))
  (add-hook hook 'deos/kill-process-buffer-on-exit))

(defun set-scroll-conservatively ()
  "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
  (set (make-local-variable 'scroll-conservatively) 10))

(defadvice comint-previous-matching-input
    (around suppress-history-item-messages activate)
  "Suppress the annoying 'History item : NNN' messages from shell history isearch.
If this isn't enough, try the same thing with
comint-replace-by-expanded-history-before-point."
  (let ((old-message (symbol-function 'message)))
    (unwind-protect
        (progn (fset 'message 'ignore) ad-do-it)
      (fset 'message old-message))))

(add-hook 'shell-mode-hook #'set-scroll-conservatively)
;; truncate buffers continuously
(add-hook 'comint-output-filter-functions #'comint-truncate-buffer)
;; interpret and use ansi color codes in shell output windows
(add-hook 'shell-mode-hook #'ansi-color-for-comint-mode-on)
#+END_SRC

* Eshell
Eshell is great for most shell things. It's a great ZSH replacement. Regardless,
it needs some tweaks in order to be fully useful.

First, a function to be called when eshell-mode is entered

#+BEGIN_SRC emacs-lisp
(defun deos/setup-eshell ()
  (interactive)
  ;; turn off semantic-mode in eshell buffers
  (semantic-mode -1)
  ;; turn off hl-line-mode
  (when (fboundp 'deos/turn-off-hl-line)
    (deos/turn-off-hl-line))
  (local-set-key (kbd "M-P") 'eshell-previous-prompt)
  (local-set-key (kbd "M-N") 'eshell-next-prompt)
  (local-set-key (kbd "M-R") 'eshell-previous-matching-input))
#+END_SRC

Add a nice helper to sudo-edit a file

#+BEGIN_SRC emacs-lisp
(defun sudoec (file)
  (interactive)
  (find-file (concat "/sudo::" (expand-file-name file))))
#+END_SRC

Also, after eshell has loaded its options, let's load some other niceties like
completion, prompt and term settings:

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :commands (eshell eshell-command)
  :bind ("C-c m" . eshell)
  :init
  (require 'em-smart)
  (setq eshell-glob-case-insensitive nil
        eshell-error-if-no-glob nil
        eshell-scroll-to-bottom-on-input nil
        eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t)
  ;; Initialize "smart" mode
  ;;(add-hook 'eshell-mode-hook #'eshell-smart-initialize)
  :config
  (defalias 'emacs 'find-file)
  (defalias 'hff 'hexl-find-file)
  (defalias 'sec 'sudoec)
  (setenv "PAGER" "cat")
  (use-package esh-opt
    :config
    (use-package em-cmpl)
    (use-package em-prompt
      :init
      (with-eval-after-load 'em-prompt
        (defun eshell-next-prompt (n)
          "Move to end of Nth next prompt in the buffer. See `eshell-prompt-regexp'."
          (interactive "p")
          (re-search-forward eshell-prompt-regexp nil t n)
          (when eshell-highlight-prompt
          (while (not (get-text-property (line-beginning-position) 'read-only))
            (re-search-forward eshell-prompt-regexp nil t n)))
          (eshell-skip-prompt))

        (defun eshell-previous-prompt (n)
          "Move to end of Nth previous prompt in the buffer. See `eshell-prompt-regexp'."
          (interactive "p")
          (backward-char)
          (eshell-next-prompt (- n)))))
    (use-package em-term)

    ;; Shared history.
    (defvar eshell-history-global-ring nil
      "The history ring shared across Eshell sessions.")

    ;; (defun eshell-hist-use-global-history ()
    ;;   "Make Eshell history shared across different sessions."
    ;;   (unless eshell-history-global-ring
    ;;     (let (eshell-history-ring)
    ;;       (when eshell-history-file-name
    ;;         (eshell-read-history nil t))
    ;;       (setq eshell-history-global-ring eshell-history-ring))
    ;;     (unless eshell-history-ring (setq eshell-history-global-ring (make-ring eshell-history-size))))
    ;;   (setq eshell-history-ring eshell-history-global-ring))
    ;; (add-hook 'eshell-mode-hook 'eshell-hist-use-global-history)

    (setq eshell-cmpl-cycle-completions nil
          ;; auto truncate after 12k lines
          eshell-buffer-maximum-lines 12000
          ;; history size
          eshell-history-size 500
          ;; buffer shorthand -> echo foo > #'buffer
          eshell-buffer-shorthand t
          ;; my prompt is easy enough to see
          eshell-highlight-prompt nil
          ;; treat 'echo' like shell echo
          eshell-plain-echo-behavior t
          ;; add -lh to the `ls' flags
          eshell-ls-initial-args "-lh")

    ;; Visual commands
    (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                                   "ncftp" "pine" "tin" "trn" "elm" "vim"
                                   "nmtui" "alsamixer" "htop" "el" "elinks"
                                   "ssh" "nethack" "dtop" "dstat"))
    (setq eshell-visual-subcommands '(("git" "log" "diff" "show")
                                      ("vagrant" "ssh")))

    (defun deos/truncate-eshell-buffers ()
      "Truncates all eshell buffers"
      (interactive)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (eq major-mode 'eshell-mode)
            (eshell-truncate-buffer)))))

    ;; After being idle for 5 seconds, truncate all the eshell-buffers if
    ;; needed. If this needs to be canceled, you can run `(cancel-timer
    ;; deos/eshell-truncate-timer)'
    (setq deos/eshell-truncate-timer
          (run-with-idle-timer 5 t #'deos/truncate-eshell-buffers))

    (defun eshell/cds ()
      "Change directory to the project's root."
      (eshell/cd (locate-dominating-file default-directory ".git")))

    (defalias 'eshell/l 'eshell/ls)
    (defalias 'eshell/ll 'eshell/ls)

    (defun eshell/ec (pattern)
      (if (stringp pattern)
          (find-file pattern)
        (mapc #'find-file (mapcar #'expand-file-name pattern))))
    (defalias 'e 'eshell/ec)
    (defalias 'ee 'find-file-other-window)

    (defun eshell/d (&rest args)
      (dired (pop args) "."))

    (defun eshell/clear ()
      "Clear the eshell buffer"
      (interactive)
      (let ((eshell-buffer-maximum-lines 0))
        (eshell-truncate-buffer)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (eshell-send-input)))))

  (defun eshell/icat (&rest args)
    "Display image(s)."
    (let ((elems (eshell-flatten-list args)))
      (while elems
        (eshell-printn
         (propertize " "
                     'display (create-image (expand-file-name (car elems)))))
        (setq elems (cdr elems))))
    nil)

  (add-hook 'eshell-mode-hook #'deos/setup-eshell)

  ;; See eshell-prompt-function below
  (setq eshell-prompt-regexp "^[^#$\n]* [#$] ")

  ;; So the history vars are defined
  (require 'em-hist)
  (if (boundp 'eshell-save-history-on-exit)
      ;; Don't ask, just save
      (setq eshell-save-history-on-exit t))

  ;; See: https://github.com/kaihaosw/eshell-prompt-extras
  (use-package eshell-prompt-extras
    :ensure t
    :init
    (progn
      (setq eshell-highlight-prompt nil
            epe-git-dirty-char " Ϟ"
            ;; epe-git-dirty-char "*"
            eshell-prompt-function 'epe-theme-dakrone)))

  (defun eshell/magit ()
    "Function to open magit-status for the current directory"
    (interactive)
    (magit-status default-directory)
    nil))

  (use-package esh-autosuggest
    :ensure t
    :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC

I use a dedicated buffer for connection to my desktop, with a binding of =C-x
d=, if the buffer doesn't exist it is created.

#+BEGIN_SRC emacs-lisp
(defun deos/create-or-switch-to-delta-buffer ()
  "Switch to the *eshell delta* buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell-delta*")
      (switch-to-buffer "*eshell-delta*")
    (let ((eshell-buffer-name "*eshell-delta*"))
      (eshell))))

(global-set-key (kbd "C-x d") 'deos/create-or-switch-to-delta-buffer)

(defun deos/create-or-switch-to-eshell-1 ()
  "Switch to the *eshell* buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*")
      (switch-to-buffer "*eshell*")
    (let ((eshell-buffer-name "*eshell*"))
      (eshell))))

(defun deos/create-or-switch-to-eshell-2 ()
  "Switch to the *eshell*<2> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<2>")
      (switch-to-buffer "*eshell*<2>")
    (let ((eshell-buffer-name "*eshell*<2>"))
      (eshell))))

(defun deos/create-or-switch-to-eshell-3 ()
  "Switch to the *eshell*<3> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<3>")
      (switch-to-buffer "*eshell*<3>")
    (let ((eshell-buffer-name "*eshell*<3>"))
      (eshell))))

(defun deos/create-or-switch-to-eshell-4 ()
  "Switch to the *eshell*<4> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<4>")
      (switch-to-buffer "*eshell*<4>")
    (let ((eshell-buffer-name "*eshell*<4>"))
      (eshell))))

(defun deos/create-all-eshell-buffers ()
  "Create all my normal eshell buffers"
  (interactive)
  (let ((eshell-buffer-name "*eshell*")
        (default-directory "~/"))
    (eshell))
  (let ((eshell-buffer-name "*eshell*<2>")
        (default-directory "~/")) (eshell))
  (let ((eshell-buffer-name "*eshell*<3>")
        (default-directory "~/gitrepo"))
    (eshell))
  (let ((eshell-buffer-name "*eshell-delta*")
        (default-directory "~/.emacs.d"))
    (eshell))
  (let ((eshell-buffer-name "*eshell downloads*")
        (default-directory "~/Downloads"))
    (eshell)))

(global-set-key (kbd "M-@") #'deos/create-all-eshell-buffers)

(global-set-key (kbd "H-1") 'deos/create-or-switch-to-eshell-1)
(global-set-key (kbd "H-2") 'deos/create-or-switch-to-eshell-2)
(global-set-key (kbd "H-3") 'deos/create-or-switch-to-eshell-3)
(global-set-key (kbd "H-4") 'deos/create-or-switch-to-eshell-4)
(global-set-key (kbd "s-1") 'deos/create-or-switch-to-eshell-1)
(global-set-key (kbd "s-2") 'deos/create-or-switch-to-eshell-2)
(global-set-key (kbd "s-3") 'deos/create-or-switch-to-eshell-3)
(global-set-key (kbd "s-4") 'deos/create-or-switch-to-eshell-4)
(global-set-key (kbd "M-1") 'deos/create-or-switch-to-eshell-1)
(global-set-key (kbd "M-2") 'deos/create-or-switch-to-eshell-2)
(global-set-key (kbd "M-3") 'deos/create-or-switch-to-eshell-3)
(global-set-key (kbd "M-4") 'deos/create-or-switch-to-eshell-4)
#+END_SRC

Also, add the buffer stack option to eshell

#+BEGIN_SRC emacs-lisp
(use-package esh-buf-stack
  :ensure t
  :commands eshell-push-command
  :config
  (setup-eshell-buf-stack)
  (define-key eshell-mode-map (kbd "M-q") 'eshell-push-command))
#+END_SRC

Indicate the exit status of the previous command using the eshell-fringe-status
package. Eh, disabled this for now, not sure I actually like it.

#+BEGIN_SRC emacs-lisp
(use-package eshell-fringe-status
  :disabled t
  :ensure t
  :init
  (add-hook 'eshell-mode-hook 'eshell-fringe-status-mode))
#+END_SRC
** Open an eshell window here
:PROPERTIES:
:CUSTOM_ID: h:27886c4c-b283-496d-ac41-1fe2bdcaf977
:END:

#+BEGIN_SRC emacs-lisp
(defun eshell-here ()
  "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (height (/ (window-total-height) 3))
         (name   (car (last (split-string parent "/" t)))))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))

    (insert (concat "ls"))
    (eshell-send-input)))

(global-set-key (kbd "C-!") #'eshell-here)
#+END_SRC

And some nice glue for quickly closing eshell windows

#+BEGIN_SRC emacs-lisp
(defun eshell/x ()
  "Closes the EShell session and gets rid of the EShell window."
   (delete-window)
   (eshell/exit))
#+END_SRC

** Open an eshell window there
:PROPERTIES:
:CUSTOM_ID: h:321c7f37-a36f-4482-9727-88b651a452d1
:END:

Like opening one here, but for remote hosts

#+BEGIN_SRC emacs-lisp
(defun eshell-there (host)
  (interactive "sHost: ")
  (let ((default-directory (format "/%s:" host)))
    (eshell host)))
#+END_SRC
* File Browsing
** Directory Editing and Navigation
#+BEGIN_SRC emacs-lisp
(defun deos/dired-mode-hook ()
      (setq-local truncate-lines t))

    (use-package dired
      :bind ("C-x C-j" . dired-jump)
      :config
      (use-package dired-x
        :init (setq-default dired-omit-files-p t)
        :config
        (add-to-list 'dired-omit-extensions ".DS_Store"))
      (customize-set-variable 'diredp-hide-details-initially-flag nil)
      (use-package dired+
        :disabled t
        :ensure t)
      (use-package dired-aux
        :init
        (use-package dired-async
          :ensure async))
      (put 'dired-find-alternate-file 'disabled nil)
      (setq ls-lisp-dirs-first t
            dired-recursive-copies 'always
            dired-recursive-deletes 'always
            dired-dwim-target t
            ;; -F marks links with @
            dired-ls-F-marks-symlinks t
            delete-by-moving-to-trash t
            ;; Don't auto refresh dired
            global-auto-revert-non-file-buffers nil
            wdired-allow-to-change-permissions t)
      (define-key dired-mode-map (kbd "C-M-u") #'dired-up-directory)
      (define-key dired-mode-map (kbd "M-o") #'my/dired-open)
      (define-key dired-mode-map (kbd "C-x C-q") #'wdired-change-to-wdired-mode)
      (bind-key "l" #'dired-up-directory dired-mode-map)
      (bind-key "M-!" #'async-shell-command dired-mode-map)
      (add-hook 'dired-mode-hook 'deos/turn-on-hl-line)
      (add-hook 'dired-mode-hook #'deos/dired-mode-hook))
#+END_SRC

** Quick-preview provides a nice preview of the thing under the cursor
#+BEGIN_SRC emacs-lisp
(use-package quick-preview
  :ensure t
  :init
  (global-set-key (kbd "C-c q") 'quick-preview-at-point)
  (define-key dired-mode-map (kbd "Q") 'quick-preview-at-point))
#+END_SRC

** Let's use async for everything in dired
#+BEGIN_SRC emacs-lisp
(use-package async :ensure t)
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+END_SRC

** Filter dired results with a filter
#+BEGIN_SRC emacs-lisp
    (use-package dired-narrow
      :ensure t
      :bind (:map dired-mode-map ("/" . dired-narrow)))
#+END_SRC

** Icons in a buffer
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)

(use-package all-the-icons-dired
  :ensure t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC

** Neotree
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :config
  (global-set-key (kbd "C-c n") 'neotree-toggle)
  (setq neo-theme 'arrow)
  (setq neo-window-fixed-size nil)
  (setq neo-smart-open t)
  (setq neo-window-width 40)
  (setq neo-default-system-application "open"))
#+END_SRC
* Git
** Magit
The be all, end all mode for all things git
#+BEGIN_SRC emacs-lisp
    (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status))
    :init (add-hook 'magit-mode-hook 'deos/turn-on-hl-line)
    :config
    (setq git-commit-summary-max-length 70)
    (setenv "GIT_PAGER" "")
    (if (file-exists-p "/usr/local/bin/emacsclient")
        (setq magit-emacsclient-executable (executable-find "emacsclient")))
    (defun deos/magit-browse ()
      "Browse to the project's github URL, if available"
      (interactive)
      (let ((url (with-temp-buffer
                            (unless (zerop (call-process-shell-command
                                            "git remote -v" nil t))
                              (error "Failed: 'git remote -v'"))
                            (goto-char (point-min))
                            (when (re-search-forward
                                   "github\\.com[:/]\\(.+?\\)\\.git" nil t)
                              (format "https://github.com/%s" (match-string 1))))))
        (unless url
          (error "Can't find repository URL"))
        (browse-url url)))

  (define-key magit-mode-map (kbd "C-c C-b") #'deos/magit-browse)
  ;; Magit has its own binding, so re-bind them
  (bind-key "M-1" #'deos/create-or-switch-to-eshell-1 magit-mode-map)
  (bind-key "M-2" #'deos/create-or-switch-to-eshell-2 magit-mode-map)
  (bind-key "M-3" #'deos/create-or-switch-to-eshell-3 magit-mode-map)
  (bind-key "M-4" #'deos/create-or-switch-to-eshell-4 magit-mode-map)

  ;; Allow gpg signing merge commits
  (magit-define-popup-option 'magit-merge-popup
                             ?S "Sign using gpg" "--gpg-sign="
                             #'magit-read-gpg-secret-key))
#+END_SRC
** Git Fringe
This helps visualize version changes in a file
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure t
  :when window-system
  :defer t
  :bind (("C-x P" . git-gutter:popup-hunk)
         ("C-x p" . git-gutter:previous-hunk)
         ("C-x n" . git-gutter:next-hunk)
         ("C-c G" . git-gutter:popup-hunk))
  :diminish ""
  :init
  (add-hook 'prog-mode-hook #'git-gutter-mode)
  (add-hook 'text-mode-hook #'git-gutter-mode)
  :config
  (use-package git-gutter-fringe
    :ensure t
    :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
        [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
        nil nil 'center))))
#+END_SRC
** Various Git helpers
#+BEGIN_SRC emacs-lisp
(use-package git-messenger
  :ensure t
  :commands git-messenger:popup-message
  :bind (("C-c M" . git-messenger:popup-message))
  :config
  (setq git-messenger:show-detail t))

  (use-package browse-at-remote
  :ensure t
  :commands browse-at-remote
  :bind ("C-c g g" . browse-at-remote))

  (use-package git-timemachine
  :ensure t)

  (use-package git-annex
  :ensure t)

  (use-package magit-annex
  :ensure t)

  (use-package ediff
  :init
  (setq
   ;; Always split nicely for wide screens
   ediff-split-window-function 'split-window-horizontally)
  (defun ediff-copy-both-to-C ()
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents
       ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents
       ediff-current-difference 'B ediff-control-buffer))))
  (defun add-d-to-ediff-mode-map ()
    (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
  (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map))

  (defhydra deos/hydra-smerge
  (:color red :hint nil
          :pre (smerge-mode 1))
  "
^Move^ ^Keep^ ^Diff^ ^Pair^
------------------------------------------------------
_n_ext _b_ase _R_efine _<_: base-mine
_p_rev _m_ine _E_diff _=_: mine-other
^ ^ _o_ther _C_ombine _>_: base-other
^ ^ _a_ll _r_esolve
_q_uit _RET_: current
"
  ("RET" smerge-keep-current)
  ("C" smerge-combine-with-next)
  ("E" smerge-ediff)
  ("R" smerge-refine)
  ("a" smerge-keep-all)
  ("b" smerge-keep-base)
  ("m" smerge-keep-mine)
  ("n" smerge-next)
  ("o" smerge-keep-other)
  ("p" smerge-prev)
  ("r" smerge-resolve)
  ("<" smerge-diff-base-mine)
  ("=" smerge-diff-mine-other)
  (">" smerge-diff-base-other)
  ("q" nil :color blue))
#+END_SRC
* Programming Modes
** Python
#+BEGIN_SRC emacs-lisp
(use-package python
  :config
  (setq-default python-indent-offset 2)
  (define-key python-mode-map (kbd "<backtab>") 'python-back-indent))

(when (executable-find "jupyter")
  (use-package ob-ipython
    :ensure t
    :config
    (use-package company
      :config
      (add-to-list 'company-backends 'company-ob-ipython))
    (add-to-list 'org-latex-minted-langs '(ipython "python"))))

(use-package virtualenvwrapper
  :ensure t
  :defer t
  :init
  (progn
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location (or (getenv "WORKON_HOME")
                            "~/.virtualenvs"))))
;; this requires some setup pip install jedi flake8 autopep8 yapf
(use-package elpy
  :ensure t
  :defer t
  :init
  (elpy-enable)
  :config
  (setq elpy-test-django-with-manage t))

(use-package anaconda-mode
  :ensure t
  :config
  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC
*** Kivy
#+BEGIN_SRC emacs-lisp
(use-package kivy-mode
  :ensure t
  :mode ("\\.kv\\'" . kivy-mode))
#+END_SRC
** C
#+BEGIN_SRC emacs-lisp
    (use-package irony
      :ensure t
      :hook (c-mode . irony-mode))
  (use-package company-irony
    :ensure t
    :config
    (add-to-list 'company-backends 'company-irony))
(use-package flycheck-irony
  :ensure t
  :hook (flycheck-mode . flycheck-irony-setup))
#+END_SRC
** C Sharp
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :ensure t)

(use-package omnisharp
  :ensure t
  :hook ((csharp-mode . omnisharp-mode)
         ;; TODO: 'before-save runs globally - make this buffer local?
         (before-save . omnisharp-code-format-entire-file))
  :config
  (add-to-list 'company-backends 'company-omnisharp))
#+END_SRC
** Groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :ensure t
  :config
  (setq groovy-indent-offset 2))
#+END_SRC
** Java
Prior art from https://github.com/dakrone/eos/blob/master/eos-java.org
*** Which major mode
let's try all of the major ones
#+BEGIN_SRC emacs-lisp
(setq deos/use-meghanda nil)
(setq deos/use-eclim nil)
(setq deos/use-lsp nil)
#+END_SRC

*** What style?
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'c-default-style
                        '((java-mode . "google-c-style")
                          (awk-mode . "awk")
                          (other . "google-c-style")))
#+END_SRC

*** Setup java mode
#+BEGIN_SRC emacs-lisp
(use-package shut-up :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun deos/setup-java ()
  (interactive)
  (define-key java-mode-map (kbd "M-,") 'pop-tag-mark)
  (define-key java-mode-map (kbd "C-c M-i") 'java-imports-add-import-dwim)
  (define-key java-mode-map (kbd "C-c C-b") 'bool-flip-do-flip)
  (c-set-style "google-c-style" t)
  (subword-mode 1)
  (shut-up (toggle-truncate-lines 1))
  (setq-local fci-rule-column 99)
  (setq-local fill-column 100)
  (when (fboundp 'deos/turn-on-whitespace-mode)
    (whitespace-mode -1)
    (deos/turn-on-whitespace-mode))
  ;; hide the initial comment in the file (usually a license) if hs-minor-mode
  ;; is enabled
  (when (boundp' hs-minor-mode)
    (hs-hide-initial-comment-block)))
(add-hook 'java-mode-hook #'deos/setup-java)
(require 'compile)
(add-to-list 'compilation-error-regexp-alist
             '("^:[^/.\n]+\\(/.+\\):\\([[:digit:]]+\\):" 1 2))
#+END_SRC

*** Backspace deletes whole line
#+BEGIN_SRC emacs-lisp
(use-package smart-backspace
  :ensure t
  :bind ("<C-M-backspace>" . smart-backspace))
#+END_SRC

*** Java imports
#+BEGIN_SRC emacs-lisp
(use-package java-imports
  :ensure t
  :config
  (setq java-imports-find-block-function 'java-imports-find-place-sorted-block)
  (add-hook 'java-mode-hook 'java-imports-scan-file))
#+END_SRC

*** Eclim
#+BEGIN_SRC emacs-lisp
(use-package eclim
  :ensure t
  :disabled t
  :init
  ;; only show errors
  (setq-default eclim--problems-filter "e")
  (when deos/use-eclim
    (add-hook 'java-mode-hook #'eclim-mode)
    (use-package company-emacs-eclim
      :ensure t
      :init (company-emacs-eclim-setup))))
#+END_SRC

*** SDKman
First you have to install sdkman http://sdkman.io
#+BEGIN_SRC emacs-lisp
(add-to-list 'tramp-remote-path "/home/d")
#+END_SRC

** Yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t)
#+END_SRC

** Javascript
Indent to 2 spaces
#+BEGIN_SRC emacs-lisp
(setq-default js-indent-level 2)
#+END_SRC

Use JS2 mode
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode "\\.js\\'"
  :config
  (setq-default js2-ignored-warnings '("msg.extra.trailing.comma")))
#+END_SRC

Use JS2-Refactor for refactoring goodness
#+BEGIN_SRC emacs-lisp
(use-package js2-refactor
  :ensure t
  :config
  (js2r-add-keybindings-with-prefix "C-c C-m")
  (add-hook 'js2-mode-hook 'js2-refactor-mode))
#+END_SRC

Use RJSX mode for all your templating language needs
#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :ensure t)
#+END_SRC

Make your JS oh so pretty
#+BEGIN_SRC emacs-lisp
(use-package prettier-js
  :ensure t
  :config
  (setq prettier-js-args '(
                           "--trailing-comma" "es5"
                           "--single-quote" "true"
                           "--print-width" "100"
                           ))
  (add-hook 'js2-mode-hook 'prettier-js-mode)
  (add-hook 'rjsx-mode-hook 'prettier-js-mode))
#+END_SRC

Document your JS with js-doc
#+BEGIN_SRC emacs-lisp
(use-package js-doc
  :ensure t
  :bind (:map js2-mode-map
              ("C-c i" . js-doc-insert-function-doc)
              ("@" . js-doc-insert-tag))
  :config
  (setq js-doc-mail-address "dwnewman78@gmail.com"
        js-doc-author (format "Daniel Newman <%s>" js-doc-mail-address)
        js-doc-url "danlovesprogramming.com"
        js-doc-license "MIT License"))
#+END_SRC

Use projects eslint if it is present
#+BEGIN_SRC emacs-lisp
(defun my/use-eslint-from-node-modules ()
  "Set local eslint if available."
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (eslint (and root
                      (expand-file-name "node_modules/eslint/bin/eslint.js"
                                        root))))
    (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))
#+END_SRC

** Web
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html\\'")
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-engines-alist
        '(("django" . "focus/.*\\.html\\'")
          ("ctemplate" . "realtimecrm/.*\\.html\\'"))))
#+END_SRC

*** Web beautify
Beautify your web code with web-beautify
NOTE: You have to install it globally with "npm install -g js-beautify"
#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :ensure t
  :bind (:map web-mode-map
              ("C-c b" . web-beautify-html)
              :map js2-mode-map
              ("C-c b" . web-beautify-js)))
#+END_SRC

* Extras
** Stack Overflow
SX is a stack overflow client that you can use in Emacs
#+BEGIN_SRC emacs-lisp
(use-package sx
  :ensure t
  :config
  (bind-keys :prefix "C-c s"
             :prefix-map my-sx-map
             :prefix-docstring "Global keymap for SX."
             ("q" . sx-tab-all-questions)
             ("i" . sx-inbox)
             ("o" . sx-open-link)
             ("u" . sx-tab-unanswered-my-tags)
             ("a" . sx-ask)
             ("s" . sx-search)))
#+END_SRC
** Web Browsing
Browse any url under the cursor
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x m") 'browse-url-at-point)
#+END_SRC
*** EWW
I rather like eww for browsing inside Emacs but some sites don't work well so I open them in an
external browser
#+BEGIN_SRC emacs-lisp
(use-package eww
  :defer t
  :init
  (setq browse-url-browser-function
        '((".*google.*maps.*" . browse-url-generic)
          ;; Github goes to firefox, but not gist
          ("corp.digitalreasoning.com" . browse-url-generic)
          ("http.*\/\/github.com" . browse-url-generic)
          ("groups.google.com" . browse-url-generic)
          ("docs.google.com" . browse-url-generic)
          ("melpa.org" . browse-url-generic)
          ("build.*\.elastic.co" . browse-url-generic)
          (".*-ci\.elastic.co" . browse-url-generic)
          ("internal-ci\.elastic\.co" . browse-url-generic)
          ("zendesk\.com" . browse-url-generic)
          ("salesforce\.com" . browse-url-generic)
          ("stackoverflow\.com" . browse-url-generic)
          ("apache\.org\/jira" . browse-url-generic)
          ("thepoachedegg\.net" . browse-url-generic)
          ("zoom.us" . browse-url-generic)
          ("t.co" . browse-url-generic)
          ("twitter.com" . browse-url-generic)
          ("\/\/a.co" . browse-url-generic)
          ("youtube.com" . browse-url-generic)
          ("amazon.com" . browse-url-generic)
          ("." . eww-browse-url)))
  (setq shr-external-browser 'browse-url-generic)
  (if *is-a-mac*
        (setq browse-url-generic-program "open")
    (setq browse-url-generic-program (executable-find "firefox")))
  (add-hook 'eww-mode-hook #'toggle-word-wrap)
  (add-hook 'eww-mode-hook #'visual-line-mode)
  :config
  (use-package s :ensure t)
  (define-key eww-mode-map "o" 'eww)
  (define-key eww-mode-map "O" 'eww-browse-with-external-browser)
  (define-key eww-mode-map "j" 'next-line)
  (define-key eww-mode-map "k" 'previous-line)

  (use-package eww-lnum
    :ensure t
    :config
    (bind-key "f" #'eww-lnum-follow eww-mode-map)
    (bind-key "U" #'eww-lnum-universal eww-mode-map)))
#+END_SRC

Vimperator for EWW
#+BEGIN_SRC emacs-lisp
(use-package link-hint
  :ensure t
  :bind ("C-c f" . link-hint-open-link))
#+END_SRC
** Chat
Here are some utilities to facilitate text communications between carbon based lifeforms. Nanu-Nanu
#+BEGIN_SRC emacs-lisp :tangle no
(use-package jabber
  :ensure t
  :init
  (setq jabber-history-enabled t)
  :config
  (add-to-list 'jabber-account-list '("dwnewman78@gmail.com"
  (:network-server . "talk.google.com")
  (:connection-type . ssl)))
  (add-hook 'jabber-post-connect-hooks 'jabber-autoaway-start)
  (setq
  jabber-history-enabled t
  jabber-use-global-history nil
  jabber-backlog-number 40
  jabber-backlog-days 30))
#+END_SRC
